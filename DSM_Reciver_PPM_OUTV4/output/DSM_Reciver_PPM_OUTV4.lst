FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x34 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
                                        (0108)     ;halt                           ;Stop execution if power falls too low
0004: 7D 19 DD LJMP  _LVD_ISR           (0109)     ljmp _LVD_ISR	
0007: 7E       RETI                     (0110)     reti
                                        (0111) 
                                        (0112)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0113)     // call	void_handler
0008: 7E       RETI                     (0114)     reti
                                        (0115) 
                                        (0116)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0117)     // call	void_handler
000C: 7E       RETI                     (0118)     reti
                                        (0119) 
                                        (0120)     org   18h                      ;VC3 Interrupt Vector
                                        (0121)     // call	void_handler
0018: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 1E 26 LJMP  PSoC_GPIO_ISR      (0125)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0129)     // call	void_handler
0020: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 04 EC LJMP  RST_GetState|RST_Invert|_PWM16_1_ISR(0133)     ljmp	_PWM16_1_ISR
0027: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0137)     // call	void_handler
0028: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 04 71 LJMP  _Timer8_1_ISR      (0141)     ljmp	_Timer8_1_ISR
002F: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0145)     // call	void_handler
0060: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   64h                      ;Sleep Timer Interrupt Vector
0064: 7D 04 92 LJMP  _SleepTimer_1_ISR  (0149)     ljmp	_SleepTimer_1_ISR
0067: 7E       RETI                     (0150)     reti
0068: 71 10    OR    F,0x10             
                                        (0151)     ;---------------------------------------------------
                                        (0152)     ; Insert your custom code above this banner
                                        (0153)     ;---------------------------------------------------
                                        (0154)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0155) 
                                        (0156) ;-----------------------------------------------------------------------------
                                        (0157) ;  Start of Execution.
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0160) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0161) ;
                                        (0162) 
                                        (0163) IF	(TOOLCHAIN & HITECH)
                                        (0164)  	AREA PD_startup(CODE, REL, CON)
                                        (0165) ELSE
                                        (0166)     org 68h
                                        (0167) ENDIF
                                        (0168) __Start:
                                        (0169) 
                                        (0170)     ; initialize SMP values for voltage stabilization, if required,
                                        (0171)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0172)     ; least for now. 
                                        (0173)     ;
                                        (0174)     M8C_SetBank1
006A: 62 E3 81 MOV   REG[0xE3],0x81     (0175)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0176)     M8C_SetBank0
                                        (0177) 
                                        (0178) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0179) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0180)     M8C_EnableWatchDog
                                        (0181) ENDIF
                                        (0182) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0183)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0184) 
                                        (0185)     ;---------------------------
                                        (0186)     ; Set up the Temporary stack
                                        (0187)     ;---------------------------
                                        (0188)     ; A temporary stack is set up for the SSC instructions.
                                        (0189)     ; The real stack start will be assigned later.
                                        (0190)     ;
                                        (0191) _stack_start:          equ 80h
0075: 50 80    MOV   A,0x80             (0192)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0193)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
007B: 5D D0    MOV   A,REG[0xD0]        
007D: 08       PUSH  A                  
007E: 62 D0 00 MOV   REG[0xD0],0x0      
0081: 55 FA 01 MOV   [_ramareas_end+105],0x1
0084: 4F       MOV   X,SP               
0085: 5B       MOV   A,X                
0086: 01 03    ADD   A,0x3              
0088: 53 F9    MOV   [_ramareas_end+104],A
008A: 55 F8 3A MOV   [_ramareas_end+103],0x3A
008D: 50 06    MOV   A,0x6              
008F: 00       SWI                      
0090: 71 10    OR    F,0x10             
0092: 51 F9    MOV   A,[_ramareas_end+104]
0094: 60 E8    MOV   REG[0xE8],A        
0096: 51 F8    MOV   A,[_ramareas_end+103]
0098: 60 EA    MOV   REG[0xEA],A        
009A: 70 EF    AND   F,0xEF             
009C: 18       POP   A                  
009D: 60 D0    MOV   REG[0xD0],A        
                                        (0194) 
                                        (0195)     ;------------------------
                                        (0196)     ; Set Power-related Trim 
                                        (0197)     ;------------------------
                                        (0198)     
                                        (0199) M8C_ClearWDTAndSleep
                                        (0200) 
                                        (0201) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0202)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0203)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0204)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0205)  ENDIF
                                        (0206) ENDIF ; 5.0 V Operation
                                        (0207) 
                                        (0208) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0209)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0210)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0211)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0212)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0213)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0214)  ENDIF
                                        (0215) ENDIF ; 3.3 Volt Operation
                                        (0216) 
                                        (0217) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0218)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0219)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0220) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0221) 
                                        (0222) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0223)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0224)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0225) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0226) 
009F: 55 F8 00 MOV   [_ramareas_end+103],0x0(0227)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00A2: 55 F9 00 MOV   [_ramareas_end+104],0x0(0228)     mov  [bSSC_KEYSP], 0
00A5: 71 10    OR    F,0x10             
                                        (0229) 
                                        (0230)     ;---------------------------------------
                                        (0231)     ; Initialize Crystal Oscillator and PLL
                                        (0232)     ;---------------------------------------
                                        (0233) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0234)     M8C_SetBank1
                                        (0235)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0236)     M8C_SetBank0
                                        (0237)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0238) 
                                        (0239) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0240)     M8C_SetBank1
00A7: 62 E0 02 MOV   REG[0xE0],0x2      (0241)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00AA: 70 EF    AND   F,0xEF             
00AC: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0242)     M8C_SetBank0
                                        (0243)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0244) 
                                        (0245) ENDIF
                                        (0246) 
                                        (0247) 	;-------------------------------------------------------
                                        (0248)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0249)     ;-------------------------------------------------------
                                        (0250) 
                                        (0251)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0252) 
                                        (0253) IF (SYSCLK_SOURCE)
                                        (0254)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0255) ENDIF
                                        (0256)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0257) 
                                        (0258) IF	(TOOLCHAIN & HITECH)
                                        (0259)     ;---------------------------------------------
                                        (0260)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0261)     ;---------------------------------------------
                                        (0262) 	global		__Lstackps
                                        (0263) 	mov     a,low __Lstackps
                                        (0264) 	swap    a,sp
                                        (0265) 
                                        (0266) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0267)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0268)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0269)     RAM_SETPAGE_CUR 0
                                        (0270)     RAM_SETPAGE_MVW 0
                                        (0271)     RAM_SETPAGE_MVR 0
                                        (0272)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0273)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0274)     ELSE
                                        (0275)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0276)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0277) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0278) ELSE
                                        (0279)     ;---------------------------------------------
                                        (0280)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0281)     ;---------------------------------------------
                                        (0282) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0283)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0284)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
                                        (0285)     swap  A, SP
                                        (0286)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0287)     RAM_SETPAGE_CUR 0
                                        (0288)     RAM_SETPAGE_MVW 0
                                        (0289)     RAM_SETPAGE_MVR 0
                                        (0290) 
                                        (0291)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0292)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0293)   ELSE
                                        (0294)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0295)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0296) ELSE
00AF: 50 91    MOV   A,0x91             (0297)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00B1: 4E       SWAP  SP,A               (0298)     swap  SP, A
                                        (0299) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0300) ENDIF ;	TOOLCHAIN
                                        (0301) 
                                        (0302)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0303)     ;---------------------------------------------------
                                        (0304)     ; Insert your custom code below this banner
                                        (0305)     ;---------------------------------------------------
                                        (0306) 
                                        (0307)     ;---------------------------------------------------
                                        (0308)     ; Insert your custom code above this banner
                                        (0309)     ;---------------------------------------------------
                                        (0310)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0311) 
                                        (0312)     ;-------------------------
                                        (0313)     ; Load Base Configuration
                                        (0314)     ;-------------------------
                                        (0315)     ; Load global parameter settings and load the user modules in the
                                        (0316)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0317)     ; to minimize start up time; (2) We may still need to play with the
                                        (0318)     ; Sleep Timer.
                                        (0319)     ;
00B2: 7C 04 5E LCALL 0x045E             (0320)     lcall LoadConfigInit
                                        (0321) 
                                        (0322)     ;-----------------------------------
                                        (0323)     ; Initialize C Run-Time Environment
                                        (0324)     ;-----------------------------------
                                        (0325) IF ( C_LANGUAGE_SUPPORT )
                                        (0326) IF ( SYSTEM_SMALL_MEMORY_MODEL )
00B5: 50 00    MOV   A,0x0              (0327)     mov  A,0                           ; clear the 'bss' segment to zero
00B7: 55 17 20 MOV   [__r0],0x20        (0328)     mov  [__r0],<__bss_start
                                        (0329) BssLoop:
00BA: 3C 17 91 CMP   [__r0],0x91        (0330)     cmp  [__r0],<__bss_end
00BD: A0 05    JZ    0x00C3             (0331)     jz   BssDone
00BF: 3F 17    MVI   [__r0],A           (0332)     mvi  [__r0],A
00C1: 8F F8    JMP   0x00BA             (0333)     jmp  BssLoop
                                        (0334) BssDone:
00C3: 50 03    MOV   A,0x3              (0335)     mov  A,>__idata_start              ; copy idata to data segment
00C5: 57 0B    MOV   X,0xB              (0336)     mov  X,<__idata_start
00C7: 55 17 00 MOV   [__r0],0x0         (0337)     mov  [__r0],<__data_start
                                        (0338) IDataLoop:
00CA: 3C 17 09 CMP   [__r0],0x9         (0339)     cmp  [__r0],<__data_end
00CD: A0 0B    JZ    0x00D9             (0340)     jz   C_RTE_Done
00CF: 08       PUSH  A                  (0341)     push A
00D0: 28       ROMX                     (0342)     romx
00D1: 3F 17    MVI   [__r0],A           (0343)     mvi  [__r0],A
00D3: 18       POP   A                  (0344)     pop  A
00D4: 75       INC   X                  (0345)     inc  X
00D5: 09 00    ADC   A,0x0              (0346)     adc  A,0
00D7: 8F F2    JMP   0x00CA             (0347)     jmp  IDataLoop
00D9: 71 10    OR    F,0x10             
                                        (0348) 
                                        (0349) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0350) 
                                        (0351) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0352)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0353)                                        ; to use the Virtual Register page.
                                        (0354) 
                                        (0355)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0356)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0357)     ; text segment and may have been relocated by the Code Compressor.
                                        (0358)     ;
                                        (0359)     mov   A, >__pXIData                ; Get the address of the flash
                                        (0360)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                        (0361)     push  A
                                        (0362)     romx                               ; get the MSB of xidata's address
                                        (0363)     mov   [__r0], A
                                        (0364)     pop   A
                                        (0365)     inc   X
                                        (0366)     adc   A, 0
                                        (0367)     romx                               ; get the LSB of xidata's address
                                        (0368)     swap  A, X
                                        (0369)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0370)                                        ;   XIData structure list in flash
                                        (0371)     jmp   .AccessStruct
                                        (0372) 
                                        (0373)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0374)     ; values of C variables. Each structure contains 3 member elements.
                                        (0375)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0376)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0377)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0378)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0379)     ; value in the second member element, an unsigned byte:
                                        (0380)     ; (1) If the value of the second element is non-zero, it represents
                                        (0381)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0382)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0383)     ; the bytes are copied to the block of RAM.
                                        (0384)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0385)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0386)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0387) 
                                        (0388) .AccessNextStructLoop:
                                        (0389)     inc   X                            ; pXIData++
                                        (0390)     adc   A, 0
                                        (0391) .AccessStruct:                         ; Entry point for first block
                                        (0392)     ;
                                        (0393)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0394)     ;
                                        (0395)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                        (0396)     push  A
                                        (0397)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                        (0398)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                        (0399)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                        (0400)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                        (0401)     pop   A                            ; restore pXIData to [A,X]
                                        (0402)     inc   X                            ; pXIData++
                                        (0403)     adc   A, 0
                                        (0404)     push  A
                                        (0405)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                        (0406)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                        (0407)     pop   A                            ; restore pXIData to [A,X]
                                        (0408)     inc   X                            ; pXIData++ (point to size)
                                        (0409)     adc   A, 0
                                        (0410)     push  A
                                        (0411)     romx                               ; Get the size (CPU.A <- *pXIData)
                                        (0412)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                        (0413)     mov   [__r1], A                    ;             else downcount in __r1
                                        (0414)     pop   A                            ; restore pXIData to [A,X]
                                        (0415) 
                                        (0416) .CopyNextByteLoop:
                                        (0417)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0418)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0419)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0420)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0421)     ;
                                        (0422)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0423)     adc   A, 0
                                        (0424)     push  A
                                        (0425)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                        (0426)     mvi   [__r0], A                    ; Transfer the data to RAM
                                        (0427)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0428)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                        (0429)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0430)     inc   A
                                        (0431)     mov   reg[ MVW_PP], A
                                        (0432) .CopyLoopTail:
                                        (0433)     pop   A                            ; restore pXIData to [A,X]
                                        (0434)     dec   [__r1]                       ; End of this array in flash?
                                        (0435)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                        (0436)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0437) 
                                        (0438) .ClearRAMBlockToZero:
                                        (0439)     pop   A                            ; restore pXIData to [A,X]
                                        (0440)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0441)     adc   A, 0
                                        (0442)     push  A
                                        (0443)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                        (0444)     mov   [__r1], A                    ; Initialize downcounter
                                        (0445)     mov   A, 0                         ; Initialize source data
                                        (0446) 
                                        (0447) .ClearRAMBlockLoop:
                                        (0448)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0449)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0450)     ;
                                        (0451)     mvi   [__r0], A                    ; Clear a byte
                                        (0452)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0453)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                        (0454)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0455)     inc   A
                                        (0456)     mov   reg[ MVW_PP], A
                                        (0457)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0458) .ClearLoopTail:
                                        (0459)     dec   [__r1]                       ; Was this the last byte?
                                        (0460)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                        (0461)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                        (0462)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0463) 
                                        (0464) .C_RTE_WrapUp:
                                        (0465)     pop   A                            ; balance stack
                                        (0466) 
                                        (0467) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0468) 
                                        (0469) C_RTE_Done:
                                        (0470) 
                                        (0471) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0472) 
                                        (0473)     ;-------------------------------
                                        (0474)     ; Voltage Stabilization for SMP
                                        (0475)     ;-------------------------------
                                        (0476) 
                                        (0477) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0478) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0479)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0480)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0481)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0482)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0483)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0484)     M8C_SetBank1
                                        (0485)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0486)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0487)     M8C_SetBank0
                                        (0488)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0489)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0490) .WaitFor2ms:
                                        (0491)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0492)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0493) ENDIF ; SMP is operational
                                        (0494) ENDIF ; 5.0V Operation
                                        (0495) 
                                        (0496)     ;-------------------------------
                                        (0497)     ; Set Power-On Reset (POR) Level
                                        (0498)     ;-------------------------------
                                        (0499)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0500)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0501)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0502)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0503)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0504) 
                                        (0505)     M8C_SetBank1
                                        (0506) 
                                        (0507) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0508)                                                ;  Yes, lowest trip already set
                                        (0509) ELSE                                           ;   No, must adjust POR...
                                        (0510) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
00DB: 43 E3 10 OR    REG[0xE3],0x10     (0511)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
00DE: 70 EF    AND   F,0xEF             
                                        (0512) ELSE
                                        (0513) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0514)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0515)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0516)  ELSE                                          ;    No, fast mode
                                        (0517)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                        (0518)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
                                        (0519)   ELSE ; 24HMz                                 ;
                                        (0520)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0521)   ENDIF ; 24MHz
                                        (0522)  ENDIF ; Slow Mode
                                        (0523) ENDIF ; 5.0V Operation
                                        (0524) ENDIF ; 3.3V Operation
                                        (0525) ENDIF ; 2.7V Operation
                                        (0526) 
                                        (0527)     M8C_SetBank0
                                        (0528) 
                                        (0529)     ;----------------------------
                                        (0530)     ; Wrap up and invoke "main"
                                        (0531)     ;----------------------------
                                        (0532) 
                                        (0533)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0534)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0535)     ;
00E0: 62 E0 00 MOV   REG[0xE0],0x0      (0536)     mov  reg[INT_MSK0],0
00E3: 71 10    OR    F,0x10             
                                        (0537) 
                                        (0538)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0539)     ;
                                        (0540)     M8C_SetBank1
00E5: 62 E0 02 MOV   REG[0xE0],0x2      (0541)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00E8: 70 EF    AND   F,0xEF             
                                        (0542)     M8C_SetBank0
                                        (0543) 
                                        (0544)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0545)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0546)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0547)     ;
00EA: 62 E2 00 MOV   REG[0xE2],0x0      (0548)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0549)                                    ; have been set during the boot process.
                                        (0550) IF	(TOOLCHAIN & HITECH)
                                        (0551) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0552) ELSE
                                        (0553) IF ENABLE_LJMP_TO_MAIN
                                        (0554)     ljmp  _main                    ; goto main (no return)
                                        (0555) ELSE
00ED: 7C 19 E9 LCALL _main              (0556)     lcall _main                    ; call main
                                        (0557) .Exit:
00F0: 8F FF    JMP   0x00F0             (0558)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0559) ENDIF
                                        (0560) ENDIF ; TOOLCHAIN
                                        (0561) 
                                        (0562)     ;---------------------------------
                                        (0563)     ; Library Access to Global Parms
                                        (0564)     ;---------------------------------
                                        (0565)     ;
                                        (0566)  bGetPowerSetting:
                                        (0567) _bGetPowerSetting:
                                        (0568)     ; Returns value of POWER_SETTING in the A register.
                                        (0569)     ; No inputs. No Side Effects.
                                        (0570)     ;
                                        (0571) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0572)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0573) ELSE
00F2: 50 08    MOV   A,0x8              (0574)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0575) ENDIF
00F4: 7F       RET                      (0576)     ret
                                        (0577) 
                                        (0578) IF	(TOOLCHAIN & HITECH)
                                        (0579) ELSE
                                        (0580)     ;---------------------------------
                                        (0581)     ; Order Critical RAM & ROM AREAs
                                        (0582)     ;---------------------------------
                                        (0583)     ;  'TOP' is all that has been defined so far...
                                        (0584) 
                                        (0585)     ;  ROM AREAs for C CONST, static & global items
                                        (0586)     ;
                                        (0587)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0588)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0589) __idata_start:
                                        (0590) 
                                        (0591)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0592) __func_lit_start:
                                        (0593) 
                                        (0594) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0595)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0596)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0597)     ; relocated by the code compressor, but the text area may shrink and
                                        (0598)     ; that moves xidata around.
                                        (0599)     ;
                                        (0600) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0601) ENDIF
                                        (0602) 
                                        (0603)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0604)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0605) 
                                        (0606)     ; CODE segment for general use
                                        (0607)     ;
                                        (0608)     AREA text (ROM, REL, CON)
                                        (0609) __text_start:
                                        (0610) 
                                        (0611)     ; RAM area usage
                                        (0612)     ;
                                        (0613)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0614) __data_start:
                                        (0615) 
                                        (0616)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0617)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0618)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0619) __bss_start:
                                        (0620) ENDIF ; TOOLCHAIN
                                        (0621) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.3191
0322: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_dsm_reciver
                                        (0019) AREA psoc_config(rom, rel)
                                        (0020) LoadConfigTBL_dsm_reciver:
                                        (0021) 	M8C_SetBank0
                                        (0022) ;  Global Register values Bank 0
0324: 62 60 04 MOV   REG[0x60],0x4      (0023) 	mov	reg[60h], 04h		; AnalogColumnInputSelect register (AMX_IN)
0327: 62 64 00 MOV   REG[0x64],0x0      (0024) 	mov	reg[64h], 00h		; AnalogComparatorControl0 register (CMP_CR0)
032A: 62 66 00 MOV   REG[0x66],0x0      (0025) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
032D: 62 61 00 MOV   REG[0x61],0x0      (0026) 	mov	reg[61h], 00h		; AnalogMuxBusConfig register (AMUXCFG)
0330: 62 E6 00 MOV   REG[0xE6],0x0      (0027) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
0333: 62 E7 00 MOV   REG[0xE7],0x0      (0028) 	mov	reg[e7h], 00h		; DecimatorControl_1 register (DEC_CR1)
0336: 62 D6 00 MOV   REG[0xD6],0x0      (0029) 	mov	reg[d6h], 00h		; I2CConfig register (I2CCFG)
0339: 62 62 00 MOV   REG[0x62],0x0      (0030) 	mov	reg[62h], 00h		; PWM_Control register (PWM_CR)
033C: 62 B0 30 MOV   REG[0xB0],0x30     (0031) 	mov	reg[b0h], 30h		; Row_0_InputMux register (RDI0RI)
033F: 62 B1 01 MOV   REG[0xB1],0x1      (0032) 	mov	reg[b1h], 01h		; Row_0_InputSync register (RDI0SYN)
0342: 62 B2 00 MOV   REG[0xB2],0x0      (0033) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
0345: 62 B3 3C MOV   REG[0xB3],0x3C     (0034) 	mov	reg[b3h], 3ch		; Row_0_LogicSelect_0 register (RDI0LT0)
0348: 62 B4 3F MOV   REG[0xB4],0x3F     (0035) 	mov	reg[b4h], 3fh		; Row_0_LogicSelect_1 register (RDI0LT1)
034B: 62 B5 20 MOV   REG[0xB5],0x20     (0036) 	mov	reg[b5h], 20h		; Row_0_OutputDrive_0 register (RDI0SRO0)
034E: 62 B6 14 MOV   REG[0xB6],0x14     (0037) 	mov	reg[b6h], 14h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0038) ;  Instance name CH0_OUT, User Module LED
                                        (0039) ;  Instance name CH1_OUT, User Module LED
                                        (0040) ;  Instance name CH2_OUT, User Module LED
                                        (0041) ;  Instance name CH3_OUT, User Module LED
                                        (0042) ;  Instance name CH4_OUT, User Module LED
                                        (0043) ;  Instance name CH5_OUT, User Module LED
                                        (0044) ;  Instance name CS_PIN, User Module LED
                                        (0045) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0046) ;  Instance name LED_1, User Module LED
                                        (0047) ;  Instance name PWM16_1, User Module PWM16
                                        (0048) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
0351: 62 23 00 MOV   REG[0x23],0x0      (0049) 	mov	reg[23h], 00h		;PWM16_1_CONTROL_LSB_REG(DBB00CR0)
0354: 62 21 C8 MOV   REG[0x21],0xC8     (0050) 	mov	reg[21h], c8h		;PWM16_1_PERIOD_LSB_REG(DBB00DR1)
0357: 62 22 C8 MOV   REG[0x22],0xC8     (0051) 	mov	reg[22h], c8h		;PWM16_1_COMPARE_LSB_REG(DBB00DR2)
                                        (0052) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
035A: 62 27 00 MOV   REG[0x27],0x0      (0053) 	mov	reg[27h], 00h		;PWM16_1_CONTROL_MSB_REG(DBB01CR0)
035D: 62 25 08 MOV   REG[0x25],0x8      (0054) 	mov	reg[25h], 08h		;PWM16_1_PERIOD_MSB_REG(DBB01DR1)
0360: 62 26 00 MOV   REG[0x26],0x0      (0055) 	mov	reg[26h], 00h		;PWM16_1_COMPARE_MSB_REG(DBB01DR2)
                                        (0056) ;  Instance name RST, User Module LED
                                        (0057) ;  Instance name SPIM_1, User Module SPIM
                                        (0058) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
0363: 62 2B 00 MOV   REG[0x2B],0x0      (0059) 	mov	reg[2bh], 00h		;SPIM_1_CONTROL_REG  (DCB02CR0)
0366: 62 29 00 MOV   REG[0x29],0x0      (0060) 	mov	reg[29h], 00h		;SPIM_1_TX_BUFFER_REG(DCB02DR1)
0369: 62 2A 00 MOV   REG[0x2A],0x0      (0061) 	mov	reg[2ah], 00h		;SPIM_1_RX_BUFFER_REG(DCB02DR2)
                                        (0062) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0063) ;  Instance name Timer8_1, User Module Timer8
                                        (0064) ;       Instance name Timer8_1, Block Name TIMER8(DCB03)
036C: 62 2F 04 MOV   REG[0x2F],0x4      (0065) 	mov	reg[2fh], 04h		;Timer8_1_CONTROL_REG(DCB03CR0)
036F: 62 2D FF MOV   REG[0x2D],0xFF     (0066) 	mov	reg[2dh], ffh		;Timer8_1_PERIOD_REG(DCB03DR1)
0372: 62 2E 00 MOV   REG[0x2E],0x0      (0067) 	mov	reg[2eh], 00h		;Timer8_1_COMPARE_REG(DCB03DR2)
0375: 71 10    OR    F,0x10             
                                        (0068) 	M8C_SetBank1
                                        (0069) ;  Global Register values Bank 1
0377: 62 61 00 MOV   REG[0x61],0x0      (0070) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
037A: 62 6B 04 MOV   REG[0x6B],0x4      (0071) 	mov	reg[6bh], 04h		; AnalogColumnClockDivide register (CLK_CR3)
037D: 62 60 00 MOV   REG[0x60],0x0      (0072) 	mov	reg[60h], 00h		; AnalogColumnClockSelect register (CLK_CR0)
0380: 62 62 80 MOV   REG[0x62],0x80     (0073) 	mov	reg[62h], 80h		; AnalogIOControl_0 register (ABF_CR0)
0383: 62 67 00 MOV   REG[0x67],0x0      (0074) 	mov	reg[67h], 00h		; AnalogLUTControl0 register (ALT_CR0)
0386: 62 64 00 MOV   REG[0x64],0x0      (0075) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
0389: 62 FD 00 MOV   REG[0xFD],0x0      (0076) 	mov	reg[fdh], 00h		; DAC_Control register (DAC_CR)
038C: 62 D1 00 MOV   REG[0xD1],0x0      (0077) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
038F: 62 D3 00 MOV   REG[0xD3],0x0      (0078) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
0392: 62 D0 00 MOV   REG[0xD0],0x0      (0079) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
0395: 62 D2 00 MOV   REG[0xD2],0x0      (0080) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
0398: 62 E1 B1 MOV   REG[0xE1],0xB1     (0081) 	mov	reg[e1h], b1h		; OscillatorControl_1 register (OSC_CR1)
039B: 62 E2 01 MOV   REG[0xE2],0x1      (0082) 	mov	reg[e2h], 01h		; OscillatorControl_2 register (OSC_CR2)
039E: 62 DF FF MOV   REG[0xDF],0xFF     (0083) 	mov	reg[dfh], ffh		; OscillatorControl_3 register (OSC_CR3)
03A1: 62 DE 02 MOV   REG[0xDE],0x2      (0084) 	mov	reg[deh], 02h		; OscillatorControl_4 register (OSC_CR4)
03A4: 62 DD 00 MOV   REG[0xDD],0x0      (0085) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
03A7: 62 D8 00 MOV   REG[0xD8],0x0      (0086) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
03AA: 62 D9 00 MOV   REG[0xD9],0x0      (0087) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
03AD: 62 DA 00 MOV   REG[0xDA],0x0      (0088) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
03B0: 62 DB 00 MOV   REG[0xDB],0x0      (0089) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
                                        (0090) ;  Instance name CH0_OUT, User Module LED
                                        (0091) ;  Instance name CH1_OUT, User Module LED
                                        (0092) ;  Instance name CH2_OUT, User Module LED
                                        (0093) ;  Instance name CH3_OUT, User Module LED
                                        (0094) ;  Instance name CH4_OUT, User Module LED
                                        (0095) ;  Instance name CH5_OUT, User Module LED
                                        (0096) ;  Instance name CS_PIN, User Module LED
                                        (0097) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0098) ;  Instance name LED_1, User Module LED
                                        (0099) ;  Instance name PWM16_1, User Module PWM16
                                        (0100) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
03B3: 62 20 11 MOV   REG[0x20],0x11     (0101) 	mov	reg[20h], 11h		;PWM16_1_FUNC_LSB_REG(DBB00FN)
03B6: 62 21 15 MOV   REG[0x21],0x15     (0102) 	mov	reg[21h], 15h		;PWM16_1_INPUT_LSB_REG(DBB00IN)
03B9: 62 22 40 MOV   REG[0x22],0x40     (0103) 	mov	reg[22h], 40h		;PWM16_1_OUTPUT_LSB_REG(DBB00OU)
                                        (0104) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
03BC: 62 24 39 MOV   REG[0x24],0x39     (0105) 	mov	reg[24h], 39h		;PWM16_1_FUNC_MSB_REG(DBB01FN)
03BF: 62 25 35 MOV   REG[0x25],0x35     (0106) 	mov	reg[25h], 35h		;PWM16_1_INPUT_MSB_REG(DBB01IN)
03C2: 62 26 46 MOV   REG[0x26],0x46     (0107) 	mov	reg[26h], 46h		;PWM16_1_OUTPUT_MSB_REG(DBB01OU)
                                        (0108) ;  Instance name RST, User Module LED
                                        (0109) ;  Instance name SPIM_1, User Module SPIM
                                        (0110) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
03C5: 62 28 06 MOV   REG[0x28],0x6      (0111) 	mov	reg[28h], 06h		;SPIM_1_FUNCTION_REG (DCB02FN)
03C8: 62 29 C5 MOV   REG[0x29],0xC5     (0112) 	mov	reg[29h], c5h		;SPIM_1_INPUT_REG    (DCB02IN)
03CB: 62 2A 7D MOV   REG[0x2A],0x7D     (0113) 	mov	reg[2ah], 7dh		;SPIM_1_OUTPUT_REG   (DCB02OU)
                                        (0114) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0115) ;  Instance name Timer8_1, User Module Timer8
                                        (0116) ;       Instance name Timer8_1, Block Name TIMER8(DCB03)
03CE: 62 2C 20 MOV   REG[0x2C],0x20     (0117) 	mov	reg[2ch], 20h		;Timer8_1_FUNC_REG(DCB03FN)
03D1: 62 2D 11 MOV   REG[0x2D],0x11     (0118) 	mov	reg[2dh], 11h		;Timer8_1_INPUT_REG(DCB03IN)
03D4: 62 2E 40 MOV   REG[0x2E],0x40     (0119) 	mov	reg[2eh], 40h		;Timer8_1_OUTPUT_REG(DCB03OU)
03D7: 70 EF    AND   F,0xEF             
03D9: 70 EF    AND   F,0xEF             
                                        (0120) 	M8C_SetBank0
                                        (0121) ;  Ordered Global Register values
                                        (0122) 	M8C_SetBank0
03DB: 62 00 00 MOV   REG[0x0],0x0       (0123) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
03DE: 71 10    OR    F,0x10             
                                        (0124) 	M8C_SetBank1
03E0: 62 00 BC MOV   REG[0x0],0xBC      (0125) 	mov	reg[00h], bch		; Port_0_DriveMode_0 register (PRT0DM0)
03E3: 62 01 43 MOV   REG[0x1],0x43      (0126) 	mov	reg[01h], 43h		; Port_0_DriveMode_1 register (PRT0DM1)
03E6: 70 EF    AND   F,0xEF             
                                        (0127) 	M8C_SetBank0
03E8: 62 03 02 MOV   REG[0x3],0x2       (0128) 	mov	reg[03h], 02h		; Port_0_DriveMode_2 register (PRT0DM2)
03EB: 62 02 29 MOV   REG[0x2],0x29      (0129) 	mov	reg[02h], 29h		; Port_0_GlobalSelect register (PRT0GS)
03EE: 71 10    OR    F,0x10             
                                        (0130) 	M8C_SetBank1
03F0: 62 02 00 MOV   REG[0x2],0x0       (0131) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
03F3: 62 03 40 MOV   REG[0x3],0x40      (0132) 	mov	reg[03h], 40h		; Port_0_IntCtrl_1 register (PRT0IC1)
03F6: 70 EF    AND   F,0xEF             
                                        (0133) 	M8C_SetBank0
03F8: 62 01 40 MOV   REG[0x1],0x40      (0134) 	mov	reg[01h], 40h		; Port_0_IntEn register (PRT0IE)
03FB: 62 04 00 MOV   REG[0x4],0x0       (0135) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
03FE: 71 10    OR    F,0x10             
                                        (0136) 	M8C_SetBank1
0400: 62 04 FB MOV   REG[0x4],0xFB      (0137) 	mov	reg[04h], fbh		; Port_1_DriveMode_0 register (PRT1DM0)
0403: 62 05 04 MOV   REG[0x5],0x4       (0138) 	mov	reg[05h], 04h		; Port_1_DriveMode_1 register (PRT1DM1)
0406: 70 EF    AND   F,0xEF             
                                        (0139) 	M8C_SetBank0
0408: 62 07 04 MOV   REG[0x7],0x4       (0140) 	mov	reg[07h], 04h		; Port_1_DriveMode_2 register (PRT1DM2)
040B: 62 06 00 MOV   REG[0x6],0x0       (0141) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
040E: 71 10    OR    F,0x10             
                                        (0142) 	M8C_SetBank1
0410: 62 06 00 MOV   REG[0x6],0x0       (0143) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
0413: 62 07 00 MOV   REG[0x7],0x0       (0144) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
0416: 70 EF    AND   F,0xEF             
                                        (0145) 	M8C_SetBank0
0418: 62 05 00 MOV   REG[0x5],0x0       (0146) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
041B: 62 08 00 MOV   REG[0x8],0x0       (0147) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
041E: 71 10    OR    F,0x10             
                                        (0148) 	M8C_SetBank1
0420: 62 08 EF MOV   REG[0x8],0xEF      (0149) 	mov	reg[08h], efh		; Port_2_DriveMode_0 register (PRT2DM0)
0423: 62 09 10 MOV   REG[0x9],0x10      (0150) 	mov	reg[09h], 10h		; Port_2_DriveMode_1 register (PRT2DM1)
0426: 70 EF    AND   F,0xEF             
                                        (0151) 	M8C_SetBank0
0428: 62 0B 10 MOV   REG[0xB],0x10      (0152) 	mov	reg[0bh], 10h		; Port_2_DriveMode_2 register (PRT2DM2)
042B: 62 0A 00 MOV   REG[0xA],0x0       (0153) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
042E: 71 10    OR    F,0x10             
                                        (0154) 	M8C_SetBank1
0430: 62 0A 00 MOV   REG[0xA],0x0       (0155) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
0433: 62 0B 00 MOV   REG[0xB],0x0       (0156) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
0436: 70 EF    AND   F,0xEF             
                                        (0157) 	M8C_SetBank0
0438: 62 09 00 MOV   REG[0x9],0x0       (0158) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
043B: 62 0C 04 MOV   REG[0xC],0x4       (0159) 	mov	reg[0ch], 04h		; Port_3_Data register (PRT3DR)
043E: 71 10    OR    F,0x10             
                                        (0160) 	M8C_SetBank1
0440: 62 0C 0F MOV   REG[0xC],0xF       (0161) 	mov	reg[0ch], 0fh		; Port_3_DriveMode_0 register (PRT3DM0)
0443: 62 0D 04 MOV   REG[0xD],0x4       (0162) 	mov	reg[0dh], 04h		; Port_3_DriveMode_1 register (PRT3DM1)
0446: 70 EF    AND   F,0xEF             
                                        (0163) 	M8C_SetBank0
0448: 62 0F 00 MOV   REG[0xF],0x0       (0164) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
044B: 62 0E 04 MOV   REG[0xE],0x4       (0165) 	mov	reg[0eh], 04h		; Port_3_GlobalSelect register (PRT3GS)
044E: 71 10    OR    F,0x10             
                                        (0166) 	M8C_SetBank1
0450: 62 0E 00 MOV   REG[0xE],0x0       (0167) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0453: 62 0F 00 MOV   REG[0xF],0x0       (0168) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0456: 70 EF    AND   F,0xEF             
                                        (0169) 	M8C_SetBank0
0458: 62 0D 00 MOV   REG[0xD],0x0       (0170) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
045B: 70 EF    AND   F,0xEF             
                                        (0171) 	M8C_SetBank0
045D: 7F       RET                      (0172) 	ret
                                        (0173) 
                                        (0174) 
                                        (0175) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_dsm_reciver
                                        (0026) export _LoadConfig_dsm_reciver
                                        (0027) export Port_0_Data_SHADE
                                        (0028) export _Port_0_Data_SHADE
                                        (0029) export Port_1_Data_SHADE
                                        (0030) export _Port_1_Data_SHADE
                                        (0031) export Port_3_Data_SHADE
                                        (0032) export _Port_3_Data_SHADE
                                        (0033) 
                                        (0034) 
                                        (0035) export NO_SHADOW
                                        (0036) export _NO_SHADOW
                                        (0037) 
                                        (0038) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0039) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0040) 
                                        (0041) AREA psoc_config(rom, rel)
                                        (0042) 
                                        (0043) 
                                        (0044) ;---------------------------------------------------------------------------
                                        (0045) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0046) ;                  parameters handled by boot code, like CPU speed). This
                                        (0047) ;                  function can be called from user code, but typically it
                                        (0048) ;                  is only called from boot.
                                        (0049) ;
                                        (0050) ;       INPUTS: None.
                                        (0051) ;      RETURNS: Nothing.
                                        (0052) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0053) ;               In the large memory model currently only the page
                                        (0054) ;               pointer registers listed below are modified.  This does
                                        (0055) ;               not guarantee that in future implementations of this
                                        (0056) ;               function other page pointer registers will not be
                                        (0057) ;               modified.
                                        (0058) ;          
                                        (0059) ;               Page Pointer Registers Modified: 
                                        (0060) ;               CUR_PP
                                        (0061) ;
                                        (0062) _LoadConfigInit:
                                        (0063)  LoadConfigInit:
                                        (0064)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0065)     
045E: 55 1D 00 MOV   [0x1D],0x0         (0066) 	mov		[Port_0_Data_SHADE], 0h
0461: 55 1E 00 MOV   [0x1E],0x0         (0067) 	mov		[Port_1_Data_SHADE], 0h
0464: 55 1F 04 MOV   [0x1F],0x4         (0068) 	mov		[Port_3_Data_SHADE], 4h
                                        (0069) 
0467: 7C 04 6B LCALL 0x046B             (0070) 	lcall	LoadConfig_dsm_reciver
                                        (0071) 
                                        (0072) 
                                        (0073)     RAM_EPILOGUE RAM_USE_CLASS_4
046A: 7F       RET                      (0074)     ret
                                        (0075) 
                                        (0076) ;---------------------------------------------------------------------------
                                        (0077) ; Load Configuration dsm_reciver
                                        (0078) ;
                                        (0079) ;    Load configuration registers for dsm_reciver.
                                        (0080) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0081) ;
                                        (0082) ;       INPUTS: None.
                                        (0083) ;      RETURNS: Nothing.
                                        (0084) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0085) ;               modified as may the Page Pointer registers!
                                        (0086) ;               In the large memory model currently only the page
                                        (0087) ;               pointer registers listed below are modified.  This does
                                        (0088) ;               not guarantee that in future implementations of this
                                        (0089) ;               function other page pointer registers will not be
                                        (0090) ;               modified.
                                        (0091) ;          
                                        (0092) ;               Page Pointer Registers Modified: 
                                        (0093) ;               CUR_PP
                                        (0094) ;
                                        (0095) _LoadConfig_dsm_reciver:
                                        (0096)  LoadConfig_dsm_reciver:
                                        (0097)     RAM_PROLOGUE RAM_USE_CLASS_4
046B: 7C 03 22 LCALL 0x0322             (0098)     lcall   LoadConfigTBL_dsm_reciver            ; Call load config table routine
046E: 70 EF    AND   F,0xEF             
                                        (0099) 
                                        (0100) 
                                        (0101)     M8C_SetBank0                    ; Force return to bank 0
                                        (0102)     RAM_EPILOGUE RAM_USE_CLASS_4
0470: 7F       RET                      (0103)     ret
                                        (0104) 
                                        (0105) 
                                        (0106) 
                                        (0107) AREA InterruptRAM(ram, rel)
                                        (0108) 
                                        (0109) NO_SHADOW:
                                        (0110) _NO_SHADOW:
                                        (0111) ; write only register shadows
                                        (0112) _Port_0_Data_SHADE:
                                        (0113) Port_0_Data_SHADE:	BLK	1
                                        (0114) _Port_1_Data_SHADE:
                                        (0115) Port_1_Data_SHADE:	BLK	1
                                        (0116) _Port_3_Data_SHADE:
                                        (0117) Port_3_Data_SHADE:	BLK	1
                                        (0118) 
FILE: lib\timer8_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1INT.asm
                                        (0004) ;;   Version: 2.70, Updated on 2015/3/4 at 22:27:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Timer8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Timer8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Timer8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Timer8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
0471: 7D 1D 9F LJMP  _Timer8_1_Interrupt(0081)    ljmp _Timer8_1_Interrupt
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0474: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Timer8_1INT.asm
FILE: lib\timer8_1.asm                  (0001) ;;*****************************************************************************
0475: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1.asm
                                        (0004) ;;   Version: 2.70, Updated on 2015/3/4 at 22:27:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Timer8_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Timer8_1_EnableInt
                                        (0030) export _Timer8_1_EnableInt
                                        (0031) export  Timer8_1_DisableInt
                                        (0032) export _Timer8_1_DisableInt
                                        (0033) export  Timer8_1_Start
                                        (0034) export _Timer8_1_Start
                                        (0035) export  Timer8_1_Stop
                                        (0036) export _Timer8_1_Stop
                                        (0037) export  Timer8_1_WritePeriod
                                        (0038) export _Timer8_1_WritePeriod
                                        (0039) export  Timer8_1_WriteCompareValue
                                        (0040) export _Timer8_1_WriteCompareValue
                                        (0041) export  Timer8_1_bReadCompareValue
                                        (0042) export _Timer8_1_bReadCompareValue
                                        (0043) export  Timer8_1_bReadTimer
                                        (0044) export _Timer8_1_bReadTimer
                                        (0045) export  Timer8_1_bReadTimerSaveCV
                                        (0046) export _Timer8_1_bReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  bTimer8_1_ReadCompareValue  ; deprecated
                                        (0051) export _bTimer8_1_ReadCompareValue  ; deprecated
                                        (0052) export  bTimer8_1_ReadTimer         ; deprecated
                                        (0053) export _bTimer8_1_ReadTimer         ; deprecated
                                        (0054) export  bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0055) export _bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0056) 
                                        (0057) export  bTimer8_1_ReadCounter       ; obsolete
                                        (0058) export _bTimer8_1_ReadCounter       ; obsolete
                                        (0059) export  bTimer8_1_CaptureCounter    ; obsolete
                                        (0060) export _bTimer8_1_CaptureCounter    ; obsolete
                                        (0061) 
                                        (0062) 
                                        (0063) AREA dsm_reciver_RAM (RAM,REL)
                                        (0064) 
                                        (0065) ;-----------------------------------------------
                                        (0066) ;  Constant Definitions
                                        (0067) ;-----------------------------------------------
                                        (0068) 
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: Timer8_1_EnableInt
                                        (0080) ;
                                        (0081) ;  DESCRIPTION:
                                        (0082) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0083) ;     associated with this User Module. This function has no effect until and
                                        (0084) ;     unless the global interrupts are enabled (for example by using the
                                        (0085) ;     macro M8C_EnableGInt).
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;
                                        (0088) ;  ARGUMENTS:    None.
                                        (0089) ;  RETURNS:      Nothing.
                                        (0090) ;  SIDE EFFECTS: 
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  Timer8_1_EnableInt:
                                        (0098) _Timer8_1_EnableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    Timer8_1_EnableInt_M
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0478: 7F       RET                      (0102)    ret
0479: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0103) 
                                        (0104) .ENDSECTION
                                        (0105) 
                                        (0106) 
                                        (0107) .SECTION
                                        (0108) ;-----------------------------------------------------------------------------
                                        (0109) ;  FUNCTION NAME: Timer8_1_DisableInt
                                        (0110) ;
                                        (0111) ;  DESCRIPTION:
                                        (0112) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0113) ;     mask bit associated with this User Module.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS: 
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  Timer8_1_DisableInt:
                                        (0126) _Timer8_1_DisableInt:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    Timer8_1_DisableInt_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0130)    ret
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) 
                                        (0135) .SECTION
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  FUNCTION NAME: Timer8_1_Start
                                        (0138) ;
                                        (0139) ;  DESCRIPTION:
                                        (0140) ;     Sets the start bit in the Control register of this user module.  The
                                        (0141) ;     timer will begin counting on the next input clock.
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;
                                        (0144) ;  ARGUMENTS:    None
                                        (0145) ;  RETURNS:      Nothing
                                        (0146) ;  SIDE EFFECTS: 
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  Timer8_1_Start:
                                        (0154) _Timer8_1_Start:
                                        (0155)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0156)    Timer8_1_Start_M
                                        (0157)    RAM_EPILOGUE RAM_USE_CLASS_1
047C: 7F       RET                      (0158)    ret
047D: 41 2F FE AND   REG[0x2F],0xFE     
                                        (0159) 
                                        (0160) .ENDSECTION
                                        (0161) 
                                        (0162) 
                                        (0163) .SECTION
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;  FUNCTION NAME: Timer8_1_Stop
                                        (0166) ;
                                        (0167) ;  DESCRIPTION:
                                        (0168) ;     Disables timer operation by clearing the start bit in the Control
                                        (0169) ;     register.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    None
                                        (0173) ;  RETURNS:      Nothing
                                        (0174) ;  SIDE EFFECTS: 
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;
                                        (0181)  Timer8_1_Stop:
                                        (0182) _Timer8_1_Stop:
                                        (0183)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0184)    Timer8_1_Stop_M
                                        (0185)    RAM_EPILOGUE RAM_USE_CLASS_1
0480: 7F       RET                      (0186)    ret
                                        (0187) 
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) 
                                        (0191) .SECTION
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  FUNCTION NAME: Timer8_1_WritePeriod
                                        (0194) ;
                                        (0195) ;  DESCRIPTION:
                                        (0196) ;     Write the 8-bit period value into the Period register (DR1). If the
                                        (0197) ;     Timer user module is stopped, then this value will also be latched
                                        (0198) ;     into the Count register (DR0).
                                        (0199) ;-----------------------------------------------------------------------------
                                        (0200) ;
                                        (0201) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0202) ;  RETURNS:   Nothing
                                        (0203) ;  SIDE EFFECTS: 
                                        (0204) ;    The A and X registers may be modified by this or future implementations
                                        (0205) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0207) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0208) ;    functions.
                                        (0209) ;
                                        (0210)  Timer8_1_WritePeriod:
                                        (0211) _Timer8_1_WritePeriod:
                                        (0212)    RAM_PROLOGUE RAM_USE_CLASS_1
0481: 60 2D    MOV   REG[0x2D],A        (0213)    mov   reg[Timer8_1_PERIOD_REG], A
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_1
0483: 7F       RET                      (0215)    ret
                                        (0216) 
                                        (0217) .ENDSECTION
                                        (0218) 
                                        (0219) 
                                        (0220) .SECTION
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;  FUNCTION NAME: Timer8_1_WriteCompareValue
                                        (0223) ;
                                        (0224) ;  DESCRIPTION:
                                        (0225) ;     Writes compare value into the Compare register (DR2).
                                        (0226) ;
                                        (0227) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0228) ;           Compare register. (Call Timer8_1_Stop to disable).
                                        (0229) ;-----------------------------------------------------------------------------
                                        (0230) ;
                                        (0231) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0232) ;  RETURNS:      Nothing
                                        (0233) ;  SIDE EFFECTS: 
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240)  Timer8_1_WriteCompareValue:
                                        (0241) _Timer8_1_WriteCompareValue:
                                        (0242)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0243)    mov   reg[Timer8_1_COMPARE_REG], A
                                        (0244)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0245)    ret
                                        (0246) 
                                        (0247) .ENDSECTION
                                        (0248) 
                                        (0249) 
                                        (0250) .SECTION
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;  FUNCTION NAME: Timer8_1_bReadCompareValue
                                        (0253) ;
                                        (0254) ;  DESCRIPTION:
                                        (0255) ;     Reads the Compare register.
                                        (0256) ;-----------------------------------------------------------------------------
                                        (0257) ;
                                        (0258) ;  ARGUMENTS:    None
                                        (0259) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0260) ;  SIDE EFFECTS: 
                                        (0261) ;    The A and X registers may be modified by this or future implementations
                                        (0262) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0263) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0264) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0265) ;    functions.
                                        (0266) ;
                                        (0267)  Timer8_1_bReadCompareValue:
                                        (0268) _Timer8_1_bReadCompareValue:
                                        (0269)  bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0270) _bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0271)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0272)    mov   A, reg[Timer8_1_COMPARE_REG]
                                        (0273)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0274)    ret
                                        (0275) 
                                        (0276) .ENDSECTION
                                        (0277) 
                                        (0278) 
                                        (0279) .SECTION
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;  FUNCTION NAME: Timer8_1_bReadTimerSaveCV
                                        (0282) ;
                                        (0283) ;  DESCRIPTION:
                                        (0284) ;     Returns the value in the Count register (DR0), preserving the
                                        (0285) ;     value in the compare register (DR2).
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0292) ;     2) If enabled, Global interrupts are momentarily disabled.
                                        (0293) ;     3) The user module is stopped momentarily while the compare value is
                                        (0294) ;        restored.  This may cause the Count register to miss one or more
                                        (0295) ;        counts depending on the input clock speed.
                                        (0296) ;     4) The A and X registers may be modified by this or future implementations
                                        (0297) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0298) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0299) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0300) ;        functions.
                                        (0301) ;
                                        (0302) ;  THEORY of OPERATION:
                                        (0303) ;     1) Read and save the Compare register.
                                        (0304) ;     2) Read the Count register, causing its data to be latched into
                                        (0305) ;        the Compare register.
                                        (0306) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0307) ;        to the buffer.
                                        (0308) ;     4) Disable global interrupts
                                        (0309) ;     5) Halt the timer
                                        (0310) ;     6) Restore the Compare register values
                                        (0311) ;     7) Start the Timer again
                                        (0312) ;     8) Restore global interrupt state
                                        (0313) ;
                                        (0314)  Timer8_1_bReadTimerSaveCV:
                                        (0315) _Timer8_1_bReadTimerSaveCV:
                                        (0316)  bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0317) _bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0318)  bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0319) _bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0320) 
                                        (0321) CpuFlags:      equ   0
                                        (0322) bCount:        equ   1
                                        (0323) 
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0325)    mov   X, SP                                   ; X <- stack frame pointer
                                        (0326)    add   SP, 2                                   ; Reserve space for flags, count
                                        (0327)    mov   A, reg[Timer8_1_CONTROL_REG]            ; save the Control register
                                        (0328)    push  A
                                        (0329)    mov   A, reg[Timer8_1_COMPARE_REG]            ; save the Compare register
                                        (0330)    push  A
                                        (0331)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0332)                                                  ; This may cause an interrupt!
                                        (0333)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Now grab DR2 (DR0) and save
                                        (0334)    mov   [X+bCount], A
                                        (0335)    mov   A, 0                                    ; Guess the global interrupt state
                                        (0336)    tst   reg[CPU_F], FLAG_GLOBAL_IE              ; Currently Disabled?
                                        (0337)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
                                        (0338)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
                                        (0339) .SetupStatusFlag:                                ; and ...
                                        (0340)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
                                        (0341)    M8C_DisableGInt                               ; Disable interrupts globally
                                        (0342)    Timer8_1_Stop_M                               ; Stop the timer
                                        (0343)    pop   A                                       ; Restore the Compare register
                                        (0344)    mov   reg[Timer8_1_COMPARE_REG], A
                                        (0345)    pop   A                                       ; restore start state of the timer
                                        (0346)    mov   reg[Timer8_1_CONTROL_REG], A
                                        (0347)    pop   A                                       ; Return result stored in stack frame
                                        (0348)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0349)    reti                                          ; Flag Reg <- StackFrame[0]
                                        (0350) 
                                        (0351) .ENDSECTION
                                        (0352) 
                                        (0353) 
                                        (0354) .SECTION
                                        (0355) ;-----------------------------------------------------------------------------
                                        (0356) ;  FUNCTION NAME: Timer8_1_bReadTimer
                                        (0357) ;
                                        (0358) ;  DESCRIPTION:
                                        (0359) ;     Performs a software capture of the Count register.  A synchronous
                                        (0360) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0361) ;
                                        (0362) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;
                                        (0365) ;  ARGUMENTS:    None
                                        (0366) ;  RETURNS:      fastcall16 BYTE bCount, (value of DR0 in the A register)
                                        (0367) ;  SIDE EFFECTS:
                                        (0368) ;    May cause an interrupt.
                                        (0369) ;
                                        (0370) ;    The A and X registers may be modified by this or future implementations
                                        (0371) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0372) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0373) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0374) ;    functions.
                                        (0375) ;
                                        (0376) ;  THEORY of OPERATION:
                                        (0377) ;     1) Read the Count register - this causes the count value to be
                                        (0378) ;        latched into the Compare register.
                                        (0379) ;     2) Read and return the Count register values from the Compare
                                        (0380) ;        registers into the return buffer.
                                        (0381) ;
                                        (0382)  Timer8_1_bReadTimer:
                                        (0383) _Timer8_1_bReadTimer:
                                        (0384)  bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0385) _bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0386)  bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0387) _bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0388) 
                                        (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0390)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0391)                                                  ; This may cause an interrupt!
                                        (0392)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Return DR2 (actually DR0)
                                        (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0394)    ret
                                        (0395) 
                                        (0396) .ENDSECTION
                                        (0397) 
                                        (0398) ; End of File Timer8_1.asm
FILE: lib\spim_1.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: SPIM_1.asm
                                        (0004) ;;   Version: 2.6, Updated on 2015/3/4 at 22:27:42
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: SPIM User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "SPIM_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export   SPIM_1_EnableInt
                                        (0030) export  _SPIM_1_EnableInt
                                        (0031) export   SPIM_1_DisableInt
                                        (0032) export  _SPIM_1_DisableInt
                                        (0033) export   SPIM_1_Start
                                        (0034) export  _SPIM_1_Start
                                        (0035) export   SPIM_1_Stop
                                        (0036) export  _SPIM_1_Stop
                                        (0037) export   SPIM_1_SendTxData
                                        (0038) export  _SPIM_1_SendTxData
                                        (0039) export   SPIM_1_bReadRxData
                                        (0040) export  _SPIM_1_bReadRxData
                                        (0041) export   SPIM_1_bReadStatus
                                        (0042) export  _SPIM_1_bReadStatus
                                        (0043) 
                                        (0044) // These globals will be removed in a future release
                                        (0045) // Do not use
                                        (0046) export   bSPIM_1_ReadRxData
                                        (0047) export  _bSPIM_1_ReadRxData
                                        (0048) export   bSPIM_1_ReadStatus
                                        (0049) export  _bSPIM_1_ReadStatus
                                        (0050) 
                                        (0051) ;-----------------------------------------------
                                        (0052) ;  Constant Definitions
                                        (0053) ;-----------------------------------------------
                                        (0054) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0055) 
                                        (0056) 
                                        (0057) area UserModules (ROM, REL)
                                        (0058) 
                                        (0059) .SECTION
                                        (0060) ;-----------------------------------------------------------------------------
                                        (0061) ;  FUNCTION NAME: SPIM_1_EnableInt
                                        (0062) ;
                                        (0063) ;  DESCRIPTION:
                                        (0064) ;     Enables the SPIM interrupt by setting the interrupt enable mask
                                        (0065) ;     bit associated with this User Module.
                                        (0066) ;
                                        (0067) ;     NOTE:  Remember to enable the global interrupt by calling the
                                        (0068) ;           M8C global macro: M8C_EnableGInt
                                        (0069) ;
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:  none
                                        (0073) ;
                                        (0074) ;  RETURNS:  none
                                        (0075) ;
                                        (0076) ;  SIDE EFFECTS: 
                                        (0077) ;    The A and X registers may be modified by this or future implementations
                                        (0078) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0079) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0080) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0081) ;    functions.
                                        (0082) ;
                                        (0083) ;  THEORY of OPERATION or PROCEDURE:
                                        (0084) ;     Sets the specific user module interrupt enable mask bit.
                                        (0085) ;
                                        (0086)  SPIM_1_EnableInt:
                                        (0087) _SPIM_1_EnableInt:
                                        (0088)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0089)    M8C_EnableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0090)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0091)    ret
                                        (0092) 
                                        (0093) .ENDSECTION
                                        (0094) 
                                        (0095) .SECTION
                                        (0096) ;-----------------------------------------------------------------------------
                                        (0097) ;  FUNCTION NAME: SPIM_1_DisableInt
                                        (0098) ;
                                        (0099) ;  DESCRIPTION:
                                        (0100) ;     Disables this SPIM's interrupt by clearing the interrupt enable mask bit
                                        (0101) ;     associated with this User Module.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS:  none
                                        (0106) ;
                                        (0107) ;  RETURNS:  none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS: 
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116) ;  THEORY of OPERATION or PROCEDURE:
                                        (0117) ;     Clears the specific user module interrupt enable mask bit.
                                        (0118) ;
                                        (0119)  SPIM_1_DisableInt:
                                        (0120) _SPIM_1_DisableInt:
                                        (0121)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0122)    M8C_DisableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0123)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0124)    ret
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: SPIM_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit, SPI mode, and LSB/MSB first configuration of the SPIM
                                        (0134) ;     user module.
                                        (0135) ;
                                        (0136) ;     Transmission will begin transmitting when a byte is written into the TX buffer
                                        (0137) ;     using the SPIM_1_SendTxData function.
                                        (0138) ;
                                        (0139) ;-----------------------------------------------------------------------------
                                        (0140) ;
                                        (0141) ;  ARGUMENTS:
                                        (0142) ;     BYTE bConfiguration - Consists of SPI Mode and LSB/MSB first bit.
                                        (0143) ;           Use defined masks - masks can be OR'd together.
                                        (0144) ;     PASSED in Accumulator.
                                        (0145) ;
                                        (0146) ;  RETURNS:  none
                                        (0147) ;
                                        (0148) ;  SIDE EFFECTS: 
                                        (0149) ;    The A and X registers may be modified by this or future implementations
                                        (0150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0153) ;    functions.
                                        (0154) ;
                                        (0155) ;  THEORY of OPERATION or PROCEDURE:
                                        (0156) ;     1) Set all Slave Select outputs high
                                        (0157) ;     2) Set the specified SPI configuration bits in the Control register.
                                        (0158) ;
                                        (0159)  SPIM_1_Start:
                                        (0160) _SPIM_1_Start:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    ; setup the SPIM configuration setting
0484: 29 01    OR    A,0x1              (0163)    or    A, bfCONTROL_REG_START_BIT
0486: 60 2B    MOV   REG[0x2B],A        (0164)    mov   REG[SPIM_1_CONTROL_REG], A
                                        (0165)    RAM_EPILOGUE RAM_USE_CLASS_1
0488: 7F       RET                      (0166)    ret
                                        (0167) 
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: SPIM_1_Stop
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Disables SPIM operation.
                                        (0176) ;
                                        (0177) ;-----------------------------------------------------------------------------
                                        (0178) ;
                                        (0179) ;  ARGUMENTS:  none
                                        (0180) ;
                                        (0181) ;  RETURNS:  none
                                        (0182) ;
                                        (0183) ;  SIDE EFFECTS: 
                                        (0184) ;    The A and X registers may be modified by this or future implementations
                                        (0185) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0186) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0187) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0188) ;    functions.
                                        (0189) ;
                                        (0190) ;  THEORY of OPERATION or PROCEDURE:
                                        (0191) ;     Clear the start bit in the Control register.
                                        (0192) ;
                                        (0193)  SPIM_1_Stop:
                                        (0194) _SPIM_1_Stop:
                                        (0195)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0196)    ; clear the SPIM stop bits
                                        (0197)    and   REG[SPIM_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0198)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0199)    ret
                                        (0200) 
                                        (0201) .ENDSECTION
                                        (0202) 
                                        (0203) .SECTION
                                        (0204) ;-----------------------------------------------------------------------------
                                        (0205) ;  FUNCTION NAME: SPIM_1_SendTxData
                                        (0206) ;
                                        (0207) ;  DESCRIPTION:
                                        (0208) ;     Initiates an SPI data transfer.
                                        (0209) ;
                                        (0210) ;-----------------------------------------------------------------------------
                                        (0211) ;
                                        (0212) ;  ARGUMENTS:
                                        (0213) ;     BYTE  bTxData - data to transmit.
                                        (0214) ;        Passed in Accumulator.
                                        (0215) ;
                                        (0216) ;  RETURNS:  none
                                        (0217) ;
                                        (0218) ;  SIDE EFFECTS: 
                                        (0219) ;    The A and X registers may be modified by this or future implementations
                                        (0220) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0221) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0222) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0223) ;    functions.
                                        (0224) ;
                                        (0225) ;  THEORY of OPERATION or PROCEDURE:
                                        (0226) ;     Writes data to the TX buffer register.
                                        (0227) ;
                                        (0228)  SPIM_1_SendTxData:
                                        (0229) _SPIM_1_SendTxData:
                                        (0230)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0231)    ; Transmit the data!
0489: 60 29    MOV   REG[0x29],A        (0232)    mov REG[SPIM_1_TX_BUFFER_REG], A
                                        (0233)    RAM_EPILOGUE RAM_USE_CLASS_1
048B: 7F       RET                      (0234)    ret
                                        (0235) 
                                        (0236) .ENDSECTION
                                        (0237) 
                                        (0238) .SECTION
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) ;  FUNCTION NAME: SPIM_1_bReadRxData
                                        (0241) ;
                                        (0242) ;  DESCRIPTION:
                                        (0243) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0244) ;     sure data is valid.
                                        (0245) ;
                                        (0246) ;-----------------------------------------------------------------------------
                                        (0247) ;
                                        (0248) ;  ARGUMENTS:  none
                                        (0249) ;
                                        (0250) ;  RETURNS:
                                        (0251) ;     bRxData - returned in A.
                                        (0252) ;
                                        (0253) ;  SIDE EFFECTS: 
                                        (0254) ;    The A and X registers may be modified by this or future implementations
                                        (0255) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0256) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0257) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0258) ;    functions.
                                        (0259) ;
                                        (0260) ;  THEORY of OPERATION or PROCEDURE:
                                        (0261) ;
                                        (0262)  SPIM_1_bReadRxData:
                                        (0263) _SPIM_1_bReadRxData:
                                        (0264)  bSPIM_1_ReadRxData:
                                        (0265) _bSPIM_1_ReadRxData:
                                        (0266)    RAM_PROLOGUE RAM_USE_CLASS_1
048C: 5D 2A    MOV   A,REG[0x2A]        (0267)    mov A, REG[SPIM_1_RX_BUFFER_REG]
                                        (0268)    RAM_EPILOGUE RAM_USE_CLASS_1   
048E: 7F       RET                      (0269)    ret
                                        (0270) 
                                        (0271) 
                                        (0272) .ENDSECTION
                                        (0273) 
                                        (0274) .SECTION
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  FUNCTION NAME: SPIM_1_ReadStatus
                                        (0277) ;
                                        (0278) ;  DESCRIPTION:
                                        (0279) ;     Reads the SPIM Status bits in the Control/Status register.
                                        (0280) ;
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;
                                        (0283) ;  ARGUMENTS:  none
                                        (0284) ;
                                        (0285) ;  RETURNS:
                                        (0286) ;     BYTE  bStatus - transmit status data.  Use the defined bit masks.
                                        (0287) ;        Returned in Accumulator.
                                        (0288) ;
                                        (0289) ;  SIDE EFFECTS: 
                                        (0290) ;    The A and X registers may be modified by this or future implementations
                                        (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0294) ;    functions.
                                        (0295) ;
                                        (0296) ;  THEORY of OPERATION or PROCEDURE:
                                        (0297) ;     Read the status and control register.
                                        (0298) ;
                                        (0299)  SPIM_1_bReadStatus:
                                        (0300) _SPIM_1_bReadStatus:
                                        (0301)  bSPIM_1_ReadStatus:
                                        (0302) _bSPIM_1_ReadStatus:
                                        (0303)    RAM_PROLOGUE RAM_USE_CLASS_1
048F: 5D 2B    MOV   A,REG[0x2B]        (0304)    mov A,  REG[SPIM_1_CONTROL_REG]
                                        (0305)    RAM_EPILOGUE RAM_USE_CLASS_1   
0491: 7F       RET                      (0306)    ret
                                        (0307) 
                                        (0308) .ENDSECTION
                                        (0309) 
                                        (0310) ; End of File SPIM_1.asm
FILE: lib\sleeptimer_1int.asm           (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   SleepTimer_1INT.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "SleepTimer_1.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "m8c.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export  _SleepTimer_1_ISR
                                        (0021) 
                                        (0022) 
                                        (0023) export  SleepTimer_1_fTick
                                        (0024) export _SleepTimer_1_fTick
                                        (0025) export  SleepTimer_1_bTimerValue
                                        (0026) export _SleepTimer_1_bTimerValue
                                        (0027) export  SleepTimer_1_bCountDown
                                        (0028) export _SleepTimer_1_bCountDown
                                        (0029) export  SleepTimer_1_TickCount
                                        (0030) export _SleepTimer_1_TickCount
                                        (0031) 
                                        (0032) ;-----------------------------------------------
                                        (0033) ; Variable Allocation
                                        (0034) ;-----------------------------------------------
                                        (0035) AREA InterruptRAM (RAM, REL, CON)
                                        (0036) 
                                        (0037)  SleepTimer_1_fTick:
                                        (0038) _SleepTimer_1_fTick:        BLK  1
                                        (0039) 
                                        (0040)  SleepTimer_1_bTimerValue:
                                        (0041) _SleepTimer_1_bTimerValue:  BLK  1
                                        (0042) 
                                        (0043)  SleepTimer_1_bCountDown:
                                        (0044) _SleepTimer_1_bCountDown:   BLK  1
                                        (0045) 
                                        (0046)  SleepTimer_1_TickCount:
                                        (0047) _SleepTimer_1_TickCount:    BLK  SleepTimer_1_TICK_CNTR_SIZE
                                        (0048) 
                                        (0049) 
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _SleepTimer_1_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;      interrupt handler for instance SleepTimer_1.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _SleepTimer_1_ISR:
                                        (0090) 
0492: 2E 18 01 OR    [0x18],0x1         (0091)    or   [SleepTimer_1_fTick],0x01           ; Set tick flag
                                        (0092)  
                                        (0093)                                                 ; Decrement CountDown (Sync counter)
0495: 47 1A FF TST   [0x1A],0xFF        (0094)    tst  [SleepTimer_1_bCountDown],0xFF
0498: A0 03    JZ    0x049C             (0095)    jz   .DoTimer
049A: 7A 1A    DEC   [0x1A]             (0096)    dec  [SleepTimer_1_bCountDown]
                                        (0097) 
                                        (0098) .DoTimer:                                       ; Decrement TimerValue, if required
049C: 47 19 FF TST   [0x19],0xFF        (0099)    tst  [SleepTimer_1_bTimerValue],0xFF
049F: A0 03    JZ    0x04A3             (0100)    jz   .IncBigCounter
04A1: 7A 19    DEC   [0x19]             (0101)    dec  [SleepTimer_1_bTimerValue]
                                        (0102) 
                                        (0103) .IncBigCounter:                                 ; Increment big tick counter
                                        (0104) IF (SleepTimer_1_TICK_CNTR_SIZE & 0x04)
                                        (0105)    inc  [SleepTimer_1_TickCount+3]
                                        (0106)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0107) 
                                        (0108)    inc  [SleepTimer_1_TickCount+2]
                                        (0109)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0110) ENDIF
                                        (0111) 
                                        (0112) IF (SleepTimer_1_TICK_CNTR_SIZE & (0x04|0x02))
04A3: 76 1C    INC   [0x1C]             (0113)    inc  [SleepTimer_1_TickCount+1]
04A5: D0 03    JNC   0x04A9             (0114)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0115) ENDIF
                                        (0116) 
04A7: 76 1B    INC   [0x1B]             (0117)    inc  [SleepTimer_1_TickCount+0]
                                        (0118) 
                                        (0119) SleepTimer_1_SLEEP_ISR_END:
                                        (0120) 
                                        (0121)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0122)    ;---------------------------------------------------
                                        (0123)    ; Insert your custom assembly code below this banner
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ;   NOTE: interrupt service routines must preserve
                                        (0126)    ;   the values of the A and X CPU registers.
                                        (0127)    
                                        (0128)    ;---------------------------------------------------
                                        (0129)    ; Insert your custom assembly code above this banner
                                        (0130)    ;---------------------------------------------------
                                        (0131)    
                                        (0132)    ;---------------------------------------------------
                                        (0133)    ; Insert a lcall to a C function below this banner
                                        (0134)    ; and un-comment the lines between these banners
                                        (0135)    ;---------------------------------------------------
                                        (0136)    
                                        (0137)    ;PRESERVE_CPU_CONTEXT
                                        (0138)    ;ljmp _Sleep_Timer_Interrupt
                                        (0139)    ;RESTORE_CPU_CONTEXT
                                        (0140)    
                                        (0141)    ;---------------------------------------------------
                                        (0142)    ; Insert a lcall to a C function above this banner
                                        (0143)    ; and un-comment the lines between these banners
                                        (0144)    ;---------------------------------------------------
                                        (0145)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0146) 
04A9: 7E       RETI                     (0147)    reti
                                        (0148) 
                                        (0149) ; end of file SleepTimer_1INT.asm
                                        (0150) 
FILE: lib\sleeptimer_1.asm              (0001) ;;*****************************************************************************
04AA: 43 E0 40 OR    REG[0xE0],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  Filename:   SleepTimer_1.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer User Module software implementation file for the
                                        (0008) ;;                22/24/27/29xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "SleepTimer_1.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name reference for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  SleepTimer_1_EnableInt
                                        (0041) export _SleepTimer_1_EnableInt
                                        (0042) export  SleepTimer_1_DisableInt
                                        (0043) export _SleepTimer_1_DisableInt
                                        (0044) 
                                        (0045) export  SleepTimer_1_Start
                                        (0046) export _SleepTimer_1_Start
                                        (0047) export  SleepTimer_1_Stop
                                        (0048) export _SleepTimer_1_Stop
                                        (0049) 
                                        (0050) export  SleepTimer_1_TickWait
                                        (0051) export _SleepTimer_1_TickWait
                                        (0052) 
                                        (0053) export  SleepTimer_1_SyncWait
                                        (0054) export _SleepTimer_1_SyncWait
                                        (0055) 
                                        (0056) export  SleepTimer_1_SetInterval
                                        (0057) export _SleepTimer_1_SetInterval
                                        (0058) 	
                                        (0059) export  SleepTimer_1_bGetTickCntr
                                        (0060) export _SleepTimer_1_bGetTickCntr
                                        (0061) 
                                        (0062) export  SleepTimer_1_SetTimer
                                        (0063) export _SleepTimer_1_SetTimer
                                        (0064) 
                                        (0065) export  SleepTimer_1_bGetTimer
                                        (0066) export _SleepTimer_1_bGetTimer
                                        (0067) 
                                        (0068) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0069) export  SleepTimer_1_iGetTickCntr
                                        (0070) export _SleepTimer_1_iGetTickCntr
                                        (0071) ENDIF
                                        (0072) 
                                        (0073) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0074) export  SleepTimer_1_lGetTickCntr
                                        (0075) export _SleepTimer_1_lGetTickCntr
                                        (0076) ENDIF
                                        (0077) 
                                        (0078) 
                                        (0079) area text (ROM,REL)
                                        (0080) 
                                        (0081) ;-----------------------------------------------
                                        (0082) ;  EQUATES
                                        (0083) ;-----------------------------------------------
                                        (0084) 
                                        (0085) ; Counter LSB Offset if 4 byte tick counter
                                        (0086) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0087) ST_LSB_OFFSET:   equ  3
                                        (0088) ENDIF
                                        (0089) 
                                        (0090) ; Counter LSB Offset if 2 byte tick counter
                                        (0091) IF(SleepTimer_1_TICK_CNTR_SIZE & 2)
                                        (0092) ST_LSB_OFFSET:   equ  1
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ; Counter LSB Offset if 1 byte tick counter
                                        (0096) IF(SleepTimer_1_TICK_CNTR_SIZE & 1)
                                        (0097) ST_LSB_OFFSET:   equ  0
                                        (0098) ENDIF
                                        (0099) 
                                        (0100) 
                                        (0101) area UserModules (ROM, REL, CON)
                                        (0102) 
                                        (0103) ;=============================================================================
                                        (0104) ;=============================================================================
                                        (0105) ;
                                        (0106) ;     Low-Level Commands
                                        (0107) ;
                                        (0108) ;=============================================================================
                                        (0109) ;=============================================================================
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: SleepTimer_1_EnableInt
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Enables SleepTimer interrupts.
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;
                                        (0119) ;  ARGUMENTS:
                                        (0120) ;     none.
                                        (0121) ;
                                        (0122) ;  RETURNS:
                                        (0123) ;     none.
                                        (0124) ;
                                        (0125) ;  SIDE EFFECTS:
                                        (0126) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0127) ;
                                        (0128) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0129) ;
                                        (0130)  SleepTimer_1_EnableInt:
                                        (0131) _SleepTimer_1_EnableInt:
                                        (0132)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0133)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0134)    RAM_EPILOGUE RAM_USE_CLASS_1
04AD: 7F       RET                      (0135)    ret
                                        (0136) .ENDSECTION
                                        (0137) 
                                        (0138)     
                                        (0139) .SECTION
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;  FUNCTION NAME: SleepTimer_1_DisableInt
                                        (0142) ;
                                        (0143) ;  DESCRIPTION:
                                        (0144) ;     Disables the sleep timer. 
                                        (0145) ;
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     none.
                                        (0150) ;
                                        (0151) ;  RETURNS:
                                        (0152) ;     none.
                                        (0153) ;
                                        (0154) ;  SIDE EFFECTS:
                                        (0155) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0156) ;
                                        (0157) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0158) ;
                                        (0159)  SleepTimer_1_DisableInt:
                                        (0160) _SleepTimer_1_DisableInt:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0163)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0164)    ret
                                        (0165) .ENDSECTION
                                        (0166) 
                                        (0167) 
                                        (0168) .SECTION
                                        (0169) ;-----------------------------------------------------------------------------
                                        (0170) ;  FUNCTION NAME: SleepTimer_1_Start()
                                        (0171) ;
                                        (0172) ;  DESCRIPTION:
                                        (0173) ;     Clears all the variables.  
                                        (0174) ;-----------------------------------------------------------------------------
                                        (0175) ;
                                        (0176) ;  ARGUMENTS:
                                        (0177) ;      none
                                        (0178) ;
                                        (0179) ;  RETURNS:
                                        (0180) ;     none.
                                        (0181) ;
                                        (0182) ;  SIDE EFFECTS;    
                                        (0183) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0184) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0185) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0186) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0187) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0188) ;          
                                        (0189) ;    Page Pointer Registers Modified: 
                                        (0190) ;          CUR_PP
                                        (0191) ;
                                        (0192) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0193) ;
                                        (0194)  SleepTimer_1_Start:
                                        (0195) _SleepTimer_1_Start:
                                        (0196)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0197)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04AE: 50 00    MOV   A,0x0              (0198)    mov  A,0
04B0: 53 18    MOV   [0x18],A           (0199)    mov  [SleepTimer_1_fTick],A
04B2: 53 19    MOV   [0x19],A           (0200)    mov  [SleepTimer_1_bTimerValue],A
04B4: 53 1A    MOV   [0x1A],A           (0201)    mov  [SleepTimer_1_bCountDown],A
04B6: 53 1C    MOV   [0x1C],A           (0202)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET],A        ; Clear TickCount[0:7]
                                        (0203) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
04B8: 53 1B    MOV   [0x1B],A           (0204)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET - 1],A    ; Clear TickCount[8:15]
                                        (0205) ENDIF
                                        (0206) 
                                        (0207) 
                                        (0208) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0209)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 2],A    ; Clear TickCount[16:31]
                                        (0210)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 3],A    
                                        (0211) ENDIF
                                        (0212) 
                                        (0213) 
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_4
04BA: 7F       RET                      (0215)    ret
                                        (0216) .ENDSECTION
                                        (0217) 
                                        (0218) 
                                        (0219) .SECTION
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;  FUNCTION NAME: SleepTimer_1_Stop
                                        (0222) ;
                                        (0223) ;  DESCRIPTION:
                                        (0224) ;   This function does nothing at this time.  It is only here as a place 
                                        (0225) ;   holder.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;
                                        (0228) ;  ARGUMENTS:
                                        (0229) ;     none.
                                        (0230) ;
                                        (0231) ;  RETURNS:
                                        (0232) ;     none.
                                        (0233) ;
                                        (0234) ;  SIDE EFFECTS:
                                        (0235) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0238) ;
                                        (0239)  SleepTimer_1_Stop:
                                        (0240) _SleepTimer_1_Stop:
                                        (0241)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0242)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0243)    ret
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: SleepTimer_1_SetInterval
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Sets sleep timer interval
                                        (0252) ;
                                        (0253) ;-----------------------------------------------------------------------------
                                        (0254) ;
                                        (0255) ;  ARGUMENTS:
                                        (0256) ;     A <= Timer setting
                                        (0257) ;
                                        (0258) ;  RETURNS:
                                        (0259) ;     none.
                                        (0260) ;
                                        (0261) ;  SIDE EFFECTS:
                                        (0262) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0263) ;
                                        (0264) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0265) ;
                                        (0266)  SleepTimer_1_SetInterval:
                                        (0267) _SleepTimer_1_SetInterval:
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0269)    and  A,SleepTimer_1_CLOCK_MASK               ; Mask off invalid data
                                        (0270)    mov  X, SP
                                        (0271)    push A
                                        (0272)    M8C_SetBank1
                                        (0273)    mov  A, reg[OSC_CR0]                  ; Get current timer value
                                        (0274)    and  A,~SleepTimer_1_CLOCK_MASK   ; Zero out old timer value
                                        (0275)    or   A, [X]                           ; Set new timer values
                                        (0276)    mov  reg[OSC_CR0],A                   ; Write it
                                        (0277)    M8C_SetBank0
                                        (0278)    pop  A
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0280)    ret
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) 
                                        (0284) .SECTION
                                        (0285) ;-----------------------------------------------------------------------------
                                        (0286) ;  FUNCTION NAME: SleepTimer_1_TickWait(BYTE bTicks)
                                        (0287) ;
                                        (0288) ;  DESCRIPTION:
                                        (0289) ;     Wait X Ticks and return
                                        (0290) ;
                                        (0291) ;-----------------------------------------------------------------------------
                                        (0292) ;
                                        (0293) ;  ARGUMENTS:
                                        (0294) ;     A <= Count down time
                                        (0295) ;
                                        (0296) ;  RETURNS:
                                        (0297) ;     none.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS;    
                                        (0300) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0301) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0302) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0303) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0304) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0305) ;          
                                        (0306) ;    Page Pointer Registers Modified: 
                                        (0307) ;          CUR_PP
                                        (0308) ;
                                        (0309) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0310) ;
                                        (0311)  SleepTimer_1_TickWait:
                                        (0312) _SleepTimer_1_TickWait:
                                        (0313)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0314)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04BB: 55 18 00 MOV   [0x18],0x0         (0315)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
                                        (0316) 
                                        (0317) .WaitTick:
04BE: 47 18 FF TST   [0x18],0xFF        (0318)    tst   [SleepTimer_1_fTick],0xFF          ; Check for tick 
04C1: AF FC    JZ    0x04BE             (0319)    jz    .WaitTick
04C3: 55 18 00 MOV   [0x18],0x0         (0320)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
04C6: 78       DEC   A                  (0321)    dec   A                                      ; Dec the timer variable
04C7: BF F6    JNZ   0x04BE             (0322)    jnz   .WaitTick                              ; Loop until we count down to zero
                                        (0323) 
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
04C9: 7F       RET                      (0325)    ret
04CA: 41 E0 BF AND   REG[0xE0],0xBF     
                                        (0326) .ENDSECTION
                                        (0327) 
                                        (0328) 
                                        (0329) .SECTION
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: SleepTimer_1_SyncWait(BYTE bCounts, BYTE fMode)
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:
                                        (0334) ;     This function resets the SyncWait timer.  If fMode = 0, the timer
                                        (0335) ;     is set to the new value then exits the function immediatly.  If fMode
                                        (0336) ;     is set to 1, the firmware waits for the timer to expire before the
                                        (0337) ;     timer is reset and and exits.
                                        (0338) ;
                                        (0339) ;-----------------------------------------------------------------------------
                                        (0340) ;
                                        (0341) ;  ARGUMENTS:
                                        (0342) ;     A <= tCounts to wait
                                        (0343) ;     X <= fMode    fMode = 0  Just reload the value, do not wait
                                        (0344) ;                   fMode = 1  Wait for last value to count down to zero
                                        (0345) ;                              then reload.
                                        (0346) ;
                                        (0347) ;  RETURNS:
                                        (0348) ;     none.
                                        (0349) ;
                                        (0350) ;  SIDE EFFECTS;    
                                        (0351) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0352) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0353) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0354) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0355) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0356) ;          
                                        (0357) ;    Page Pointer Registers Modified: 
                                        (0358) ;          CUR_PP
                                        (0359) ;
                                        (0360) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0361) ;
                                        (0362)  SleepTimer_1_SyncWait:
                                        (0363) _SleepTimer_1_SyncWait:
                                        (0364)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0365)    RAM_SETPAGE_CUR >SleepTimer_1_bCountDown
                                        (0366)    swap  A,X
                                        (0367)    AND   A,SleepTimer_1_FORCE_RELOAD
                                        (0368)    jnz   .ReloadIt
                                        (0369) 
                                        (0370) .WaitLoop:
                                        (0371)    tst   [SleepTimer_1_bCountDown],0xFF
                                        (0372)    jnz   .WaitLoop
                                        (0373) 
                                        (0374) 
                                        (0375) .ReloadIt:
                                        (0376)    swap  A,X
                                        (0377)    mov   [SleepTimer_1_bCountDown],A 
                                        (0378) 
                                        (0379)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0380)    ret
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) 
                                        (0384) 
                                        (0385) .SECTION
                                        (0386) ;-----------------------------------------------------------------------------
                                        (0387) ;  FUNCTION NAME: SleepTimer_1_bGetTickCntr
                                        (0388) ;
                                        (0389) ;  DESCRIPTION:
                                        (0390) ;     Returns the LSB of the tick Counter
                                        (0391) ;
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;
                                        (0394) ;  ARGUMENTS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  RETURNS:
                                        (0398) ;     LSB of lTickCount
                                        (0399) ;
                                        (0400) ;  SIDE EFFECTS;    
                                        (0401) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0402) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0403) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0404) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0405) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0406) ;          
                                        (0407) ;    Page Pointer Registers Modified: 
                                        (0408) ;          CUR_PP
                                        (0409) ;
                                        (0410) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0411) ;
                                        (0412)  SleepTimer_1_bGetTickCntr:
                                        (0413) _SleepTimer_1_bGetTickCntr:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0415)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0416)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]
                                        (0417)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0418)    ret
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) .SECTION
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;  FUNCTION NAME: SleepTimer_1_SetTimer
                                        (0424) ;
                                        (0425) ;  DESCRIPTION:
                                        (0426) ;     Set timer with parameter in A
                                        (0427) ;
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;
                                        (0430) ;  ARGUMENTS:
                                        (0431) ;     A => Value used to set Timer value
                                        (0432) ;
                                        (0433) ;  RETURNS:
                                        (0434) ;     None
                                        (0435) ;
                                        (0436) ;  SIDE EFFECTS;    
                                        (0437) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0438) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0439) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0440) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0441) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0442) ;          
                                        (0443) ;    Page Pointer Registers Modified: 
                                        (0444) ;          CUR_PP
                                        (0445) ;
                                        (0446) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0447) ;
                                        (0448)  SleepTimer_1_SetTimer:
                                        (0449) _SleepTimer_1_SetTimer:
                                        (0450)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0451)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0452)    mov   [SleepTimer_1_bTimerValue],A
                                        (0453)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0454)    ret
                                        (0455) .ENDSECTION
                                        (0456) 
                                        (0457) .SECTION
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: SleepTimer_1_bGetTimer
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:
                                        (0462) ;     Returns timer value in A
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;     None
                                        (0468) ;
                                        (0469) ;  RETURNS:
                                        (0470) ;     Return timer value in A
                                        (0471) ;
                                        (0472) ;  SIDE EFFECTS;    
                                        (0473) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0474) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0475) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0476) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0477) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0478) ;          
                                        (0479) ;    Page Pointer Registers Modified: 
                                        (0480) ;          CUR_PP
                                        (0481) ;
                                        (0482) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0483) ;
                                        (0484)  SleepTimer_1_bGetTimer:
                                        (0485) _SleepTimer_1_bGetTimer:
                                        (0486)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0487)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0488)    mov   A,[SleepTimer_1_bTimerValue]
                                        (0489)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0490)    ret
                                        (0491) .ENDSECTION
                                        (0492) 
                                        (0493) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0494) .SECTION
                                        (0495) ;-----------------------------------------------------------------------------
                                        (0496) ;  FUNCTION NAME: SleepTimer_1_iGetTickCntr
                                        (0497) ;
                                        (0498) ;  DESCRIPTION:
                                        (0499) ;     Returns the least significant 16 bits.
                                        (0500) ;
                                        (0501) ;-----------------------------------------------------------------------------
                                        (0502) ;
                                        (0503) ;  ARGUMENTS:
                                        (0504) ;     none
                                        (0505) ;
                                        (0506) ;  RETURNS:
                                        (0507) ;     (int)TickCount in A and X  
                                        (0508) ;     X  <= MSB
                                        (0509) ;     A  <= LSB
                                        (0510) ;
                                        (0511) ;  SIDE EFFECTS;    
                                        (0512) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0513) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0514) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0515) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0516) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0517) ;          
                                        (0518) ;    Page Pointer Registers Modified: 
                                        (0519) ;          CUR_PP
                                        (0520) ;
                                        (0521) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0522) ;
                                        (0523)  SleepTimer_1_iGetTickCntr:
                                        (0524) _SleepTimer_1_iGetTickCntr:
                                        (0525)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0526)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0527)    ; Disable interrupt here
                                        (0528)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
04CD: 51 1C    MOV   A,[0x1C]           (0529)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]    ; Place LSB in A
04CF: 58 1B    MOV   X,[0x1B]           (0530)    mov   X,[SleepTimer_1_TickCount + ST_LSB_OFFSET - 1]    ; Place MSB in X
04D1: 43 E0 40 OR    REG[0xE0],0x40     
                                        (0531)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0532)    RAM_EPILOGUE RAM_USE_CLASS_4
04D4: 7F       RET                      (0533)    ret
                                        (0534) .ENDSECTION
                                        (0535) ENDIF
                                        (0536) 
                                        (0537) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0538) .SECTION
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ;  FUNCTION NAME: SleepTimer_1_lGetTickCntr
                                        (0541) ;
                                        (0542) ;  DESCRIPTION:
                                        (0543) ;     Returns a pointer to TickCount
                                        (0544) ;
                                        (0545) ;-----------------------------------------------------------------------------
                                        (0546) ;
                                        (0547) ;  ARGUMENTS:
                                        (0548) ;     [A:X] => Pointer to 32 bit tick counter (X=LSB, A=MSB)
                                        (0549) ;
                                        (0550) ;  RETURNS:
                                        (0551) ;     Pointer to lTickCount
                                        (0552) ;
                                        (0553) ;  SIDE EFFECTS;    
                                        (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0555) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0556) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0557) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0558) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0559) ;          
                                        (0560) ;    Page Pointer Registers Modified: 
                                        (0561) ;          CUR_PP
                                        (0562) ;
                                        (0563) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0564) ;
                                        (0565)  SleepTimer_1_lGetTickCntr:
                                        (0566) _SleepTimer_1_lGetTickCntr:
                                        (0567)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0568)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0569)    ; Disable interrupt here
                                        (0570)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0571)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0572)    RAM_SETPAGE_IDX A
                                        (0573)    push  A
                                        (0574)    mov   A,[SleepTimer_1_TickCount + 0]
                                        (0575)    mov   [X + 0],A
                                        (0576)    mov   A,[SleepTimer_1_TickCount + 1]
                                        (0577)    mov   [X + 1],A
                                        (0578)    mov   A,[SleepTimer_1_TickCount + 2]
                                        (0579)    mov   [X + 2],A
                                        (0580)    mov   A,[SleepTimer_1_TickCount + 3]
                                        (0581)    mov   [X + 3],A
                                        (0582)    pop   A
                                        (0583)    
                                        (0584)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0585)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0587)    ret
                                        (0588) .ENDSECTION
                                        (0589) ENDIF
                                        (0590) 
                                        (0591) 
                                        (0592) 
                                        (0593) 
                                        (0594) ; End of File SleepTimer_1.asm
FILE: lib\rst.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   RST.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "RST.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _RST_Start
                                        (0027) export  RST_Start
                                        (0028) 
                                        (0029) export _RST_Stop
                                        (0030) export  RST_Stop
                                        (0031) 
                                        (0032) export _RST_On
                                        (0033) export  RST_On
                                        (0034) 
                                        (0035) export _RST_Off
                                        (0036) export  RST_Off
                                        (0037) 
                                        (0038) export _RST_Switch
                                        (0039) export  RST_Switch
                                        (0040) 
                                        (0041) export _RST_Invert
                                        (0042) export  RST_Invert
                                        (0043) 
                                        (0044) export _RST_GetState
                                        (0045) export  RST_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: RST_Start(void)
                                        (0054) ;  FUNCTION NAME: RST_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: RST_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _RST_On:
                                        (0079)  RST_On:
04D5: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
04D7: 80 03    JMP   _RST_Switch        (0081)    jmp  RST_Switch 
                                        (0082) 
                                        (0083) _RST_Start:
                                        (0084)  RST_Start:
                                        (0085) _RST_Stop:
                                        (0086)  RST_Stop:
                                        (0087) _RST_Off:
                                        (0088)  RST_Off:
04D9: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _RST_Switch:
                                        (0092)  RST_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
04DB: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
04DD: A0 06    JZ    0x04E4             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
04DF: 2E 1D 10 OR    [0x1D],0x10        (0102)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0105) ENDIF
04E2: 80 04    JMP   0x04E7             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
04E4: 26 1D EF AND   [0x1D],0xEF        (0110)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
04E7: 51 1D    MOV   A,[0x1D]           (0116)    mov  A,[Port_0_Data_SHADE]
04E9: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[RST_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
04EB: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: RST_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _RST_Invert:
                                        (0144)  RST_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],RST_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[RST_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: RST_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _RST_GetState:
                                        (0177)  RST_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,RST_PinMask                 ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\pwm16_1int.asm                (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:26:51
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM16_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
04EC: 7D 1C BC LJMP  _PWM16_1_CMP_ISR   (0081)    ljmp _PWM16_1_CMP_ISR
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
04EF: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWM16_1INT.asm
FILE: lib\pwm16_1.asm                   (0001) ;;*****************************************************************************
04F0: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:26:51
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM16_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM16_1_EnableInt
                                        (0030) export _PWM16_1_EnableInt
                                        (0031) export  PWM16_1_DisableInt
                                        (0032) export _PWM16_1_DisableInt
                                        (0033) export  PWM16_1_Start
                                        (0034) export _PWM16_1_Start
                                        (0035) export  PWM16_1_Stop
                                        (0036) export _PWM16_1_Stop
                                        (0037) export  PWM16_1_WritePeriod
                                        (0038) export _PWM16_1_WritePeriod
                                        (0039) export  PWM16_1_WritePulseWidth
                                        (0040) export _PWM16_1_WritePulseWidth
                                        (0041) export  PWM16_1_wReadPulseWidth
                                        (0042) export _PWM16_1_wReadPulseWidth
                                        (0043) export  PWM16_1_wReadCounter
                                        (0044) export _PWM16_1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0049) export _wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0050) export  wPWM16_1_ReadCounter       ; deprecated
                                        (0051) export _wPWM16_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA dsm_reciver_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM16_1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM16_1_EnableInt:
                                        (0091) _PWM16_1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM16_1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
04F3: 7F       RET                      (0095)    ret
04F4: 43 23 01 OR    REG[0x23],0x1      
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM16_1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM16_1_DisableInt:
                                        (0119) _PWM16_1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM16_1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0123)    ret
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM16_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM16_1_Start:
                                        (0148) _PWM16_1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM16_1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
04F7: 7F       RET                      (0152)    ret
04F8: 41 23 FE AND   REG[0x23],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM16_1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM16_1_Stop:
                                        (0176) _PWM16_1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM16_1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
04FB: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM16_1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM16_1_WritePeriod:
                                        (0206) _PWM16_1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
04FC: 60 21    MOV   REG[0x21],A        (0208)    mov   reg[PWM16_1_PERIOD_LSB_REG], A
04FE: 5B       MOV   A,X                (0209)    mov   A, X
04FF: 60 25    MOV   REG[0x25],A        (0210)    mov   reg[PWM16_1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0501: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: PWM16_1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  PWM16_1_WritePulseWidth:
                                        (0235) _PWM16_1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0502: 60 22    MOV   REG[0x22],A        (0237)    mov   reg[PWM16_1_COMPARE_LSB_REG], A
0504: 5B       MOV   A,X                (0238)    mov   A, X
0505: 60 26    MOV   REG[0x26],A        (0239)    mov   reg[PWM16_1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0507: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: PWM16_1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  PWM16_1_wReadPulseWidth:
                                        (0264) _PWM16_1_wReadPulseWidth:
                                        (0265)  wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0266) _wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0268)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]
                                        (0269)    mov   X, A
                                        (0270)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: PWM16_1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  PWM16_1_wReadCounter:
                                        (0299) _PWM16_1_wReadCounter:
                                        (0300)  wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0301) _wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0309)    mov   X, SP                                      ; X <-  stack frame pointer
                                        (0310)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Save the Compare register on the stack
                                        (0311)    push  A                                          ;
                                        (0312)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ;
                                        (0313)    push  A                                          ;  -stack frame now 2 bytes-
                                        (0314)    PWM16_1_Stop_M                                ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
                                        (0316)    mov   A, reg[PWM16_1_INPUT_LSB_REG]           ; save the LSB clock input setting
                                        (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
                                        (0319)    mov   reg[PWM16_1_INPUT_LSB_REG], INPUT_REG_NULL
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
                                        (0321)    mov   A, reg[PWM16_1_COUNTER_MSB_REG]         ; DR2 <- DR0 (in the MSB block)
                                        (0322)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Stash the Count MSB on the stack
                                        (0323)    push  A                                          ;  -stack frame is now 4 bytes
                                        (0324)    mov   A, reg[PWM16_1_COUNTER_LSB_REG]         ; DR2 <- DR0 (in the LSB block)
                                        (0325)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ; Stash the Count LSB on the stack
                                        (0326)    push  A                                          ;   -stack frame is now 5 bytes-
                                        (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
                                        (0328)    mov   reg[PWM16_1_COMPARE_MSB_REG], A         ;
                                        (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
                                        (0330)    mov   reg[PWM16_1_COMPARE_LSB_REG], A         ;
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
                                        (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
                                        (0333)    mov   reg[PWM16_1_INPUT_LSB_REG], A           ;    and restore it
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    PWM16_1_Start_M                               ; Now re-enable the PWM function
                                        (0336)    pop   A                                          ; Setup the return value
                                        (0337)    pop   X                                          ;
                                        (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File PWM16_1.asm
FILE: lib\led_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_Start
                                        (0027) export  LED_1_Start
                                        (0028) 
                                        (0029) export _LED_1_Stop
                                        (0030) export  LED_1_Stop
                                        (0031) 
                                        (0032) export _LED_1_On
                                        (0033) export  LED_1_On
                                        (0034) 
                                        (0035) export _LED_1_Off
                                        (0036) export  LED_1_Off
                                        (0037) 
                                        (0038) export _LED_1_Switch
                                        (0039) export  LED_1_Switch
                                        (0040) 
                                        (0041) export _LED_1_Invert
                                        (0042) export  LED_1_Invert
                                        (0043) 
                                        (0044) export _LED_1_GetState
                                        (0045) export  LED_1_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_On:
                                        (0079)  LED_1_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_Switch 
                                        (0082) 
                                        (0083) _LED_1_Start:
                                        (0084)  LED_1_Start:
                                        (0085) _LED_1_Stop:
                                        (0086)  LED_1_Stop:
                                        (0087) _LED_1_Off:
                                        (0088)  LED_1_Off:
0508: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_Switch:
                                        (0092)  LED_1_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0096) 
050A: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
050C: A0 06    JZ    0x0513             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(0)                                            ; Active High Digit Drive
                                        (0102)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
050E: 26 1F FE AND   [0x1F],0xFE        (0104)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0105) ENDIF
0511: 80 04    JMP   0x0516             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(0)                      ; Active High Digit Drive
                                        (0110)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
0513: 2E 1F 01 OR    [0x1F],0x1         (0112)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0516: 51 1F    MOV   A,[0x1F]           (0116)    mov  A,[Port_3_Data_SHADE]
0518: 60 0C    MOV   REG[0xC],A         (0117)    mov  reg[LED_1_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
051A: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_Invert:
                                        (0144)  LED_1_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_3_Data_SHADE],LED_1_PinMask
                                        (0150)    mov  A,[Port_3_Data_SHADE]
                                        (0151)    mov  reg[LED_1_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_GetState:
                                        (0177)  LED_1_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_3_Data_SHADE]         ; Get shade value
                                        (0183) IF(0)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_PinMask               ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\e2prom_1.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   E2PROM_1.asm
                                        (0004) ;;  Version: 1.7, Updated on 2015/3/4 at 22:26:11
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: EEPROM emulation User Module implementation file.
                                        (0008) ;;
                                        (0009) ;;     Routines in this file perform E2PROM_1 User Module Read and
                                        (0010) ;;     Write operations.
                                        (0011) ;;
                                        (0012) ;;     They provide a layer of abstraction on top of the E2PROMLIB.asm routines
                                        (0013) ;;     to allow instancing of the EEPROM devices.  Together the E2PROM and
                                        (0014) ;;     E2PROMLIB algorithms emulate a byte-wise EEPROM device on a block oriented
                                        (0015) ;;     flash architecture.
                                        (0016) ;;
                                        (0017) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0018) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0019) ;;        This means it is the caller's responsibility to preserve any values
                                        (0020) ;;        in the X and A registers that are still needed after the API functions
                                        (0021) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0022) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0023) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0024) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0025) ;;-----------------------------------------------------------------------------
                                        (0026) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0027) ;;*****************************************************************************
                                        (0028) ;;*****************************************************************************
                                        (0029) 
                                        (0030) ;Preset CPU_EQUATE for CY8C25/26xxx identification
                                        (0031) CPU_F:   equ   0
                                        (0032) 
                                        (0033) include "m8c.inc"
                                        (0034) include "E2PROM_1.inc"
                                        (0035) include "memory.inc"
                                        (0036) 
                                        (0037) ;-------------------------------------------------------------------
                                        (0038) ;  Declare the functions global for both assembler and C compiler.
                                        (0039) ;
                                        (0040) ;  Note that there are two names for each API. First name is
                                        (0041) ;  assembler reference. Name with underscore is name refence for
                                        (0042) ;  C compiler.  Calling function in C source code does not require
                                        (0043) ;  the underscore.
                                        (0044) ;-------------------------------------------------------------------
                                        (0045) 
                                        (0046) ;-----------------------------------------------
                                        (0047) ;  Global Symbols
                                        (0048) ;-----------------------------------------------
                                        (0049) 
                                        (0050) export   E2PROM_1_Start
                                        (0051) export  _E2PROM_1_Start
                                        (0052) export   E2PROM_1_Stop
                                        (0053) export  _E2PROM_1_Stop
                                        (0054) export   E2PROM_1_bE2Write
                                        (0055) export  _E2PROM_1_bE2Write
                                        (0056) export   E2PROM_1_E2Read
                                        (0057) export  _E2PROM_1_E2Read
                                        (0058) 
                                        (0059) export   E2PROM_1_RESERVED
                                        (0060) 
                                        (0061) ;-----------------------------------------------------------------
                                        (0062) ;  Allocate the E2PROM_1 EEPROM device in Flash memory
                                        (0063) ;     This will allow the linker to perform memory collision
                                        (0064) ;     checking and the EEPROM device will be displayed in the
                                        (0065) ;     map file.
                                        (0066) ;     Note that this memory region can also be accessed from "C".
                                        (0067) ;-----------------------------------------------------------------
                                        (0068) AREA  E2PROM_1_AREA   (ROM,ABS,CON)
                                        (0069)    ORG   E2PROM_1_START_ADDR
                                        (0070) 
                                        (0071) _E2PROM_1_RESERVED::
                                        (0072)  E2PROM_1_RESERVED::     blkb     40h
                                        (0073) 
                                        (0074) 
                                        (0075) AREA  UserModules (ROM,REL)
                                        (0076) 
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: E2PROM_1_Start
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Start routine for the E2PROM_1 user module.  This routine is
                                        (0082) ;     a place holder for conformance and consistency.
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS:
                                        (0086) ;     None
                                        (0087) ;
                                        (0088) ;  RETURNS:
                                        (0089) ;     None
                                        (0090) ;
                                        (0091) ;  SIDE EFFECTS: 
                                        (0092) ;    The A and X registers may be modified by this or future implementations
                                        (0093) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0094) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0095) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0096) ;    functions.
                                        (0097) ;
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)  E2PROM_1_Start:
                                        (0101) _E2PROM_1_Start:
                                        (0102)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
051B: 7F       RET                      (0104)    ret
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) 
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: E2PROM_1_Stop
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Stop routine for the E2PROM_1 user module.  This routine is
                                        (0114) ;     a place holder for conformance and consistency.
                                        (0115) ;
                                        (0116) ;-----------------------------------------------------------------------------
                                        (0117) ;
                                        (0118) ;  ARGUMENTS:
                                        (0119) ;     None
                                        (0120) ;
                                        (0121) ;  RETURNS:
                                        (0122) ;     None
                                        (0123) ;
                                        (0124) ;  SIDE EFFECTS: 
                                        (0125) ;    The A and X registers may be modified by this or future implementations
                                        (0126) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0127) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0128) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0129) ;    functions.
                                        (0130) ;
                                        (0131) .SECTION
                                        (0132) 
                                        (0133)  E2PROM_1_Stop:
                                        (0134) _E2PROM_1_Stop:
                                        (0135)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0136)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0137)    ret
                                        (0138) 
                                        (0139) .ENDSECTION
                                        (0140) 
                                        (0141) 
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;  FUNCTION NAME: E2PROM_1_E2Write
                                        (0144) ;
                                        (0145) ;  DESCRIPTION:
                                        (0146) ;     Writes the specified E2PROM data at the wAddr and wByteCount from RAM into
                                        (0147) ;     Flash into the defined E2PROM instance.
                                        (0148) ;
                                        (0149) ;     Prototype in C is:
                                        (0150) ;
                                        (0151) ;        #pragma  fastcall16 E2Write
                                        (0152) ;        void E2PROM_1_bE2Write( WORD wAddr, BYTE * pbData, WORD wByteCount,
                                        (0153) ;                                        CHAR cTemperature );
                                        (0154) ;
                                        (0155) ;     Easiest method to call from assembly is as follows:
                                        (0156) ;           push  X                    ; push X only if X needs to be perserved
                                        (0157) ;           mov   X, SP
                                        (0158) ;           push  <cTemperature>
                                        (0159) ;           push  <wByteCount>
                                        (0160) ;           push  <wByteCount+1>
                                        (0161) ;           push  <pbDataDest>                  
                                        (0162) ;           push  <pbDataDest+1>
                                        (0163) ;           push  <wAddr>
                                        (0164) ;           push  <wAddr+1>
                                        (0165) ;           call  E2PROM_1_bE2Write
                                        (0166) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0167) ;           pop   X                    ; restore X only if it was saved above
                                        (0168) ;
                                        (0169) ;           where <> refers to any addressing mode or number of instructions to
                                        (0170) ;              place the referenced data on the stack frame.
                                        (0171) ;
                                        (0172) ;     Other method is to create a stack frame using the defined equates and
                                        (0173) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0174) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0175) ;     that the index page tracks the stack page or is set to the same page
                                        (0176) ;     as the stack page.
                                        (0177) ;
                                        (0178) ;-----------------------------------------------------------------------------
                                        (0179) ;
                                        (0180) ;  ARGUMENTS:
                                        (0181) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to write data
                                        (0182) ;     pbData:        BYTE * - pointer to the RAM buffer of data to write
                                        (0183) ;     wByteCount:    WORD   - number of bytes to write into E2PROM
                                        (0184) ;     cTemperature:  CHAR   - temperature in degrees celsius
                                        (0185) ;
                                        (0186) ;  RETURNS:    E2PROM_1_NOERROR, E2PROM_1_FAILURE, or
                                        (0187) ;              E2PROM_1_STACKOVERFLOW
                                        (0188) ;
                                        (0189) ;  SIDE EFFECTS: 
                                        (0190) ;    If a partial block is to be saved to flash, then a 64 byte buffer
                                        (0191) ;    is temporary allocated.
                                        (0192) ;
                                        (0193) ;    The A and X registers may be modified by this or future implementations
                                        (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0197) ;    functions.
                                        (0198) ;          
                                        (0199) ;    Currently only the page pointer registers listed below are modified:
                                        (0200) ;       CUR_PP 
                                        (0201) ;       IDX_PP
                                        (0202) ;       MVW_PP
                                        (0203) ;                
                                        (0204) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0205) ;------------------------------------------------------------------------------
                                        (0206) .SECTION
                                        (0207) 
                                        (0208)  E2PROM_1_bE2Write::
                                        (0209) _E2PROM_1_bE2Write::
                                        (0210) 
                                        (0211) ;  RAM_PROLOGUE RAM_PROXY_CLASS_4 RAM_USE_CLASS_2  -->  implemented in E2PROMLIB  
                                        (0212) ;  Save the Flag register to perserve the native paging mode
                                        (0213) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
051C: 5D F7    MOV   A,REG[0xF7]        (0214)    mov   A, reg[CPU_F]                            
051E: 08       PUSH  A                  (0215)    push  A
                                        (0216) ENDIF
051F: 50 00    MOV   A,0x0              (0217)    mov   A, >E2PROM_1_START_BLOCK          ; push the FirstBlockID - MSB
0521: 08       PUSH  A                  (0218)    push  A
0522: 50 7F    MOV   A,0x7F             (0219)    mov   A, <E2PROM_1_START_BLOCK          ; push the FirstBlockID - LSB
0524: 08       PUSH  A                  (0220)    push  A
0525: 7D 05 BC LJMP  _bE2Write|CH0_OUT_GetState|CH0_OUT_Invert|bE2Write(0221)    ljmp  bE2Write                                  ; jmp to E2PROMLIB 
                                        (0222) 
                                        (0223) 
                                        (0224) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0225) ;      mode and flag status.
                                        (0226) 
                                        (0227) .ENDSECTION
                                        (0228) 
                                        (0229) 
                                        (0230) ;-----------------------------------------------------------------------------
                                        (0231) ;  FUNCTION NAME: E2PROM_1_E2Read
                                        (0232) ;
                                        (0233) ;  DESCRIPTION:
                                        (0234) ;     Reads the specified E2PROM data at offset=wAddr for wByteCount bytes  and
                                        (0235) ;     places the data read into the RAM buffer pbDataDest.
                                        (0236) ;
                                        (0237) ;     Prototype in C is:
                                        (0238) ;
                                        (0239) ;        #pragma  fastcall16 E2Read
                                        (0240) ;        void E2PROM_1_E2Read( WORD wAddr, BYTE * pbDataDest, WORD wByteCount );
                                        (0241) ;
                                        (0242) ;     Easiest method to call from assembly is as follows:
                                        (0243) ;           push  X                             ; only if X needs to be preserved
                                        (0244) ;           mov   X, SP
                                        (0245) ;           push  <wByteCount>
                                        (0246) ;           push  <wByteCount+1>
                                        (0247) ;           push  <pbDataDest
                                        (0248) ;           push  <pbDataDest+1>
                                        (0249) ;           push  <wAddr>
                                        (0250) ;           push  <wAddr+1>
                                        (0251) ;           call  E2PROM_1_E2Read
                                        (0252) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0253) ;           pop   X                             ; restore only if X needs to be preserved
                                        (0254) ;
                                        (0255) ;           where <> refers to any addressing mode or number of instructions to
                                        (0256) ;              place the referenced data on the stack frame.
                                        (0257) ;
                                        (0258) ;     Other method is to create a stack frame using the defined equates and
                                        (0259) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0260) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0261) ;     that the index page tracks the stack page or is set to the same page
                                        (0262) ;     as the stack page.
                                        (0263) ;
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;
                                        (0266) ;  ARGUMENTS:
                                        (0267) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to read data
                                        (0268) ;     pbDataDest:    BYTE * - pointer to the RAM buffer to place read data
                                        (0269) ;     wByteCount:    WORD   - number of bytes to read from E2PROM
                                        (0270) ;
                                        (0271) ;  RETURNS:       none
                                        (0272) ;
                                        (0273) ;  SIDE EFFECTS:
                                        (0274) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED 
                                        (0275) ;    AS MAY THE PAGE POINTER REGISTERS! 
                                        (0276) ;    
                                        (0277) ;    In the large memory model currently only the page
                                        (0278) ;    pointer registers listed below are modified.  This does
                                        (0279) ;    not guarantee that in future implementations of this
                                        (0280) ;    function other page pointer registers will not be
                                        (0281) ;    modified.
                                        (0282) ;    
                                        (0283) ;    Page Pointer Registers Modified:
                                        (0284) ;          CUR_PP
                                        (0285) ;          MVW_PP 
                                        (0286) ;
                                        (0287) ;-----------------------------------------------------------------------------
                                        (0288) .SECTION
                                        (0289) 
                                        (0290)  E2PROM_1_E2Read::
                                        (0291) _E2PROM_1_E2Read::
                                        (0292) ;  RAM_PROLOGUE RAM_PROXY_CLASS_NULL RAM_USE_CLASS_4  -->  implemented in E2PROMLIB  
                                        (0293) ;  Save the Flag register to perserve the native paging mode
                                        (0294) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
0528: 5D F7    MOV   A,REG[0xF7]        (0295)    mov   A, reg[CPU_F]                            
052A: 08       PUSH  A                  (0296)    push  A
                                        (0297) ENDIF
                                        (0298) 
                                        (0299) ;  Load the Block ID into X and A
052B: 50 00    MOV   A,0x0              (0300)    mov   A, >E2PROM_1_START_BLOCK       
052D: 5C       MOV   X,A                (0301)    mov   X, A
052E: 50 7F    MOV   A,0x7F             (0302)    mov   A, <E2PROM_1_START_BLOCK
0530: 7D 07 52 LJMP  _E2Read            (0303)    ljmp  E2Read
                                        (0304) 
                                        (0305) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0306) ;      mode and flag status.
                                        (0307) 
                                        (0308) 
                                        (0309) .ENDSECTION
                                        (0310) 
                                        (0311) ; End of File
FILE: lib\cs_pin.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CS_PIN.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CS_PIN.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CS_PIN_Start
                                        (0027) export  CS_PIN_Start
                                        (0028) 
                                        (0029) export _CS_PIN_Stop
                                        (0030) export  CS_PIN_Stop
                                        (0031) 
                                        (0032) export _CS_PIN_On
                                        (0033) export  CS_PIN_On
                                        (0034) 
                                        (0035) export _CS_PIN_Off
                                        (0036) export  CS_PIN_Off
                                        (0037) 
                                        (0038) export _CS_PIN_Switch
                                        (0039) export  CS_PIN_Switch
                                        (0040) 
                                        (0041) export _CS_PIN_Invert
                                        (0042) export  CS_PIN_Invert
                                        (0043) 
                                        (0044) export _CS_PIN_GetState
                                        (0045) export  CS_PIN_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CS_PIN_Start(void)
                                        (0054) ;  FUNCTION NAME: CS_PIN_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CS_PIN_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CS_PIN_On:
                                        (0079)  CS_PIN_On:
0533: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
0535: 80 03    JMP   _CS_PIN_Switch     (0081)    jmp  CS_PIN_Switch 
                                        (0082) 
                                        (0083) _CS_PIN_Start:
                                        (0084)  CS_PIN_Start:
                                        (0085) _CS_PIN_Stop:
                                        (0086)  CS_PIN_Stop:
                                        (0087) _CS_PIN_Off:
                                        (0088)  CS_PIN_Off:
0537: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CS_PIN_Switch:
                                        (0092)  CS_PIN_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
0539: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
053B: A0 06    JZ    0x0542             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
053D: 2E 1D 80 OR    [0x1D],0x80        (0102)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0105) ENDIF
0540: 80 04    JMP   0x0545             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
0542: 26 1D 7F AND   [0x1D],0x7F        (0110)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0545: 51 1D    MOV   A,[0x1D]           (0116)    mov  A,[Port_0_Data_SHADE]
0547: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[CS_PIN_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0549: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CS_PIN_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CS_PIN_Invert:
                                        (0144)  CS_PIN_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[CS_PIN_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CS_PIN_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CS_PIN_GetState:
                                        (0177)  CS_PIN_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CS_PIN_PinMask              ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch5_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH5_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH5_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH5_OUT_Start
                                        (0027) export  CH5_OUT_Start
                                        (0028) 
                                        (0029) export _CH5_OUT_Stop
                                        (0030) export  CH5_OUT_Stop
                                        (0031) 
                                        (0032) export _CH5_OUT_On
                                        (0033) export  CH5_OUT_On
                                        (0034) 
                                        (0035) export _CH5_OUT_Off
                                        (0036) export  CH5_OUT_Off
                                        (0037) 
                                        (0038) export _CH5_OUT_Switch
                                        (0039) export  CH5_OUT_Switch
                                        (0040) 
                                        (0041) export _CH5_OUT_Invert
                                        (0042) export  CH5_OUT_Invert
                                        (0043) 
                                        (0044) export _CH5_OUT_GetState
                                        (0045) export  CH5_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH5_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH5_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH5_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH5_OUT_On:
                                        (0079)  CH5_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH5_OUT_Switch 
                                        (0082) 
                                        (0083) _CH5_OUT_Start:
                                        (0084)  CH5_OUT_Start:
                                        (0085) _CH5_OUT_Stop:
                                        (0086)  CH5_OUT_Stop:
                                        (0087) _CH5_OUT_Off:
                                        (0088)  CH5_OUT_Off:
054A: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH5_OUT_Switch:
                                        (0092)  CH5_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
054C: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
054E: A0 06    JZ    0x0555             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0550: 2E 1E 40 OR    [0x1E],0x40        (0102)    or   [Port_1_Data_SHADE],CH5_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH5_OUT_PinMask
                                        (0105) ENDIF
0553: 80 04    JMP   0x0558             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
0555: 26 1E BF AND   [0x1E],0xBF        (0110)    and  [Port_1_Data_SHADE],~CH5_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH5_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0558: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
055A: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH5_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
055C: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH5_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH5_OUT_Invert:
                                        (0144)  CH5_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH5_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH5_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH5_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH5_OUT_GetState:
                                        (0177)  CH5_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH5_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch4_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH4_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH4_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH4_OUT_Start
                                        (0027) export  CH4_OUT_Start
                                        (0028) 
                                        (0029) export _CH4_OUT_Stop
                                        (0030) export  CH4_OUT_Stop
                                        (0031) 
                                        (0032) export _CH4_OUT_On
                                        (0033) export  CH4_OUT_On
                                        (0034) 
                                        (0035) export _CH4_OUT_Off
                                        (0036) export  CH4_OUT_Off
                                        (0037) 
                                        (0038) export _CH4_OUT_Switch
                                        (0039) export  CH4_OUT_Switch
                                        (0040) 
                                        (0041) export _CH4_OUT_Invert
                                        (0042) export  CH4_OUT_Invert
                                        (0043) 
                                        (0044) export _CH4_OUT_GetState
                                        (0045) export  CH4_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH4_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH4_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH4_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH4_OUT_On:
                                        (0079)  CH4_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH4_OUT_Switch 
                                        (0082) 
                                        (0083) _CH4_OUT_Start:
                                        (0084)  CH4_OUT_Start:
                                        (0085) _CH4_OUT_Stop:
                                        (0086)  CH4_OUT_Stop:
                                        (0087) _CH4_OUT_Off:
                                        (0088)  CH4_OUT_Off:
055D: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH4_OUT_Switch:
                                        (0092)  CH4_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
055F: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0561: A0 06    JZ    0x0568             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0563: 2E 1E 10 OR    [0x1E],0x10        (0102)    or   [Port_1_Data_SHADE],CH4_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH4_OUT_PinMask
                                        (0105) ENDIF
0566: 80 04    JMP   0x056B             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
0568: 26 1E EF AND   [0x1E],0xEF        (0110)    and  [Port_1_Data_SHADE],~CH4_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH4_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
056B: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
056D: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH4_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
056F: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH4_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH4_OUT_Invert:
                                        (0144)  CH4_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH4_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH4_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH4_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH4_OUT_GetState:
                                        (0177)  CH4_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH4_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch3_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH3_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH3_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH3_OUT_Start
                                        (0027) export  CH3_OUT_Start
                                        (0028) 
                                        (0029) export _CH3_OUT_Stop
                                        (0030) export  CH3_OUT_Stop
                                        (0031) 
                                        (0032) export _CH3_OUT_On
                                        (0033) export  CH3_OUT_On
                                        (0034) 
                                        (0035) export _CH3_OUT_Off
                                        (0036) export  CH3_OUT_Off
                                        (0037) 
                                        (0038) export _CH3_OUT_Switch
                                        (0039) export  CH3_OUT_Switch
                                        (0040) 
                                        (0041) export _CH3_OUT_Invert
                                        (0042) export  CH3_OUT_Invert
                                        (0043) 
                                        (0044) export _CH3_OUT_GetState
                                        (0045) export  CH3_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH3_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH3_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH3_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH3_OUT_On:
                                        (0079)  CH3_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH3_OUT_Switch 
                                        (0082) 
                                        (0083) _CH3_OUT_Start:
                                        (0084)  CH3_OUT_Start:
                                        (0085) _CH3_OUT_Stop:
                                        (0086)  CH3_OUT_Stop:
                                        (0087) _CH3_OUT_Off:
                                        (0088)  CH3_OUT_Off:
0570: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH3_OUT_Switch:
                                        (0092)  CH3_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0572: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0574: A0 06    JZ    0x057B             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0576: 2E 1E 01 OR    [0x1E],0x1         (0102)    or   [Port_1_Data_SHADE],CH3_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH3_OUT_PinMask
                                        (0105) ENDIF
0579: 80 04    JMP   0x057E             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
057B: 26 1E FE AND   [0x1E],0xFE        (0110)    and  [Port_1_Data_SHADE],~CH3_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH3_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
057E: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0580: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH3_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0582: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH3_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH3_OUT_Invert:
                                        (0144)  CH3_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH3_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH3_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH3_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH3_OUT_GetState:
                                        (0177)  CH3_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH3_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch2_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH2_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH2_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH2_OUT_Start
                                        (0027) export  CH2_OUT_Start
                                        (0028) 
                                        (0029) export _CH2_OUT_Stop
                                        (0030) export  CH2_OUT_Stop
                                        (0031) 
                                        (0032) export _CH2_OUT_On
                                        (0033) export  CH2_OUT_On
                                        (0034) 
                                        (0035) export _CH2_OUT_Off
                                        (0036) export  CH2_OUT_Off
                                        (0037) 
                                        (0038) export _CH2_OUT_Switch
                                        (0039) export  CH2_OUT_Switch
                                        (0040) 
                                        (0041) export _CH2_OUT_Invert
                                        (0042) export  CH2_OUT_Invert
                                        (0043) 
                                        (0044) export _CH2_OUT_GetState
                                        (0045) export  CH2_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH2_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH2_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH2_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH2_OUT_On:
                                        (0079)  CH2_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH2_OUT_Switch 
                                        (0082) 
                                        (0083) _CH2_OUT_Start:
                                        (0084)  CH2_OUT_Start:
                                        (0085) _CH2_OUT_Stop:
                                        (0086)  CH2_OUT_Stop:
                                        (0087) _CH2_OUT_Off:
                                        (0088)  CH2_OUT_Off:
0583: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH2_OUT_Switch:
                                        (0092)  CH2_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0585: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0587: A0 06    JZ    0x058E             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0589: 2E 1E 20 OR    [0x1E],0x20        (0102)    or   [Port_1_Data_SHADE],CH2_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH2_OUT_PinMask
                                        (0105) ENDIF
058C: 80 04    JMP   0x0591             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
058E: 26 1E DF AND   [0x1E],0xDF        (0110)    and  [Port_1_Data_SHADE],~CH2_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH2_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0591: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0593: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH2_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0595: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH2_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH2_OUT_Invert:
                                        (0144)  CH2_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH2_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH2_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH2_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH2_OUT_GetState:
                                        (0177)  CH2_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH2_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch1_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH1_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH1_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH1_OUT_Start
                                        (0027) export  CH1_OUT_Start
                                        (0028) 
                                        (0029) export _CH1_OUT_Stop
                                        (0030) export  CH1_OUT_Stop
                                        (0031) 
                                        (0032) export _CH1_OUT_On
                                        (0033) export  CH1_OUT_On
                                        (0034) 
                                        (0035) export _CH1_OUT_Off
                                        (0036) export  CH1_OUT_Off
                                        (0037) 
                                        (0038) export _CH1_OUT_Switch
                                        (0039) export  CH1_OUT_Switch
                                        (0040) 
                                        (0041) export _CH1_OUT_Invert
                                        (0042) export  CH1_OUT_Invert
                                        (0043) 
                                        (0044) export _CH1_OUT_GetState
                                        (0045) export  CH1_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH1_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH1_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH1_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH1_OUT_On:
                                        (0079)  CH1_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH1_OUT_Switch 
                                        (0082) 
                                        (0083) _CH1_OUT_Start:
                                        (0084)  CH1_OUT_Start:
                                        (0085) _CH1_OUT_Stop:
                                        (0086)  CH1_OUT_Stop:
                                        (0087) _CH1_OUT_Off:
                                        (0088)  CH1_OUT_Off:
0596: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH1_OUT_Switch:
                                        (0092)  CH1_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0598: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
059A: A0 06    JZ    0x05A1             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
059C: 2E 1E 02 OR    [0x1E],0x2         (0102)    or   [Port_1_Data_SHADE],CH1_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH1_OUT_PinMask
                                        (0105) ENDIF
059F: 80 04    JMP   0x05A4             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
05A1: 26 1E FD AND   [0x1E],0xFD        (0110)    and  [Port_1_Data_SHADE],~CH1_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH1_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
05A4: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
05A6: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH1_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
05A8: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH1_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH1_OUT_Invert:
                                        (0144)  CH1_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH1_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH1_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH1_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH1_OUT_GetState:
                                        (0177)  CH1_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH1_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\ch0_out.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CH0_OUT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CH0_OUT.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CH0_OUT_Start
                                        (0027) export  CH0_OUT_Start
                                        (0028) 
                                        (0029) export _CH0_OUT_Stop
                                        (0030) export  CH0_OUT_Stop
                                        (0031) 
                                        (0032) export _CH0_OUT_On
                                        (0033) export  CH0_OUT_On
                                        (0034) 
                                        (0035) export _CH0_OUT_Off
                                        (0036) export  CH0_OUT_Off
                                        (0037) 
                                        (0038) export _CH0_OUT_Switch
                                        (0039) export  CH0_OUT_Switch
                                        (0040) 
                                        (0041) export _CH0_OUT_Invert
                                        (0042) export  CH0_OUT_Invert
                                        (0043) 
                                        (0044) export _CH0_OUT_GetState
                                        (0045) export  CH0_OUT_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CH0_OUT_Start(void)
                                        (0054) ;  FUNCTION NAME: CH0_OUT_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CH0_OUT_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CH0_OUT_On:
                                        (0079)  CH0_OUT_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  CH0_OUT_Switch 
                                        (0082) 
                                        (0083) _CH0_OUT_Start:
                                        (0084)  CH0_OUT_Start:
                                        (0085) _CH0_OUT_Stop:
                                        (0086)  CH0_OUT_Stop:
                                        (0087) _CH0_OUT_Off:
                                        (0088)  CH0_OUT_Off:
05A9: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CH0_OUT_Switch:
                                        (0092)  CH0_OUT_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
05AB: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
05AD: A0 06    JZ    0x05B4             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
05AF: 2E 1E 80 OR    [0x1E],0x80        (0102)    or   [Port_1_Data_SHADE],CH0_OUT_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~CH0_OUT_PinMask
                                        (0105) ENDIF
05B2: 80 04    JMP   0x05B7             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
05B4: 26 1E 7F AND   [0x1E],0x7F        (0110)    and  [Port_1_Data_SHADE],~CH0_OUT_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],CH0_OUT_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
05B7: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
05B9: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[CH0_OUT_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
05BB: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CH0_OUT_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CH0_OUT_Invert:
                                        (0144)  CH0_OUT_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],CH0_OUT_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[CH0_OUT_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CH0_OUT_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CH0_OUT_GetState:
                                        (0177)  CH0_OUT_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CH0_OUT_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
_bE2Write|CH0_OUT_GetState|CH0_OUT_Invert|bE2Write:
    05BC: 62 D0 00 MOV   REG[0xD0],0x0
    05BF: 4F       MOV   X,SP
    05C0: 4B       SWAP  A,X
    05C1: 39 EA    CMP   A,0xEA
    05C3: C0 06    JC    0x05CA
    05C5: 50 FE    MOV   A,0xFE
    05C7: 38 FE    ADD   SP,0xFE
    05C9: 7E       RETI  
    05CA: 4F       MOV   X,SP
    05CB: 79       DEC   X
    05CC: 79       DEC   X
    05CD: 38 09    ADD   SP,0x9
    05CF: 56 08 00 MOV   [X+8],0x0
    05D2: 52 FB    MOV   A,[X-5]
    05D4: 08       PUSH  A
    05D5: 52 FC    MOV   A,[X-4]
    05D7: 08       PUSH  A
    05D8: 69 FB    ASR   [X-5]
    05DA: 6F FC    RRC   [X-4]
    05DC: 69 FB    ASR   [X-5]
    05DE: 6F FC    RRC   [X-4]
    05E0: 69 FB    ASR   [X-5]
    05E2: 6F FC    RRC   [X-4]
    05E4: 69 FB    ASR   [X-5]
    05E6: 6F FC    RRC   [X-4]
    05E8: 69 FB    ASR   [X-5]
    05EA: 6F FC    RRC   [X-4]
    05EC: 69 FB    ASR   [X-5]
    05EE: 6F FC    RRC   [X-4]
    05F0: 52 FC    MOV   A,[X-4]
    05F2: 05 01    ADD   [X+1],A
    05F4: 52 FB    MOV   A,[X-5]
    05F6: 0D 00    ADC   [X+0],A
    05F8: 18       POP   A
    05F9: 54 FC    MOV   [X-4],A
    05FB: 18       POP   A
    05FC: 54 FB    MOV   [X-5],A
    05FE: 52 FA    MOV   A,[X-6]
    0600: 54 03    MOV   [X+3],A
    0602: 52 F9    MOV   A,[X-7]
    0604: 54 02    MOV   [X+2],A
    0606: 52 F6    MOV   A,[X-10]
    0608: 54 04    MOV   [X+4],A
    060A: 52 FC    MOV   A,[X-4]
    060C: 21 3F    AND   A,0x3F
    060E: 54 09    MOV   [X+9],A
    0610: 50 40    MOV   A,0x40
    0612: 13 09    SUB   A,[X+9]
    0614: 54 0A    MOV   [X+10],A
    0616: 52 F7    MOV   A,[X-9]
    0618: B0 09    JNZ   0x0622
    061A: 52 F8    MOV   A,[X-8]
    061C: 3B 0A    CMP   A,[X+10]
    061E: D0 03    JNC   0x0622
    0620: 54 0A    MOV   [X+10],A
    0622: 3D 0A 40 CMP   [X+10],0x40
    0625: B0 1C    JNZ   0x0642
    0627: 56 08 FF MOV   [X+8],0xFF
    062A: 10       PUSH  X
    062B: 5B       MOV   A,X
    062C: 01 01    ADD   A,0x1
    062E: 5C       MOV   X,A
    062F: 5D D1    MOV   A,REG[0xD1]
    0631: 70 3F    AND   F,0x3F
    0633: 71 C0    OR    F,0xC0
    0635: 7C 07 B8 LCALL _bFlashWriteBlock
    0638: 20       POP   X
    0639: 39 00    CMP   A,0x0
    063B: A0 4D    JZ    0x0689
    063D: 56 08 00 MOV   [X+8],0x0
    0640: 80 1D    JMP   0x065E
    0642: 52 03    MOV   A,[X+3]
    0644: 54 FA    MOV   [X-6],A
    0646: 52 02    MOV   A,[X+2]
    0648: 54 F9    MOV   [X-7],A
    064A: 90 46    CALL  0x0692
    064C: 52 08    MOV   A,[X+8]
    064E: 39 FF    CMP   A,0xFF
    0650: A0 38    JZ    0x0689
    0652: 39 FE    CMP   A,0xFE
    0654: A0 34    JZ    0x0689
    0656: 52 FA    MOV   A,[X-6]
    0658: 54 03    MOV   [X+3],A
    065A: 52 F9    MOV   A,[X-7]
    065C: 54 02    MOV   [X+2],A
    065E: 52 F8    MOV   A,[X-8]
    0660: 13 0A    SUB   A,[X+10]
    0662: 54 F8    MOV   [X-8],A
    0664: D0 03    JNC   0x0668
    0666: 7B F7    DEC   [X-9]
    0668: 52 F8    MOV   A,[X-8]
    066A: 2B F7    OR    A,[X-9]
    066C: A0 1C    JZ    0x0689
    066E: 77 01    INC   [X+1]
    0670: 0F 00 00 ADC   [X+0],0x0
    0673: 52 03    MOV   A,[X+3]
    0675: 03 0A    ADD   A,[X+10]
    0677: 54 03    MOV   [X+3],A
    0679: D0 03    JNC   0x067D
    067B: 77 02    INC   [X+2]
    067D: 52 FC    MOV   A,[X-4]
    067F: 03 0A    ADD   A,[X+10]
    0681: 54 FC    MOV   [X-4],A
    0683: DF 86    JNC   0x060A
    0685: 77 FB    INC   [X-5]
    0687: 8F 82    JMP   0x060A
    0689: 52 08    MOV   A,[X+8]
    068B: 38 F5    ADD   SP,0xF5
    068D: 70 3F    AND   F,0x3F
    068F: 71 C0    OR    F,0xC0
    0691: 7E       RETI  
    0692: 5B       MOV   A,X
    0693: 4F       MOV   X,SP
    0694: 4B       SWAP  A,X
    0695: 39 A0    CMP   A,0xA0
    0697: C0 05    JC    0x069D
    0699: 56 08 FE MOV   [X+8],0xFE
    069C: 7F       RET   
    069D: 38 44    ADD   SP,0x44
    069F: 52 09    MOV   A,[X+9]
    06A1: 03 0A    ADD   A,[X+10]
    06A3: 54 0D    MOV   [X+13],A
    06A5: 52 09    MOV   A,[X+9]
    06A7: A0 22    JZ    0x06CA
    06A9: 10       PUSH  X
    06AA: 50 00    MOV   A,0x0
    06AC: 08       PUSH  A
    06AD: 52 09    MOV   A,[X+9]
    06AF: 08       PUSH  A
    06B0: 5D D1    MOV   A,REG[0xD1]
    06B2: 08       PUSH  A
    06B3: 5B       MOV   A,X
    06B4: 01 0E    ADD   A,0xE
    06B6: 08       PUSH  A
    06B7: 50 00    MOV   A,0x0
    06B9: 08       PUSH  A
    06BA: 08       PUSH  A
    06BB: 52 00    MOV   A,[X+0]
    06BD: 08       PUSH  A
    06BE: 52 01    MOV   A,[X+1]
    06C0: 20       POP   X
    06C1: 70 3F    AND   F,0x3F
    06C3: 71 C0    OR    F,0xC0
    06C5: 90 84    CALL  0x074B
    06C7: 38 FA    ADD   SP,0xFA
    06C9: 20       POP   X
    06CA: 3D 0D 40 CMP   [X+13],0x40
    06CD: D0 28    JNC   0x06F6
    06CF: 10       PUSH  X
    06D0: 50 00    MOV   A,0x0
    06D2: 08       PUSH  A
    06D3: 50 40    MOV   A,0x40
    06D5: 13 0D    SUB   A,[X+13]
    06D7: 08       PUSH  A
    06D8: 5D D1    MOV   A,REG[0xD1]
    06DA: 08       PUSH  A
    06DB: 5B       MOV   A,X
    06DC: 01 0E    ADD   A,0xE
    06DE: 0B 0D    ADC   A,[X+13]
    06E0: 08       PUSH  A
    06E1: 50 00    MOV   A,0x0
    06E3: 08       PUSH  A
    06E4: 52 0D    MOV   A,[X+13]
    06E6: 08       PUSH  A
    06E7: 52 00    MOV   A,[X+0]
    06E9: 08       PUSH  A
    06EA: 52 01    MOV   A,[X+1]
    06EC: 20       POP   X
    06ED: 70 3F    AND   F,0x3F
    06EF: 71 C0    OR    F,0xC0
    06F1: 90 58    CALL  0x074B
    06F3: 38 FA    ADD   SP,0xFA
    06F5: 20       POP   X
    06F6: 5B       MOV   A,X
    06F7: 03 09    ADD   A,[X+9]
    06F9: 01 0E    ADD   A,0xE
    06FB: 53 FC    MOV   [_ramareas_end+107],A
    06FD: 5D D1    MOV   A,REG[0xD1]
    06FF: 60 D5    MOV   REG[0xD5],A
    0701: 52 03    MOV   A,[X+3]
    0703: 53 FA    MOV   [_ramareas_end+105],A
    0705: 52 02    MOV   A,[X+2]
    0707: 60 D4    MOV   REG[0xD4],A
    0709: 52 0D    MOV   A,[X+13]
    070B: 13 09    SUB   A,[X+9]
    070D: 53 FF    MOV   [_ramareas_end+110],A
    070F: 3E FA    MVI   A,[_ramareas_end+105]
    0711: 3F FC    MVI   [_ramareas_end+107],A
    0713: 51 FA    MOV   A,[_ramareas_end+105]
    0715: B0 06    JNZ   0x071C
    0717: 5D D4    MOV   A,REG[0xD4]
    0719: 74       INC   A
    071A: 60 D4    MOV   REG[0xD4],A
    071C: 7A FF    DEC   [_ramareas_end+110]
    071E: BF F0    JNZ   0x070F
    0720: 52 03    MOV   A,[X+3]
    0722: 08       PUSH  A
    0723: 5B       MOV   A,X
    0724: 01 0E    ADD   A,0xE
    0726: 54 03    MOV   [X+3],A
    0728: 5D D1    MOV   A,REG[0xD1]
    072A: 54 02    MOV   [X+2],A
    072C: 56 08 FF MOV   [X+8],0xFF
    072F: 10       PUSH  X
    0730: 5B       MOV   A,X
    0731: 01 01    ADD   A,0x1
    0733: 5C       MOV   X,A
    0734: 5D D1    MOV   A,REG[0xD1]
    0736: 70 3F    AND   F,0x3F
    0738: 71 C0    OR    F,0xC0
    073A: 7C 07 B8 LCALL _bFlashWriteBlock
    073D: 20       POP   X
    073E: 39 00    CMP   A,0x0
    0740: A0 04    JZ    0x0745
    0742: 56 08 00 MOV   [X+8],0x0
    0745: 18       POP   A
    0746: 54 03    MOV   [X+3],A
    0748: 38 BC    ADD   SP,0xBC
    074A: 7F       RET   
    074B: 53 F8    MOV   [_ramareas_end+103],A
    074D: 5D F7    MOV   A,REG[0xF7]
    074F: 08       PUSH  A
    0750: 51 F8    MOV   A,[_ramareas_end+103]
_E2Read:
    0752: 08       PUSH  A
    0753: 10       PUSH  X
    0754: 62 D0 00 MOV   REG[0xD0],0x0
    0757: 20       POP   X
    0758: 18       POP   A
    0759: 5A F8    MOV   [_ramareas_end+103],X
    075B: 64       ASL   A
    075C: 6B F8    RLC   [_ramareas_end+103]
    075E: 64       ASL   A
    075F: 6B F8    RLC   [_ramareas_end+103]
    0761: 64       ASL   A
    0762: 6B F8    RLC   [_ramareas_end+103]
    0764: 64       ASL   A
    0765: 6B F8    RLC   [_ramareas_end+103]
    0767: 64       ASL   A
    0768: 6B F8    RLC   [_ramareas_end+103]
    076A: 64       ASL   A
    076B: 6B F8    RLC   [_ramareas_end+103]
    076D: 21 C0    AND   A,0xC0
    076F: 53 F9    MOV   [_ramareas_end+104],A
    0771: 4F       MOV   X,SP
    0772: 52 F7    MOV   A,[X-9]
    0774: 2B F8    OR    A,[X-8]
    0776: A0 3B    JZ    0x07B2
    0778: 52 F7    MOV   A,[X-9]
    077A: 53 FE    MOV   [_ramareas_end+109],A
    077C: 52 F8    MOV   A,[X-8]
    077E: 53 FF    MOV   [_ramareas_end+110],A
    0780: 76 FE    INC   [_ramareas_end+109]
    0782: 52 FA    MOV   A,[X-6]
    0784: 53 FD    MOV   [_ramareas_end+108],A
    0786: 52 F9    MOV   A,[X-7]
    0788: 60 D5    MOV   REG[0xD5],A
    078A: 51 F9    MOV   A,[_ramareas_end+104]
    078C: 05 FC    ADD   [X-4],A
    078E: 51 F8    MOV   A,[_ramareas_end+103]
    0790: 0D FB    ADC   [X-5],A
    0792: 52 FB    MOV   A,[X-5]
    0794: 59 FC    MOV   X,[X-4]
    0796: 08       PUSH  A
    0797: 28       ROMX  
    0798: 3F FD    MVI   [_ramareas_end+108],A
    079A: 18       POP   A
    079B: 75       INC   X
    079C: B0 02    JNZ   0x079F
    079E: 74       INC   A
    079F: 08       PUSH  A
    07A0: 51 FD    MOV   A,[_ramareas_end+108]
    07A2: B0 06    JNZ   0x07A9
    07A4: 5D D5    MOV   A,REG[0xD5]
    07A6: 74       INC   A
    07A7: 60 D5    MOV   REG[0xD5],A
    07A9: 18       POP   A
    07AA: 7A FF    DEC   [_ramareas_end+110]
    07AC: BF E9    JNZ   0x0796
    07AE: 7A FE    DEC   [_ramareas_end+109]
    07B0: BF E5    JNZ   0x0796
    07B2: 70 3F    AND   F,0x3F
    07B4: 71 C0    OR    F,0xC0
    07B6: 7E       RETI  
    07B7: 30       HALT  
_bFlashWriteBlock:
    07B8: 62 D0 00 MOV   REG[0xD0],0x0
    07BB: 53 F8    MOV   [_ramareas_end+103],A
    07BD: 5D F7    MOV   A,REG[0xF7]
    07BF: 08       PUSH  A
    07C0: 21 C0    AND   A,0xC0
    07C2: B0 07    JNZ   0x07CA
    07C4: 56 01 00 MOV   [X+1],0x0
    07C7: 55 F8 00 MOV   [_ramareas_end+103],0x0
    07CA: 51 F8    MOV   A,[_ramareas_end+103]
    07CC: 70 3F    AND   F,0x3F
    07CE: 71 80    OR    F,0x80
    07D0: 60 D3    MOV   REG[0xD3],A
    07D2: 55 FD 01 MOV   [_ramareas_end+108],0x1
    07D5: 3C FD 01 CMP   [_ramareas_end+108],0x1
    07D8: B0 E2    JNZ   0x08BB
    07DA: 7C 00 F2 LCALL 0x00F2
    07DD: 21 06    AND   A,0x6
    07DF: A0 19    JZ    0x07F9
    07E1: 71 10    OR    F,0x10
    07E3: 5D E0    MOV   A,REG[0xE0]
    07E5: 08       PUSH  A
    07E6: 21 F8    AND   A,0xF8
    07E8: 49 FE 10 TST   REG[0xFE],0x10
    07EB: A0 05    JZ    0x07F1
    07ED: 29 02    OR    A,0x2
    07EF: 80 03    JMP   0x07F3
    07F1: 29 00    OR    A,0x0
    07F3: 60 E0    MOV   REG[0xE0],A
    07F5: 70 EF    AND   F,0xEF
    07F7: 80 17    JMP   0x080F
    07F9: 71 10    OR    F,0x10
    07FB: 5D E0    MOV   A,REG[0xE0]
    07FD: 08       PUSH  A
    07FE: 21 F8    AND   A,0xF8
    0800: 49 FE 10 TST   REG[0xFE],0x10
    0803: A0 05    JZ    0x0809
    0805: 29 03    OR    A,0x3
    0807: 80 03    JMP   0x080B
    0809: 29 02    OR    A,0x2
    080B: 60 E0    MOV   REG[0xE0],A
    080D: 70 EF    AND   F,0xEF
    080F: 62 E3 00 MOV   REG[0xE3],0x0
    0812: 65 FD    ASL   [_ramareas_end+108]
    0814: 3C FD 02 CMP   [_ramareas_end+108],0x2
    0817: B0 A3    JNZ   0x08BB
    0819: 90 B0    CALL  0x08CB
    081B: 39 00    CMP   A,0x0
    081D: A0 09    JZ    0x0827
    081F: 55 FF 00 MOV   [_ramareas_end+110],0x0
    0822: 55 FD 10 MOV   [_ramareas_end+108],0x10
    0825: 80 80    JMP   0x08A6
    0827: 65 FD    ASL   [_ramareas_end+108]
    0829: 71 10    OR    F,0x10
    082B: 49 E4 08 TST   REG[0xE4],0x8
    082E: A0 05    JZ    0x0834
    0830: 70 EF    AND   F,0xEF
    0832: 80 2E    JMP   0x0861
    0834: 70 EF    AND   F,0xEF
    0836: 62 E3 00 MOV   REG[0xE3],0x0
    0839: 52 00    MOV   A,[X+0]
    083B: 53 FA    MOV   [_ramareas_end+105],A
    083D: 52 04    MOV   A,[X+4]
    083F: 53 FC    MOV   [_ramareas_end+107],A
    0841: 55 FE 56 MOV   [_ramareas_end+109],0x56
    0844: 51 FD    MOV   A,[_ramareas_end+108]
    0846: 39 04    CMP   A,0x4
    0848: B0 72    JNZ   0x08BB
    084A: 08       PUSH  A
    084B: 10       PUSH  X
_FlashBlockLocal1:
    084C: 4F       MOV   X,SP
    084D: 5B       MOV   A,X
    084E: 01 03    ADD   A,0x3
    0850: 53 F9    MOV   [_ramareas_end+104],A
    0852: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    0855: 50 03    MOV   A,0x3
    0857: 00       SWI   
    0858: 20       POP   X
    0859: 18       POP   A
    085A: 53 FD    MOV   [_ramareas_end+108],A
    085C: 3C F8 00 CMP   [_ramareas_end+103],0x0
    085F: A0 09    JZ    0x0869
    0861: 55 FF 00 MOV   [_ramareas_end+110],0x0
    0864: 55 FD 10 MOV   [_ramareas_end+108],0x10
    0867: 80 3E    JMP   0x08A6
    0869: 62 E3 00 MOV   REG[0xE3],0x0
    086C: 65 FD    ASL   [_ramareas_end+108]
    086E: 52 00    MOV   A,[X+0]
    0870: 53 FA    MOV   [_ramareas_end+105],A
    0872: 52 02    MOV   A,[X+2]
    0874: 53 FB    MOV   [_ramareas_end+106],A
    0876: 52 01    MOV   A,[X+1]
    0878: 60 D4    MOV   REG[0xD4],A
    087A: 52 05    MOV   A,[X+5]
    087C: 53 FC    MOV   [_ramareas_end+107],A
    087E: 55 FE 56 MOV   [_ramareas_end+109],0x56
    0881: 51 FD    MOV   A,[_ramareas_end+108]
    0883: 39 08    CMP   A,0x8
    0885: B0 35    JNZ   0x08BB
    0887: 08       PUSH  A
    0888: 10       PUSH  X
_FlashBlockLocal2:
    0889: 4F       MOV   X,SP
    088A: 5B       MOV   A,X
    088B: 01 03    ADD   A,0x3
    088D: 53 F9    MOV   [_ramareas_end+104],A
    088F: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    0892: 50 02    MOV   A,0x2
    0894: 00       SWI   
    0895: 20       POP   X
    0896: 18       POP   A
    0897: 53 FD    MOV   [_ramareas_end+108],A
    0899: 55 FF 01 MOV   [_ramareas_end+110],0x1
    089C: 3C F8 00 CMP   [_ramareas_end+103],0x0
    089F: A0 04    JZ    0x08A4
    08A1: 55 FF 00 MOV   [_ramareas_end+110],0x0
    08A4: 65 FD    ASL   [_ramareas_end+108]
    08A6: 3C FD 10 CMP   [_ramareas_end+108],0x10
    08A9: B0 11    JNZ   0x08BB
    08AB: 18       POP   A
    08AC: 71 10    OR    F,0x10
    08AE: 60 E0    MOV   REG[0xE0],A
    08B0: 70 EF    AND   F,0xEF
    08B2: 65 FD    ASL   [_ramareas_end+108]
    08B4: 51 FF    MOV   A,[_ramareas_end+110]
    08B6: 3C FD 20 CMP   [_ramareas_end+108],0x20
    08B9: A0 04    JZ    0x08BE
    08BB: 30       HALT  
    08BC: 8F FE    JMP   0x08BB
    08BE: 62 D0 00 MOV   REG[0xD0],0x0
    08C1: 62 D5 00 MOV   REG[0xD5],0x0
    08C4: 62 D4 00 MOV   REG[0xD4],0x0
    08C7: 7E       RETI  
    08C8: 30       HALT  
    08C9: 30       HALT  
    08CA: 30       HALT  
    08CB: 55 FA 03 MOV   [_ramareas_end+105],0x3
    08CE: 62 D5 00 MOV   REG[0xD5],0x0
    08D1: 51 FD    MOV   A,[_ramareas_end+108]
    08D3: 39 02    CMP   A,0x2
    08D5: BF E5    JNZ   0x08BB
    08D7: 08       PUSH  A
    08D8: 10       PUSH  X
_FlashBlockLocal3:
    08D9: 4F       MOV   X,SP
    08DA: 5B       MOV   A,X
    08DB: 01 03    ADD   A,0x3
    08DD: 53 F9    MOV   [_ramareas_end+104],A
    08DF: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    08E2: 50 06    MOV   A,0x6
    08E4: 00       SWI   
    08E5: 20       POP   X
    08E6: 3C FF 01 CMP   [_ramareas_end+110],0x1
    08E9: B0 80    JNZ   0x096A
    08EB: 10       PUSH  X
    08EC: 5D D3    MOV   A,REG[0xD3]
    08EE: 08       PUSH  A
    08EF: 52 03    MOV   A,[X+3]
    08F1: 08       PUSH  A
    08F2: 62 D3 00 MOV   REG[0xD3],0x0
    08F5: 21 80    AND   A,0x80
    08F7: B0 05    JNZ   0x08FD
    08F9: 57 FB    MOV   X,0xFB
    08FB: 80 07    JMP   0x0903
    08FD: 57 F8    MOV   X,0xF8
    08FF: 18       POP   A
    0900: 73       CPL   A
    0901: 74       INC   A
    0902: 08       PUSH  A
    0903: 18       POP   A
    0904: 10       PUSH  X
    0905: 08       PUSH  A
    0906: 52 00    MOV   A,[X+0]
    0908: 20       POP   X
    0909: 90 69    CALL  0x0974
    090B: 64       ASL   A
    090C: 5B       MOV   A,X
    090D: 6A       RLC   A
    090E: 20       POP   X
    090F: 08       PUSH  A
    0910: 5B       MOV   A,X
    0911: 39 F8    CMP   A,0xF8
    0913: A0 05    JZ    0x0919
    0915: 18       POP   A
    0916: 73       CPL   A
    0917: 74       INC   A
    0918: 08       PUSH  A
    0919: 18       POP   A
    091A: 03 01    ADD   A,[X+1]
    091C: 53 FE    MOV   [_ramareas_end+109],A
    091E: 52 02    MOV   A,[X+2]
    0920: 10       PUSH  X
    0921: 5C       MOV   X,A
    0922: 51 FE    MOV   A,[_ramareas_end+109]
    0924: 90 4E    CALL  0x0974
    0926: 4B       SWAP  A,X
    0927: 53 FF    MOV   [_ramareas_end+110],A
    0929: 5B       MOV   A,X
    092A: 20       POP   X
    092B: 64       ASL   A
    092C: 6B FF    RLC   [_ramareas_end+110]
    092E: 64       ASL   A
    092F: 6B FF    RLC   [_ramareas_end+110]
    0931: 51 FF    MOV   A,[_ramareas_end+110]
    0933: 5C       MOV   X,A
    0934: 18       POP   A
    0935: 60 D3    MOV   REG[0xD3],A
    0937: 5B       MOV   A,X
    0938: 20       POP   X
    0939: 54 05    MOV   [X+5],A
    093B: 51 FE    MOV   A,[_ramareas_end+109]
    093D: 54 04    MOV   [X+4],A
    093F: 7C 00 F2 LCALL 0x00F2
    0942: 21 06    AND   A,0x6
    0944: A0 07    JZ    0x094C
    0946: 69 04    ASR   [X+4]
    0948: 69 05    ASR   [X+5]
    094A: 80 0D    JMP   0x0958
    094C: 49 FE 10 TST   REG[0xFE],0x10
    094F: A0 10    JZ    0x0960
    0951: 7C 00 F2 LCALL 0x00F2
    0954: 21 04    AND   A,0x4
    0956: B0 09    JNZ   0x0960
    0958: 69 05    ASR   [X+5]
    095A: 77 05    INC   [X+5]
    095C: 69 04    ASR   [X+4]
    095E: 77 04    INC   [X+4]
    0960: 18       POP   A
    0961: 39 02    CMP   A,0x2
    0963: BF 57    JNZ   0x08BB
    0965: 53 FD    MOV   [_ramareas_end+108],A
    0967: 50 00    MOV   A,0x0
    0969: 7F       RET   
    096A: 18       POP   A
    096B: 39 02    CMP   A,0x2
    096D: BF 4D    JNZ   0x08BB
    096F: 53 FD    MOV   [_ramareas_end+108],A
    0971: 50 01    MOV   A,0x1
    0973: 7F       RET   
    0974: 71 40    OR    F,0x40
    0976: 08       PUSH  A
    0977: 5B       MOV   A,X
    0978: 4F       MOV   X,SP
    0979: 79       DEC   X
    097A: 08       PUSH  A
    097B: 50 00    MOV   A,0x0
    097D: 08       PUSH  A
    097E: 08       PUSH  A
    097F: 52 00    MOV   A,[X+0]
    0981: A0 1C    JZ    0x099E
    0983: 52 01    MOV   A,[X+1]
    0985: A0 18    JZ    0x099E
    0987: 50 08    MOV   A,0x8
    0989: 70 FB    AND   F,0xFB
    098B: 6F 00    RRC   [X+0]
    098D: D0 09    JNC   0x0997
    098F: 08       PUSH  A
    0990: 52 01    MOV   A,[X+1]
    0992: 70 FB    AND   F,0xFB
    0994: 05 02    ADD   [X+2],A
    0996: 18       POP   A
    0997: 6F 02    RRC   [X+2]
    0999: 6F 03    RRC   [X+3]
    099B: 78       DEC   A
    099C: BF EC    JNZ   0x0989
    099E: 52 02    MOV   A,[X+2]
    09A0: 08       PUSH  A
    09A1: 52 03    MOV   A,[X+3]
    09A3: 20       POP   X
    09A4: 38 FC    ADD   SP,0xFC
    09A6: 70 BF    AND   F,0xBF
    09A8: 7F       RET   
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\config.c
(0001) #include "config.h"
(0002) 
(0003) extern CHAR  E2PROM_1_bE2Write(WORD wAddr, BYTE * pbData, WORD wByteCount, CHAR cTemperature);
(0004) extern void  E2PROM_1_E2Read(WORD wAddr, BYTE * pbDataDest, WORD wByteCount);
(0005) 
(0006) RAM_D mem;
(0007) #define buf mem.buf
(0008) 
(0009) 
(0010) void SaveConfig(void *Data,BYTE Cnt)
(0011) {
_FlashReadBlock|__UserModules_end|__text_start|_SaveConfig|_SaveConfig:
  n                    --> X+0
  Cnt                  --> X-6
  Data                 --> X-5
    09A9: 10       PUSH  X
    09AA: 4F       MOV   X,SP
    09AB: 38 01    ADD   SP,0x1
(0012) BYTE n;	
(0013) #ifndef DEBUG
(0014) E2PROM_1_E2Read(0,buf,32);
    09AD: 10       PUSH  X
    09AE: 50 00    MOV   A,0x0
    09B0: 08       PUSH  A
    09B1: 50 20    MOV   A,0x20
    09B3: 08       PUSH  A
    09B4: 50 00    MOV   A,0x0
    09B6: 08       PUSH  A
    09B7: 50 20    MOV   A,0x20
    09B9: 08       PUSH  A
    09BA: 50 00    MOV   A,0x0
    09BC: 08       PUSH  A
    09BD: 08       PUSH  A
    09BE: 7C 05 28 LCALL _E2PROM_1_E2Read
    09C1: 38 FA    ADD   SP,0xFA
    09C3: 20       POP   X
(0015) #endif
(0016) buf[0]=CONFIG_ID;
    09C4: 55 20 21 MOV   [mem],0x21
(0017) for (n=0;n<Cnt;n++)
    09C7: 56 00 00 MOV   [X+0],0x0
    09CA: 80 19    JMP   0x09E4
(0018) 	buf[n+1]=((BYTE *)Data)[n];
    09CC: 52 00    MOV   A,[X+0]
    09CE: 53 16    MOV   [__r1],A
    09D0: 52 FC    MOV   A,[X-4]
    09D2: 04 16    ADD   [__r1],A
    09D4: 3E 16    MVI   A,[__r1]
    09D6: 53 17    MOV   [__r0],A
    09D8: 52 00    MOV   A,[X+0]
    09DA: 01 21    ADD   A,0x21
    09DC: 53 14    MOV   [__r3],A
    09DE: 51 17    MOV   A,[__r0]
    09E0: 3F 14    MVI   [__r3],A
    09E2: 77 00    INC   [X+0]
    09E4: 52 00    MOV   A,[X+0]
    09E6: 3B FA    CMP   A,[X-6]
    09E8: CF E3    JC    0x09CC
(0019) #ifndef DEBUG
(0020) E2PROM_1_bE2Write(0,buf,64,25);
    09EA: 10       PUSH  X
    09EB: 50 19    MOV   A,0x19
    09ED: 08       PUSH  A
    09EE: 50 00    MOV   A,0x0
    09F0: 08       PUSH  A
    09F1: 50 40    MOV   A,0x40
    09F3: 08       PUSH  A
    09F4: 50 00    MOV   A,0x0
    09F6: 08       PUSH  A
    09F7: 50 20    MOV   A,0x20
    09F9: 08       PUSH  A
    09FA: 50 00    MOV   A,0x0
    09FC: 08       PUSH  A
    09FD: 08       PUSH  A
    09FE: 7C 05 1C LCALL _E2PROM_1_Stop|_E2PROM_1_bE2Write|E2PROM_1_bE2Write
    0A01: 38 F9    ADD   SP,0xF9
    0A03: 20       POP   X
    0A04: 38 FF    ADD   SP,0xFF
    0A06: 20       POP   X
    0A07: 7F       RET   
(0021) #endif
(0022) }
(0023) 
(0024) BOOL ReadConfig(void *Data,BYTE Cnt)
(0025) {
_ReadConfig:
  n                    --> X+0
  Cnt                  --> X-6
  Data                 --> X-5
    0A08: 10       PUSH  X
    0A09: 4F       MOV   X,SP
    0A0A: 38 01    ADD   SP,0x1
(0026) BYTE n;	
(0027) #ifndef DEBUG
(0028) E2PROM_1_E2Read(0,buf,32);
    0A0C: 10       PUSH  X
    0A0D: 50 00    MOV   A,0x0
    0A0F: 08       PUSH  A
    0A10: 50 20    MOV   A,0x20
    0A12: 08       PUSH  A
    0A13: 50 00    MOV   A,0x0
    0A15: 08       PUSH  A
    0A16: 50 20    MOV   A,0x20
    0A18: 08       PUSH  A
    0A19: 50 00    MOV   A,0x0
    0A1B: 08       PUSH  A
    0A1C: 08       PUSH  A
    0A1D: 7C 05 28 LCALL _E2PROM_1_E2Read
    0A20: 38 FA    ADD   SP,0xFA
    0A22: 20       POP   X
(0029) #endif
(0030) if(buf[0]!=CONFIG_ID)
    0A23: 3C 20 21 CMP   [mem],0x21
    0A26: A0 05    JZ    0x0A2C
(0031) 	{
(0032) 		return FALSE;
    0A28: 50 00    MOV   A,0x0
    0A2A: 80 26    JMP   0x0A51
(0033) 	}
(0034) else
(0035) 	{
(0036) 	for (n=0;n<Cnt;n++)
    0A2C: 56 00 00 MOV   [X+0],0x0
    0A2F: 80 19    JMP   0x0A49
(0037) 		((BYTE *)Data)[n]=buf[n+1];
    0A31: 52 00    MOV   A,[X+0]
    0A33: 01 21    ADD   A,0x21
    0A35: 53 16    MOV   [__r1],A
    0A37: 3E 16    MVI   A,[__r1]
    0A39: 53 17    MOV   [__r0],A
    0A3B: 52 00    MOV   A,[X+0]
    0A3D: 53 14    MOV   [__r3],A
    0A3F: 52 FC    MOV   A,[X-4]
    0A41: 04 14    ADD   [__r3],A
    0A43: 51 17    MOV   A,[__r0]
    0A45: 3F 14    MVI   [__r3],A
    0A47: 77 00    INC   [X+0]
    0A49: 52 00    MOV   A,[X+0]
    0A4B: 3B FA    CMP   A,[X-6]
    0A4D: CF E3    JC    0x0A31
(0038) 	}
(0039) return TRUE;
    0A4F: 50 01    MOV   A,0x1
(0040) }
(0041) 
(0042) 
(0043) 
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\cyrf6936.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "CYRF6936.h"
(0003) #include "delay.h"
(0004) #include "timer.h"
(0005) 
(0006) volatile BOOL CY_irq;
(0007) 
(0008) //called on a GPIO interrupt
(0009) #pragma interrupt_handler GPIO_ISR
(0010) void GPIO_ISR(void )
(0011) {
_GPIO_ISR:
    0A55: 08       PUSH  A
    0A56: 51 17    MOV   A,[__r0]
    0A58: 08       PUSH  A
(0012) 	if (PRT0DR&CY_IRQPin_MASK) //Check if  pin went high
    0A59: 5D 00    MOV   A,REG[0x0]
    0A5B: 53 17    MOV   [__r0],A
    0A5D: 47 17 40 TST   [__r0],0x40
    0A60: A0 04    JZ    0x0A65
(0013) 	{
(0014) 		CY_irq=TRUE;
    0A62: 55 40 01 MOV   [CY_irq],0x1
(0015) 	}
    0A65: 18       POP   A
    0A66: 53 17    MOV   [__r0],A
    0A68: 18       POP   A
    0A69: 7E       RETI  
(0016) }
(0017) 
(0018) 
(0019) //initialize cyrf chip
(0020) void CYRF_Init(void )
(0021) {
(0022) 	RST_Start();
_CYRF_Init:
    0A6A: 10       PUSH  X
    0A6B: 7C 04 D9 LCALL _RST_Stop|RST_Off|RST_Start|_RST_Start|_RST_Off|RST_Stop
(0023) 	CS_PIN_Start();
    0A6E: 7C 05 37 LCALL _CS_PIN_Start|CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop
(0024) 	SPIM_1_Start(SPIM_1_SPIM_MODE_0 | SPIM_1_SPIM_MSB_FIRST);
    0A71: 50 00    MOV   A,0x0
    0A73: 7C 04 84 LCALL _Timer8_1_bReadCompareValue|_bTimer8_1_ReadCompareValue|bTimer8_1_ReadTimerSaveCV|bTimer8_1_CaptureCounter|_Timer8_1_bReadTimer|_bTimer8_1_ReadCounter|_bTimer8_1_ReadTimer|_SPIM_1_EnableInt|_SPIM_1_Start|bTimer8_1_ReadCounter|_Timer8_1_bReadTimerSaveCV|...
(0025) 	//manua inline
(0026) 	//CYRF_Reset();
(0027) 	//reset cyrf chip
(0028) 	//void CYRF_Reset(void)
(0029) 	{
(0030) 	    RS_HI();
    0A76: 7C 04 D5 LCALL _RST_On
(0031) 		CS_HI();
    0A79: 7C 05 33 LCALL _CS_PIN_On
(0032) 	    SleepTimer_1_TickWait(2);
    0A7C: 50 02    MOV   A,0x2
    0A7E: 7C 04 BB LCALL _SleepTimer_1_Stop|_SleepTimer_1_TickWait|_SleepTimer_1_SetInterval|SleepTimer_1_TickWait
(0033) 	    RS_LO();
    0A81: 7C 04 D9 LCALL _RST_Stop|RST_Off|RST_Start|_RST_Start|_RST_Off|RST_Stop
(0034) 	   SleepTimer_1_TickWait(10);
    0A84: 50 0A    MOV   A,0xA
    0A86: 7C 04 BB LCALL _SleepTimer_1_Stop|_SleepTimer_1_TickWait|_SleepTimer_1_SetInterval|SleepTimer_1_TickWait
    0A89: 20       POP   X
(0035) 	}
(0036)     CYRF_WriteRegister(CYRF_XACT_CFG, (CYRF_ACK_TO_12x));
    0A8A: 50 02    MOV   A,0x2
    0A8C: 08       PUSH  A
    0A8D: 50 0F    MOV   A,0xF
    0A8F: 08       PUSH  A
    0A90: 90 10    CALL  _CYRF_WriteRegister
    0A92: 38 FE    ADD   SP,0xFE
(0037)     Delay50uTimes(100);
    0A94: 10       PUSH  X
    0A95: 50 64    MOV   A,0x64
    0A97: 7C 0C 7E LCALL _Delay50uTimes
    0A9A: 20       POP   X
(0038) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); 
    0A9B: 43 E0 20 OR    REG[0xE0],0x20
(0039) 	CY_irq=FALSE;
    0A9E: 55 40 00 MOV   [CY_irq],0x0
    0AA1: 7F       RET   
(0040) }
(0041) 
(0042) 
(0043) //write a singel register
(0044) void CYRF_WriteRegister(BYTE reg, BYTE val)
(0045) {
_CYRF_WriteRegister:
  val                  --> X-5
  reg                  --> X-4
    0AA2: 10       PUSH  X
    0AA3: 4F       MOV   X,SP
(0046) CYRF_WriteRegisterMultiD(reg,&val,1);
    0AA4: 50 01    MOV   A,0x1
    0AA6: 08       PUSH  A
    0AA7: 5A 16    MOV   [__r1],X
    0AA9: 16 16 05 SUB   [__r1],0x5
    0AAC: 51 17    MOV   A,[__r0]
    0AAE: 08       PUSH  A
    0AAF: 51 16    MOV   A,[__r1]
    0AB1: 08       PUSH  A
    0AB2: 52 FC    MOV   A,[X-4]
    0AB4: 08       PUSH  A
    0AB5: 90 69    CALL  _CYRF_WriteRegisterMultiD
    0AB7: 38 FC    ADD   SP,0xFC
    0AB9: 20       POP   X
    0ABA: 7F       RET   
(0047) }
(0048) 
(0049) 
(0050) //write a single register cnt times
(0051) void CYRF_WriteRegisterMulti(BYTE reg,BYTE const data[] , BYTE cnt)
(0052) {
_CYRF_WriteRegisterMulti:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0ABB: 10       PUSH  X
    0ABC: 4F       MOV   X,SP
    0ABD: 38 01    ADD   SP,0x1
(0053) 	BYTE n;
(0054)     CS_LO();
    0ABF: 10       PUSH  X
    0AC0: 7C 05 37 LCALL _CS_PIN_Start|CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop
    0AC3: 20       POP   X
(0055) 	//wait for buffer empty
(0056) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0AC4: 10       PUSH  X
    0AC5: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0AC8: 20       POP   X
    0AC9: 53 17    MOV   [__r0],A
    0ACB: 47 17 10 TST   [__r0],0x10
    0ACE: AF F5    JZ    0x0AC4
(0057) 	//write address
(0058) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0AD0: 52 FC    MOV   A,[X-4]
    0AD2: 29 80    OR    A,0x80
    0AD4: 10       PUSH  X
    0AD5: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0AD8: 20       POP   X
(0059)     for(n = 0; n < cnt; n++)
    0AD9: 56 00 00 MOV   [X+0],0x0
    0ADC: 80 28    JMP   0x0B05
(0060)     {
(0061) 		//wait for buffer empty
(0062) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0ADE: 10       PUSH  X
    0ADF: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0AE2: 20       POP   X
    0AE3: 53 17    MOV   [__r0],A
    0AE5: 47 17 10 TST   [__r0],0x10
    0AE8: AF F5    JZ    0x0ADE
(0063) 	    //write data
(0064) 		SPIM_1_SendTxData(data[n]);
    0AEA: 52 00    MOV   A,[X+0]
    0AEC: 53 16    MOV   [__r1],A
    0AEE: 55 17 00 MOV   [__r0],0x0
    0AF1: 52 FB    MOV   A,[X-5]
    0AF3: 04 16    ADD   [__r1],A
    0AF5: 52 FA    MOV   A,[X-6]
    0AF7: 0C 17    ADC   [__r0],A
    0AF9: 51 17    MOV   A,[__r0]
    0AFB: 10       PUSH  X
    0AFC: 58 16    MOV   X,[__r1]
    0AFE: 28       ROMX  
    0AFF: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0B02: 20       POP   X
(0065)     }
    0B03: 77 00    INC   [X+0]
    0B05: 52 00    MOV   A,[X+0]
    0B07: 3B F9    CMP   A,[X-7]
    0B09: CF D4    JC    0x0ADE
(0066) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0B0B: 10       PUSH  X
    0B0C: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0B0F: 20       POP   X
    0B10: 53 17    MOV   [__r0],A
    0B12: 47 17 20 TST   [__r0],0x20
    0B15: AF F5    JZ    0x0B0B
(0067) 	CS_HI();
    0B17: 10       PUSH  X
    0B18: 7C 05 33 LCALL _CS_PIN_On
    0B1B: 20       POP   X
    0B1C: 38 FF    ADD   SP,0xFF
    0B1E: 20       POP   X
    0B1F: 7F       RET   
(0068) }
(0069) void CYRF_WriteRegisterMultiD(BYTE reg, BYTE data[], BYTE cnt)
(0070) {
_CYRF_WriteRegisterMultiD:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B20: 10       PUSH  X
    0B21: 4F       MOV   X,SP
    0B22: 38 01    ADD   SP,0x1
(0071) 	BYTE n;
(0072)     CS_LO();
    0B24: 10       PUSH  X
    0B25: 7C 05 37 LCALL _CS_PIN_Start|CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop
    0B28: 20       POP   X
(0073) 	//wait for buffer empty
(0074) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B29: 10       PUSH  X
    0B2A: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0B2D: 20       POP   X
    0B2E: 53 17    MOV   [__r0],A
    0B30: 47 17 10 TST   [__r0],0x10
    0B33: AF F5    JZ    0x0B29
(0075) 	//write address
(0076) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0B35: 52 FC    MOV   A,[X-4]
    0B37: 29 80    OR    A,0x80
    0B39: 10       PUSH  X
    0B3A: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0B3D: 20       POP   X
(0077)     for(n = 0; n < cnt; n++)
    0B3E: 56 00 00 MOV   [X+0],0x0
    0B41: 80 1E    JMP   0x0B60
(0078)     {
(0079) 		//wait for buffer empty
(0080) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B43: 10       PUSH  X
    0B44: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0B47: 20       POP   X
    0B48: 53 17    MOV   [__r0],A
    0B4A: 47 17 10 TST   [__r0],0x10
    0B4D: AF F5    JZ    0x0B43
(0081) 	    //write data
(0082) 		SPIM_1_SendTxData(data[n]);
    0B4F: 52 00    MOV   A,[X+0]
    0B51: 53 16    MOV   [__r1],A
    0B53: 52 FB    MOV   A,[X-5]
    0B55: 04 16    ADD   [__r1],A
    0B57: 3E 16    MVI   A,[__r1]
    0B59: 10       PUSH  X
    0B5A: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0B5D: 20       POP   X
(0083)     }
    0B5E: 77 00    INC   [X+0]
    0B60: 52 00    MOV   A,[X+0]
    0B62: 3B F9    CMP   A,[X-7]
    0B64: CF DE    JC    0x0B43
(0084) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0B66: 10       PUSH  X
    0B67: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0B6A: 20       POP   X
    0B6B: 53 17    MOV   [__r0],A
    0B6D: 47 17 20 TST   [__r0],0x20
    0B70: AF F5    JZ    0x0B66
(0085) 	CS_HI();
    0B72: 10       PUSH  X
    0B73: 7C 05 33 LCALL _CS_PIN_On
    0B76: 20       POP   X
    0B77: 38 FF    ADD   SP,0xFF
    0B79: 20       POP   X
    0B7A: 7F       RET   
(0086) }
(0087) 
(0088) 
(0089) void CYRF_WriteRegisterInc(BYTE reg,BYTE  data[] , BYTE cnt)
(0090) {
_CYRF_WriteRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B7B: 10       PUSH  X
    0B7C: 4F       MOV   X,SP
(0091) CYRF_WriteRegisterMultiD(CYRF_INCR_BIT| reg,data,cnt);
    0B7D: 52 F9    MOV   A,[X-7]
    0B7F: 08       PUSH  A
    0B80: 52 FA    MOV   A,[X-6]
    0B82: 08       PUSH  A
    0B83: 52 FB    MOV   A,[X-5]
    0B85: 08       PUSH  A
    0B86: 52 FC    MOV   A,[X-4]
    0B88: 29 40    OR    A,0x40
    0B8A: 08       PUSH  A
    0B8B: 9F 93    CALL  _CYRF_WriteRegisterMultiD
    0B8D: 38 FC    ADD   SP,0xFC
    0B8F: 20       POP   X
    0B90: 7F       RET   
(0092) }
(0093) 
(0094) //read a singele register 
(0095) BYTE CYRF_ReadRegister(BYTE reg)
(0096) {
_CYRF_ReadRegister:
  data                 --> X+0
  reg                  --> X-4
    0B91: 10       PUSH  X
    0B92: 4F       MOV   X,SP
    0B93: 38 01    ADD   SP,0x1
(0097) BYTE data;
(0098) 	CYRF_ReadRegisterMulti(reg,&data,1);
    0B95: 50 01    MOV   A,0x1
    0B97: 08       PUSH  A
    0B98: 51 17    MOV   A,[__r0]
    0B9A: 08       PUSH  A
    0B9B: 10       PUSH  X
    0B9C: 52 FC    MOV   A,[X-4]
    0B9E: 08       PUSH  A
    0B9F: 90 08    CALL  _CYRF_ReadRegisterMulti
    0BA1: 38 FC    ADD   SP,0xFC
(0099) 	return data;
    0BA3: 52 00    MOV   A,[X+0]
    0BA5: 38 FF    ADD   SP,0xFF
    0BA7: 20       POP   X
    0BA8: 7F       RET   
(0100) }
(0101) 
(0102) //read a singel register cnt times
(0103) void CYRF_ReadRegisterMulti(BYTE reg, BYTE data[], BYTE cnt)
(0104) {
_CYRF_ReadRegisterMulti:
  n                    --> X+1
  status               --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0BA9: 10       PUSH  X
    0BAA: 4F       MOV   X,SP
    0BAB: 38 02    ADD   SP,0x2
(0105) 	BYTE n;
(0106) 	BYTE status;
(0107)     CS_LO();
    0BAD: 10       PUSH  X
    0BAE: 7C 05 37 LCALL _CS_PIN_Start|CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop
    0BB1: 20       POP   X
(0108) 	//wait for buffer empty
(0109) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BB2: 10       PUSH  X
    0BB3: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0BB6: 20       POP   X
    0BB7: 53 17    MOV   [__r0],A
    0BB9: 47 17 10 TST   [__r0],0x10
    0BBC: AF F5    JZ    0x0BB2
(0110) 	//write address
(0111) 	SPIM_1_SendTxData(reg);
    0BBE: 10       PUSH  X
    0BBF: 52 FC    MOV   A,[X-4]
    0BC1: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0BC4: 20       POP   X
(0112) 	//wait for buffer empty
(0113) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BC5: 10       PUSH  X
    0BC6: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0BC9: 20       POP   X
    0BCA: 21 10    AND   A,0x10
    0BCC: 54 00    MOV   [X+0],A
    0BCE: 39 00    CMP   A,0x0
    0BD0: AF F4    JZ    0x0BC5
(0114)     //dummy write
(0115) 	SPIM_1_SendTxData(0x00);
    0BD2: 10       PUSH  X
    0BD3: 50 00    MOV   A,0x0
    0BD5: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0BD8: 20       POP   X
(0116) 	//wait for gabage byte read
(0117) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0BD9: 10       PUSH  X
    0BDA: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0BDD: 20       POP   X
    0BDE: 21 08    AND   A,0x8
    0BE0: 54 00    MOV   [X+0],A
    0BE2: 39 00    CMP   A,0x0
    0BE4: AF F4    JZ    0x0BD9
(0118) 	SPIM_1_bReadRxData();
    0BE6: 10       PUSH  X
    0BE7: 7C 04 8C LCALL SPIM_1_bReadRxData|_bSPIM_1_ReadRxData|_SPIM_1_bReadRxData|bSPIM_1_ReadRxData
    0BEA: 20       POP   X
(0119) 	
(0120)     
(0121)     for(n=0;(n<cnt);)
    0BEB: 56 01 00 MOV   [X+1],0x0
    0BEE: 80 2E    JMP   0x0C1D
(0122) 	{
(0123) 		//if buffer empty
(0124) 		status=SPIM_1_bReadStatus();
    0BF0: 10       PUSH  X
    0BF1: 7C 04 8F LCALL SPIM_1_bReadStatus|bSPIM_1_ReadStatus|_bSPIM_1_ReadStatus|_SPIM_1_bReadStatus
    0BF4: 20       POP   X
    0BF5: 54 00    MOV   [X+0],A
(0125) 		if(  (status & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BF7: 48 00 10 TST   [X+0],0x10
    0BFA: A0 01    JZ    0x0BFC
(0126) 			{
(0127) 		    //dummy write
(0128) 			SPIM_1_SendTxData(0x00);
    0BFC: 10       PUSH  X
    0BFD: 50 00    MOV   A,0x0
    0BFF: 7C 04 89 LCALL _SPIM_1_Stop|_SPIM_1_SendTxData|SPIM_1_SendTxData
    0C02: 20       POP   X
(0129) 			}
(0130) 		//if data		
(0131) 		if(  (status & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0C03: 48 00 08 TST   [X+0],0x8
    0C06: A0 01    JZ    0x0C08
(0132) 		{
(0133) 			data[n]=SPIM_1_bReadRxData();
    0C08: 10       PUSH  X
    0C09: 7C 04 8C LCALL SPIM_1_bReadRxData|_bSPIM_1_ReadRxData|_SPIM_1_bReadRxData|bSPIM_1_ReadRxData
    0C0C: 20       POP   X
    0C0D: 53 17    MOV   [__r0],A
    0C0F: 52 01    MOV   A,[X+1]
    0C11: 53 14    MOV   [__r3],A
    0C13: 52 FB    MOV   A,[X-5]
    0C15: 04 14    ADD   [__r3],A
    0C17: 51 17    MOV   A,[__r0]
    0C19: 3F 14    MVI   [__r3],A
(0134) 			n++;
    0C1B: 77 01    INC   [X+1]
(0135) 		}
(0136)     };
    0C1D: 52 01    MOV   A,[X+1]
    0C1F: 3B F9    CMP   A,[X-7]
    0C21: CF CE    JC    0x0BF0
(0137) 	CS_HI();
    0C23: 10       PUSH  X
    0C24: 7C 05 33 LCALL _CS_PIN_On
    0C27: 20       POP   X
    0C28: 38 FE    ADD   SP,0xFE
    0C2A: 20       POP   X
    0C2B: 7F       RET   
(0138) }
(0139) void CYRF_ReadRegisterInc(BYTE reg, BYTE data[], BYTE cnt)
(0140) {
_CYRF_ReadRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0C2C: 10       PUSH  X
    0C2D: 4F       MOV   X,SP
(0141) 	CYRF_ReadRegisterMulti(reg|CYRF_INCR_BIT,data,cnt);
    0C2E: 52 F9    MOV   A,[X-7]
    0C30: 08       PUSH  A
    0C31: 52 FA    MOV   A,[X-6]
    0C33: 08       PUSH  A
    0C34: 52 FB    MOV   A,[X-5]
    0C36: 08       PUSH  A
    0C37: 52 FC    MOV   A,[X-4]
    0C39: 29 40    OR    A,0x40
    0C3B: 08       PUSH  A
    0C3C: 9F 6B    CALL  _CYRF_ReadRegisterMulti
    0C3E: 38 FC    ADD   SP,0xFC
    0C40: 20       POP   X
    0C41: 7F       RET   
(0142) }
(0143) 
(0144) 
(0145) //get Mfg ID
(0146) void CYRF_GetMfgData(BYTE data[])
(0147) {
_CYRF_GetMfgData:
  data                 --> X-5
    0C42: 10       PUSH  X
    0C43: 4F       MOV   X,SP
(0148)     /* Fuses power on */
(0149)     CYRF_WriteRegister(CYRF_MFG_ID, 0xFF);
    0C44: 50 FF    MOV   A,0xFF
    0C46: 08       PUSH  A
    0C47: 50 25    MOV   A,0x25
    0C49: 08       PUSH  A
    0C4A: 9E 56    CALL  _CYRF_WriteRegister
    0C4C: 38 FE    ADD   SP,0xFE
(0150) 
(0151)     CYRF_ReadRegisterMulti(CYRF_MFG_ID, data, 6);
    0C4E: 50 06    MOV   A,0x6
    0C50: 08       PUSH  A
    0C51: 52 FB    MOV   A,[X-5]
    0C53: 08       PUSH  A
    0C54: 52 FC    MOV   A,[X-4]
    0C56: 08       PUSH  A
    0C57: 50 25    MOV   A,0x25
    0C59: 08       PUSH  A
    0C5A: 9F 4D    CALL  _CYRF_ReadRegisterMulti
(0152) 
(0153)     /* Fuses power off */
(0154)     CYRF_WriteRegister(CYRF_MFG_ID, 0x00); 
    0C5C: 50 00    MOV   A,0x0
    0C5E: 08       PUSH  A
    0C5F: 50 25    MOV   A,0x25
    0C61: 08       PUSH  A
    0C62: 9E 3E    CALL  _CYRF_WriteRegister
    0C64: 38 FA    ADD   SP,0xFA
    0C66: 20       POP   X
    0C67: 7F       RET   
(0155) }
(0156) 
(0157) void CYRF_SetCRCSeed(WORD crc)
(0158) {
_CYRF_SetCRCSeed:
  crc                  --> X-5
    0C68: 10       PUSH  X
    0C69: 4F       MOV   X,SP
(0159)     CYRF_WriteRegister(CYRF_CRC_SEED_LSB,crc & 0xff);
    0C6A: 52 FC    MOV   A,[X-4]
    0C6C: 08       PUSH  A
    0C6D: 50 15    MOV   A,0x15
    0C6F: 08       PUSH  A
    0C70: 9E 30    CALL  _CYRF_WriteRegister
(0160)     CYRF_WriteRegister(CYRF_CRC_SEED_MSB,crc >> 8);
    0C72: 52 FB    MOV   A,[X-5]
    0C74: 08       PUSH  A
    0C75: 50 16    MOV   A,0x16
    0C77: 08       PUSH  A
    0C78: 9E 28    CALL  _CYRF_WriteRegister
    0C7A: 38 FC    ADD   SP,0xFC
    0C7C: 20       POP   X
    0C7D: 7F       RET   
FILE: .\delay.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: delay.asm
                                        (0004) ;;
                                        (0005) ;;  DESCRIPTION: Delay functions implementation file
                                        (0006) ;;
                                        (0007) ;;-----------------------------------------------------------------------------
                                        (0008) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                        (0009) ;;*****************************************************************************
                                        (0010) ;;*****************************************************************************
                                        (0011) 
                                        (0012) ;-----------------------------------------------------------------------------
                                        (0013) ;  Include Files
                                        (0014) ;-----------------------------------------------------------------------------
                                        (0015) include "m8c.inc"
                                        (0016) include "memory.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------------------------------------
                                        (0021) export  Delay50uTimes
                                        (0022) export _Delay50uTimes
                                        (0023) 
                                        (0024) export  Delay50u
                                        (0025) export _Delay50u
                                        (0026) 
                                        (0027) area text(rom)
                                        (0028) 
                                        (0029) 
                                        (0030) .SECTION
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ;  FUNCTION NAME: Delay50uTimes
                                        (0033) ;
                                        (0034) ;  DESCRIPTION:
                                        (0035) ;     Delay increments of 50uSeconds
                                        (0036) ;
                                        (0037) ;-----------------------------------------------------------------------------
                                        (0038) ;
                                        (0039) ;  ARGUMENTS:
                                        (0040) ;     A contains the delay multiplier
                                        (0041) ;
                                        (0042) ;  RETURNS:
                                        (0043) ;
                                        (0044) ;  SIDE EFFECTS:
                                        (0045) ;    The A and X registers may be modified by this or future implementations
                                        (0046) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0047) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0048) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0049) ;    functions.
                                        (0050) ;
                                        (0051) ;
                                        (0052) 
                                        (0053)  Delay50uTimes:
                                        (0054) _Delay50uTimes:
                                        (0055)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0056) 
0C7E: 90 0C    CALL  _Delay50u          (0057)     call  Delay50u
0C80: 78       DEC   A                  (0058) 	dec A
0C81: BF FC    JNZ   _Delay50uTimes     (0059)     jnz   Delay50uTimes
                                        (0060) 
                                        (0061) 	
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_1
0C83: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) .ENDSECTION
                                        (0066) 
                                        (0067) ;-----------------------------------------------------------------------------
                                        (0068) ;  FUNCTION NAME: Delay50u
                                        (0069) ;
                                        (0070) ;  DESCRIPTION:
                                        (0071) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                        (0072) ;     Slower clock frequencies the delay will be;
                                        (0073) ;           1.5
                                        (0074) ;        -------------- * 50uSec
                                        (0075) ;        clock_freq(MHz)
                                        (0076) ;
                                        (0077) ;
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;
                                        (0080) ;  ARGUMENTS: none
                                        (0081) ;
                                        (0082) ;  RETURNS: none
                                        (0083) ;
                                        (0084) ;  SIDE EFFECTS:
                                        (0085) ;    The A and X registers may be modified by this or future implementations
                                        (0086) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0088) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0089) ;    functions.
                                        (0090) ;
                                        (0091) ;  THEORY of OPERATION or PROCEDURE:
                                        (0092) ;
                                        (0093) .LITERAL
                                        (0094)  Delay50u_Table::
                                        (0095)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                        (0096) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                        (0097) .ENDLITERAL
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)   Delay50u:
                                        (0101)  _Delay50u:                      ; [11]  Call
                                        (0102)     RAM_PROLOGUE RAM_USE_CLASS_1
0C8C: 08       PUSH  A                  (0103)     push  A
0C8D: 71 10    OR    F,0x10             
                                        (0104)     M8C_SetBank1                       ; [4]
0C8F: 5D E0    MOV   A,REG[0xE0]        (0105)     mov   A, reg[OSC_CR0]              ; [6] Get delay value
0C91: 70 EF    AND   F,0xEF             
                                        (0106)     M8C_SetBank0                       ; [4]
0C93: 21 07    AND   A,0x7              (0107)     and   A,07h                        ; [4] Mask off only the clock bits
0C95: 39 05    CMP   A,0x5              (0108)     cmp   A,05h
0C97: D0 06    JNC   0x0C9E             (0109)     jnc   Delay50u_End
0C99: FF E9    INDEX Delay50u_Table     (0110)     index Delay50u_Table               ; [13] Get delay value
                                        (0111) Delay50u_Loop:                         ;
0C9B: 78       DEC   A                  (0112)     dec   A                            ; [4]
0C9C: BF FE    JNZ   0x0C9B             (0113)     jnz   Delay50u_Loop                ; [5]
                                        (0114) Delay50u_End:
0C9E: 18       POP   A                  (0115)     pop   A
                                        (0116)     RAM_EPILOGUE RAM_USE_CLASS_1
0C9F: 7F       RET                      (0117)     ret
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\dsm.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "dsm.h"
(0003) #include "timer.h"
(0004) #include "ppm.h"
(0005) 
(0006) //#define DEBUG
(0007) 
(0008) //share memory with flash buffer
(0009) extern RAM_D mem;
(0010) #define tx_buf mem.b.buf0
(0011) //BYTE tx_buf[16];	//transmit buffer
(0012) #define rx_buf mem.b.buf1
(0013) //BYTE rx_buf[16];	//recive buffer
(0014) //BYTE rx_data[16]; //recived data
(0015) #define rx_data mem.rx_d 
(0016) 
(0017) 
(0018) //global data
(0019) BYTE channels[DSM_CH_CNT]; 	//list of channels
(0020) BYTE chidx;			//current channel index	
(0021) BOOL Ch_A;			//true for channel A false for channel B
(0022) BYTE sop_col;		
(0023) BYTE data_col;		
(0024) BYTE State;		
(0025) BYTE num_channels;	//number fo transmit channels
(0026) config_s config;
(0027) WORD DSM_Perriode;		//cycle time - 4000
(0028) BYTE lost_cnt;
(0029) BOOL New_RCV_Data;
(0030) volatile BOOL new_data;
(0031) volatile BOOL Rcv_Timeout;
(0032) 
(0033) //prototypes
(0034) void DSM_initialize_bind_ack(void);
(0035) void calc_dsmx_channel(void);
(0036) void DSM_StartBindAck(void);
(0037) void DSM_StartRcv(void);
(0038) void Bind_TimeOut_cb(void);
(0039) void Process_BindRcvIrq(void);
(0040) void ProcessNewData(void );
(0041) BYTE DSM_DeterminBitCount(void);
(0042) BOOL DSM_process_Data(void);
(0043) 
(0044) volatile WORD ppm_Data[PPM_PULSE_COUNT];	//the pulse len value for the chanales
(0045) 
(0046) 
(0047) static const BYTE pn_bind[] = {0x98, 0x88, 0x1B, 0xE4, 0x30, 0x79, 0x03, 0x84}; //used for sending bind response
(0048) 
(0049) static const BYTE pncodes[5][9][8] = {
(0050)     /* Note these are in order transmitted (LSB 1st) */
(0051) { /* Row 0 */
(0052)   /* Col 0 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8},
(0053)   /* Col 1 */ {0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6},
(0054)   /* Col 2 */ {0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9},
(0055)   /* Col 3 */ {0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4},
(0056)   /* Col 4 */ {0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0},
(0057)   /* Col 5 */ {0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8},
(0058)   /* Col 6 */ {0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D},
(0059)   /* Col 7 */ {0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1},
(0060)   /* Col 8 */ {0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86}
(0061) },
(0062) { /* Row 1 */
(0063)   /* Col 0 */ {0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3},
(0064)   /* Col 1 */ {0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9},
(0065)   /* Col 2 */ {0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82},
(0066)   /* Col 3 */ {0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB},
(0067)   /* Col 4 */ {0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7},
(0068)   /* Col 5 */ {0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95},
(0069)   /* Col 6 */ {0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4},
(0070)   /* Col 7 */ {0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF},
(0071)   /* Col 8 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97}
(0072) },
(0073) { /* Row 2 */
(0074)   /* Col 0 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97},
(0075)   /* Col 1 */ {0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA},
(0076)   /* Col 2 */ {0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE},
(0077)   /* Col 3 */ {0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD},
(0078)   /* Col 4 */ {0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD},
(0079)   /* Col 5 */ {0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9},
(0080)   /* Col 6 */ {0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3},
(0081)   /* Col 7 */ {0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0},
(0082)   /* Col 8 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E}
(0083) },
(0084) { /* Row 3 */
(0085)   /* Col 0 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E},
(0086)   /* Col 1 */ {0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7},
(0087)   /* Col 2 */ {0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1},
(0088)   /* Col 3 */ {0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4},
(0089)   /* Col 4 */ {0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6},
(0090)   /* Col 5 */ {0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80},
(0091)   /* Col 6 */ {0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88},
(0092)   /* Col 7 */ {0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88},
(0093)   /* Col 8 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93}
(0094) },
(0095) { /* Row 4 */
(0096)   /* Col 0 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93},
(0097)   /* Col 1 */ {0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C},
(0098)   /* Col 2 */ {0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA},
(0099)   /* Col 3 */ {0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC},
(0100)   /* Col 4 */ {0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84},
(0101)   /* Col 5 */ {0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7},
(0102)   /* Col 6 */ {0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0},
(0103)   /* Col 7 */ {0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1},
(0104)   /* Col 8 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8}
(0105) },};
(0106) 
(0107) 
(0108) static const BYTE init_vals[][2] = {
(0109) 	//{CYRF_MODE_OVERRIDE, 0x01}, //we have HW reset
(0110) 	{CYRF_CLK_EN, CLK_EN_RXF},  //0x02
(0111)     {CYRF_AUTO_CAL_TIME, 0x3c}, //see cyrf manual
(0112)     {CYRF_AUTO_CAL_OFFSET, 0x14}, //see cyrf manual
(0113) 	{CYRF_IO_CFG,IO_CFG_IRQ_POL}, //0x40 IRQ active High 
(0114)     {CYRF_RX_CFG, RX_LNA|FAST_TURN_EN}, //0x48 Fast Turn Mode Enable, Low Noise Amplifier ON
(0115)     {CYRF_TX_OFFSET_LSB, 0x55},//see cyrf manual
(0116)     {CYRF_TX_OFFSET_MSB, 0x05},//see cyrf manual
(0117)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END}, //0x24 Force  Idle Mode
(0118) 	{CYRF_DATA64_THOLD, 0x0a},//set pn correlation threshold
(0119)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)}, //0x04 Transaction End State Idle Mode
(0120) 	{CYRF_ANALOG_CTRL, ALL_SLOW}, //0x01 all slow
(0121) };
(0122) 
(0123) 
(0124) static const BYTE rcv_vals[][2] = {
(0125)     {CYRF_TX_CFG,TX_DM(TX_DM_8DR)|DSM_BIND_POWER}, //0xD DDR Mode  32 chip codes
(0126) 	{CYRF_FRAMING_CFG,LEN_EN|SOP_LEN|SOP_EN|0xE},  //0xEE SOP Enable SOP code length is 64 chips Packet Length Enable  SOP Correlator Threshold=0xE
(0127)     {CYRF_TX_OVERRIDE, 0x00},
(0128)     {CYRF_RX_OVERRIDE, 0x00},
(0129) };
(0130) 
(0131) static const BYTE preamble[]={0x04,0x33,0x33};
(0132) static  BYTE tx_cmd[]={0xA,TXE_IRQEN|TXC_IRQEN|TX_GO|TX_CLR}; //0xC3
(0133) 
(0134) void SetChannel(void)
(0135) {
_SetChannel:
  CRCSeed              --> X+2
  pn_row               --> X+1
  channel              --> X+0
    0CA0: 10       PUSH  X
    0CA1: 4F       MOV   X,SP
    0CA2: 38 08    ADD   SP,0x8
(0136) 	BYTE channel=channels[chidx];
    0CA4: 5F 16 4D MOV   [__r1],[chidx]
    0CA7: 06 16 4E ADD   [__r1],0x4E
    0CAA: 3E 16    MVI   A,[__r1]
    0CAC: 54 00    MOV   [X+0],A
(0137) 	BYTE pn_row = DSM_Is_DSMX ? (channel - 2)%5 : channel%5;
    0CAE: 3C 77 00 CMP   [config+4],0x0
    0CB1: A0 27    JZ    0x0CD9
    0CB3: 52 00    MOV   A,[X+0]
    0CB5: 53 16    MOV   [__r1],A
    0CB7: 55 17 00 MOV   [__r0],0x0
    0CBA: 16 16 02 SUB   [__r1],0x2
    0CBD: 1E 17 00 SBB   [__r0],0x0
    0CC0: 50 00    MOV   A,0x0
    0CC2: 08       PUSH  A
    0CC3: 50 05    MOV   A,0x5
    0CC5: 08       PUSH  A
    0CC6: 51 17    MOV   A,[__r0]
    0CC8: 08       PUSH  A
    0CC9: 51 16    MOV   A,[__r1]
    0CCB: 08       PUSH  A
    0CCC: 7C 1E 2A LCALL 0x1E2A
    0CCF: 38 FE    ADD   SP,0xFE
    0CD1: 18       POP   A
    0CD2: 54 05    MOV   [X+5],A
    0CD4: 18       POP   A
    0CD5: 54 04    MOV   [X+4],A
    0CD7: 80 1C    JMP   0x0CF4
    0CD9: 52 00    MOV   A,[X+0]
    0CDB: 53 16    MOV   [__r1],A
    0CDD: 50 00    MOV   A,0x0
    0CDF: 08       PUSH  A
    0CE0: 50 05    MOV   A,0x5
    0CE2: 08       PUSH  A
    0CE3: 50 00    MOV   A,0x0
    0CE5: 08       PUSH  A
    0CE6: 51 16    MOV   A,[__r1]
    0CE8: 08       PUSH  A
    0CE9: 7C 1E 2A LCALL 0x1E2A
    0CEC: 38 FE    ADD   SP,0xFE
    0CEE: 18       POP   A
    0CEF: 54 05    MOV   [X+5],A
    0CF1: 18       POP   A
    0CF2: 54 04    MOV   [X+4],A
    0CF4: 52 05    MOV   A,[X+5]
    0CF6: 54 01    MOV   [X+1],A
(0138) 	WORD CRCSeed=Ch_A?~((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]):((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]);
    0CF8: 3C 4C 00 CMP   [Ch_A],0x0
    0CFB: A0 18    JZ    0x0D14
    0CFD: 7C 1F B3 LCALL 0x1FB3
    0D00: 53 16    MOV   [__r1],A
    0D02: 51 15    MOV   A,[__r2]
    0D04: 0A 17    ADC   A,[__r0]
    0D06: 53 17    MOV   [__r0],A
    0D08: 51 16    MOV   A,[__r1]
    0D0A: 73       CPL   A
    0D0B: 54 07    MOV   [X+7],A
    0D0D: 51 17    MOV   A,[__r0]
    0D0F: 73       CPL   A
    0D10: 54 06    MOV   [X+6],A
    0D12: 80 0C    JMP   0x0D1F
    0D14: 7C 1F B3 LCALL 0x1FB3
    0D17: 54 07    MOV   [X+7],A
    0D19: 51 15    MOV   A,[__r2]
    0D1B: 0A 17    ADC   A,[__r0]
    0D1D: 54 06    MOV   [X+6],A
    0D1F: 52 07    MOV   A,[X+7]
    0D21: 54 03    MOV   [X+3],A
    0D23: 52 06    MOV   A,[X+6]
    0D25: 54 02    MOV   [X+2],A
(0139) 	CYRF_SetRFChannel(channel);
    0D27: 52 00    MOV   A,[X+0]
    0D29: 08       PUSH  A
    0D2A: 50 00    MOV   A,0x0
    0D2C: 08       PUSH  A
    0D2D: 7C 0A A2 LCALL _CYRF_WriteRegister
(0140) 	CYRF_SetCRCSeed(CRCSeed);
    0D30: 52 02    MOV   A,[X+2]
    0D32: 08       PUSH  A
    0D33: 52 03    MOV   A,[X+3]
    0D35: 08       PUSH  A
    0D36: 7C 0C 68 LCALL _CYRF_SetCRCSeed
    0D39: 38 FC    ADD   SP,0xFC
(0141)     CYRF_SetSOPCode(pncodes[pn_row][sop_col]);
    0D3B: 50 08    MOV   A,0x8
    0D3D: 08       PUSH  A
    0D3E: 52 01    MOV   A,[X+1]
    0D40: 53 16    MOV   [__r1],A
    0D42: 50 00    MOV   A,0x0
    0D44: 08       PUSH  A
    0D45: 51 16    MOV   A,[__r1]
    0D47: 08       PUSH  A
    0D48: 50 00    MOV   A,0x0
    0D4A: 08       PUSH  A
    0D4B: 50 48    MOV   A,0x48
    0D4D: 08       PUSH  A
    0D4E: 7C 1F 2D LCALL 0x1F2D
    0D51: 38 FC    ADD   SP,0xFC
    0D53: 5F 16 0B MOV   [__r1],[__rX]
    0D56: 5F 17 0A MOV   [__r0],[__rY]
    0D59: 06 16 78 ADD   [__r1],0x78
    0D5C: 0E 17 01 ADC   [__r0],0x1
    0D5F: 5F 14 4B MOV   [__r3],[sop_col]
    0D62: 55 15 00 MOV   [__r2],0x0
    0D65: 65 14    ASL   [__r3]
    0D67: 6B 15    RLC   [__r2]
    0D69: 65 14    ASL   [__r3]
    0D6B: 6B 15    RLC   [__r2]
    0D6D: 65 14    ASL   [__r3]
    0D6F: 6B 15    RLC   [__r2]
    0D71: 51 14    MOV   A,[__r3]
    0D73: 02 16    ADD   A,[__r1]
    0D75: 53 16    MOV   [__r1],A
    0D77: 51 15    MOV   A,[__r2]
    0D79: 0A 17    ADC   A,[__r0]
    0D7B: 08       PUSH  A
    0D7C: 51 16    MOV   A,[__r1]
    0D7E: 08       PUSH  A
    0D7F: 50 22    MOV   A,0x22
    0D81: 08       PUSH  A
    0D82: 7C 0A BB LCALL _CYRF_WriteRegisterMulti
    0D85: 38 FC    ADD   SP,0xFC
(0142)     CYRF_SetDataCode(pncodes[pn_row][data_col], 16);
    0D87: 50 10    MOV   A,0x10
    0D89: 08       PUSH  A
    0D8A: 52 01    MOV   A,[X+1]
    0D8C: 53 16    MOV   [__r1],A
    0D8E: 50 00    MOV   A,0x0
    0D90: 08       PUSH  A
    0D91: 51 16    MOV   A,[__r1]
    0D93: 08       PUSH  A
    0D94: 50 00    MOV   A,0x0
    0D96: 08       PUSH  A
    0D97: 50 48    MOV   A,0x48
    0D99: 08       PUSH  A
    0D9A: 7C 1F 2D LCALL 0x1F2D
    0D9D: 38 FC    ADD   SP,0xFC
    0D9F: 5F 16 0B MOV   [__r1],[__rX]
    0DA2: 5F 17 0A MOV   [__r0],[__rY]
    0DA5: 06 16 78 ADD   [__r1],0x78
    0DA8: 0E 17 01 ADC   [__r0],0x1
    0DAB: 5F 14 4A MOV   [__r3],[data_col]
    0DAE: 55 15 00 MOV   [__r2],0x0
    0DB1: 65 14    ASL   [__r3]
    0DB3: 6B 15    RLC   [__r2]
    0DB5: 65 14    ASL   [__r3]
    0DB7: 6B 15    RLC   [__r2]
    0DB9: 65 14    ASL   [__r3]
    0DBB: 6B 15    RLC   [__r2]
    0DBD: 51 14    MOV   A,[__r3]
    0DBF: 02 16    ADD   A,[__r1]
    0DC1: 53 16    MOV   [__r1],A
    0DC3: 51 15    MOV   A,[__r2]
    0DC5: 0A 17    ADC   A,[__r0]
    0DC7: 08       PUSH  A
    0DC8: 51 16    MOV   A,[__r1]
    0DCA: 08       PUSH  A
    0DCB: 50 23    MOV   A,0x23
    0DCD: 08       PUSH  A
    0DCE: 7C 0A BB LCALL _CYRF_WriteRegisterMulti
    0DD1: 38 FC    ADD   SP,0xFC
    0DD3: 38 F8    ADD   SP,0xF8
    0DD5: 20       POP   X
    0DD6: 7F       RET   
(0143) }
(0144) 
(0145) //calculate and set channel CRC , SOP and data code 
(0146) void SetCH_INC(void)
(0147) {
_SetCH_INC:
    0DD7: 10       PUSH  X
    0DD8: 4F       MOV   X,SP
    0DD9: 38 04    ADD   SP,0x4
(0148) 	Ch_A=!Ch_A;	
    0DDB: 3C 4C 00 CMP   [Ch_A],0x0
    0DDE: B0 09    JNZ   0x0DE8
    0DE0: 56 01 01 MOV   [X+1],0x1
    0DE3: 56 00 00 MOV   [X+0],0x0
    0DE6: 80 07    JMP   0x0DEE
    0DE8: 56 01 00 MOV   [X+1],0x0
    0DEB: 56 00 00 MOV   [X+0],0x0
    0DEE: 52 01    MOV   A,[X+1]
    0DF0: 53 4C    MOV   [Ch_A],A
(0149) #ifdef DEBUG
(0150) 	CH5_OUT_Switch(Ch_A?1:0);
(0151) #endif
(0152)     if(DSM_Is_DSMX)
    0DF2: 3C 77 00 CMP   [config+4],0x0
    0DF5: A0 17    JZ    0x0E0D
(0153)         chidx = (chidx + 1) % 23;
    0DF7: 51 4D    MOV   A,[chidx]
    0DF9: 01 01    ADD   A,0x1
    0DFB: 53 17    MOV   [__r0],A
    0DFD: 50 17    MOV   A,0x17
    0DFF: 08       PUSH  A
    0E00: 51 17    MOV   A,[__r0]
    0E02: 08       PUSH  A
    0E03: 7C 1E 7F LCALL 0x1E7F
    0E06: 38 FF    ADD   SP,0xFF
    0E08: 18       POP   A
    0E09: 53 4D    MOV   [chidx],A
    0E0B: 80 18    JMP   0x0E24
(0154)     else
(0155)         chidx = Ch_A?0:1;
    0E0D: 3C 4C 00 CMP   [Ch_A],0x0
    0E10: A0 09    JZ    0x0E1A
    0E12: 56 03 00 MOV   [X+3],0x0
    0E15: 56 02 00 MOV   [X+2],0x0
    0E18: 80 07    JMP   0x0E20
    0E1A: 56 03 01 MOV   [X+3],0x1
    0E1D: 56 02 00 MOV   [X+2],0x0
    0E20: 52 03    MOV   A,[X+3]
    0E22: 53 4D    MOV   [chidx],A
(0156) 	SetChannel();
    0E24: 9E 7A    CALL  _SetChannel
    0E26: 38 FC    ADD   SP,0xFC
    0E28: 20       POP   X
    0E29: 7F       RET   
(0157) }
(0158) 
(0159) //load the given config into cyfr6936
(0160) void DSM_Load_Config(const BYTE vals[][2],BYTE cnt)
(0161) {
_DSM_Load_Config:
  n                    --> X+0
  cnt                  --> X-6
  vals                 --> X-5
    0E2A: 10       PUSH  X
    0E2B: 4F       MOV   X,SP
    0E2C: 38 01    ADD   SP,0x1
(0162) BYTE n;
(0163) 
(0164) for(n=0;n<cnt;n++)
    0E2E: 56 00 00 MOV   [X+0],0x0
    0E31: 80 2B    JMP   0x0E5D
(0165) 	{
(0166) 	CYRF_WriteRegister(vals[n][0],vals[n][1]);
    0E33: 7C 1F 9B LCALL <created procedures>
    0E36: 52 FC    MOV   A,[X-4]
    0E38: 04 16    ADD   [__r1],A
    0E3A: 52 FB    MOV   A,[X-5]
    0E3C: 0C 17    ADC   [__r0],A
    0E3E: 51 16    MOV   A,[__r1]
    0E40: 01 01    ADD   A,0x1
    0E42: 53 14    MOV   [__r3],A
    0E44: 51 17    MOV   A,[__r0]
    0E46: 09 00    ADC   A,0x0
    0E48: 10       PUSH  X
    0E49: 58 14    MOV   X,[__r3]
    0E4B: 28       ROMX  
    0E4C: 20       POP   X
    0E4D: 08       PUSH  A
    0E4E: 51 17    MOV   A,[__r0]
    0E50: 10       PUSH  X
    0E51: 58 16    MOV   X,[__r1]
    0E53: 28       ROMX  
    0E54: 20       POP   X
    0E55: 08       PUSH  A
    0E56: 7C 0A A2 LCALL _CYRF_WriteRegister
    0E59: 38 FE    ADD   SP,0xFE
(0167) 	}
    0E5B: 77 00    INC   [X+0]
    0E5D: 52 00    MOV   A,[X+0]
    0E5F: 3B FA    CMP   A,[X-6]
    0E61: CF D1    JC    0x0E33
    0E63: 38 FF    ADD   SP,0xFF
    0E65: 20       POP   X
    0E66: 7F       RET   
(0168) }
(0169) 
(0170) 
(0171) //clear recive error and pending interupt flags
(0172) void DSM_ClearRxError(void)
(0173) {
_DSM_ClearRxError:
  i                    --> X+0
    0E67: 10       PUSH  X
    0E68: 4F       MOV   X,SP
    0E69: 38 01    ADD   SP,0x1
(0174) 	BYTE i=100;
    0E6B: 56 00 64 MOV   [X+0],0x64
(0175) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    0E6E: 50 07    MOV   A,0x7
    0E70: 08       PUSH  A
    0E71: 7C 0B 91 LCALL _CYRF_ReadRegister
(0176) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    0E74: 50 07    MOV   A,0x7
    0E76: 08       PUSH  A
    0E77: 7C 0B 91 LCALL _CYRF_ReadRegister
    0E7A: 38 FE    ADD   SP,0xFE
(0177) 	CYRF_WriteRegister(CYRF_RX_ABORT,ABORT_EN); //abort
    0E7C: 50 20    MOV   A,0x20
    0E7E: 08       PUSH  A
    0E7F: 50 29    MOV   A,0x29
    0E81: 08       PUSH  A
    0E82: 7C 0A A2 LCALL _CYRF_WriteRegister
(0178) 	//force end state
(0179) 	CYRF_WriteRegister(CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END);
    0E85: 50 24    MOV   A,0x24
    0E87: 08       PUSH  A
    0E88: 50 0F    MOV   A,0xF
    0E8A: 08       PUSH  A
    0E8B: 7C 0A A2 LCALL _CYRF_WriteRegister
    0E8E: 38 FC    ADD   SP,0xFC
    0E90: 80 0A    JMP   0x0E9B
(0180)     while (! (CYRF_ReadRegister(CYRF_XACT_CFG) & CYRF_XACT_END_STATE(CYRF_MODE_IDLE))) 
(0181) 	{
(0182)         if(!--i)
    0E92: 17 00 01 SUB   [X+0],0x1
    0E95: 52 00    MOV   A,[X+0]
    0E97: B0 03    JNZ   0x0E9B
(0183)             break;
    0E99: 80 10    JMP   0x0EAA
(0184) 	}
    0E9B: 50 0F    MOV   A,0xF
    0E9D: 08       PUSH  A
    0E9E: 7C 0B 91 LCALL _CYRF_ReadRegister
    0EA1: 38 FF    ADD   SP,0xFF
    0EA3: 53 17    MOV   [__r0],A
    0EA5: 47 17 04 TST   [__r0],0x4
    0EA8: AF E9    JZ    0x0E92
(0185) 	//clear abort
(0186) 	CYRF_WriteRegister(CYRF_RX_ABORT,0);
    0EAA: 50 00    MOV   A,0x0
    0EAC: 08       PUSH  A
    0EAD: 50 29    MOV   A,0x29
    0EAF: 08       PUSH  A
    0EB0: 7C 0A A2 LCALL _CYRF_WriteRegister
    0EB3: 38 FE    ADD   SP,0xFE
    0EB5: 38 FF    ADD   SP,0xFF
    0EB7: 20       POP   X
    0EB8: 7F       RET   
(0187) }
(0188) void SYNC_AB_TimeOut_cb(void)
(0189) {
(0190) 	DSM_ClearRxError();
_SYNC_AB_TimeOut_cb:
    0EB9: 9F AC    CALL  _DSM_ClearRxError
(0191) #ifdef DEBUG
(0192) 	CH2_OUT_Invert();
(0193) #endif
(0194) 	channels[chidx]++;
    0EBB: 5F 16 4D MOV   [__r1],[chidx]
    0EBE: 06 16 4E ADD   [__r1],0x4E
    0EC1: 3E 16    MVI   A,[__r1]
    0EC3: 7A 16    DEC   [__r1]
    0EC5: 01 01    ADD   A,0x1
    0EC7: 3F 16    MVI   [__r1],A
(0195) 	if(channels[chidx]>DSM_MAX_CH)
    0EC9: 5F 16 4D MOV   [__r1],[chidx]
    0ECC: 06 16 4E ADD   [__r1],0x4E
    0ECF: 3E 16    MVI   A,[__r1]
    0ED1: 53 17    MOV   [__r0],A
    0ED3: 50 4F    MOV   A,0x4F
    0ED5: 3A 17    CMP   A,[__r0]
    0ED7: D0 0B    JNC   0x0EE3
(0196) 		channels[chidx]=0;	
    0ED9: 5F 16 4D MOV   [__r1],[chidx]
    0EDC: 06 16 4E ADD   [__r1],0x4E
    0EDF: 50 00    MOV   A,0x0
    0EE1: 3F 16    MVI   [__r1],A
(0197) 	SetChannel();
    0EE3: 9D BB    CALL  _SetChannel
(0198) 	DSM_StartRcv();	
    0EE5: 97 28    CALL  _DSM_StartRcv
    0EE7: 7F       RET   
(0199) }
(0200) 
(0201) static cnt=0;
(0202) void SYNC_X_TimeOut_cb(void)
(0203) {
(0204) 	if (cnt==0)
_SYNC_X_TimeOut_cb:
    0EE8: 3C 02 00 CMP   [dsm.c:cnt|value|cnt],0x0
    0EEB: B0 0C    JNZ   0x0EF8
    0EED: 3C 03 00 CMP   [dsm.c:cnt|value|cnt+1],0x0
    0EF0: B0 07    JNZ   0x0EF8
(0205) 	{
(0206) 		DSM_ClearRxError();
    0EF2: 9F 73    CALL  _DSM_ClearRxError
(0207) 		SetCH_INC();
    0EF4: 9E E1    CALL  _SetCH_INC
(0208) 		DSM_StartRcv();	
    0EF6: 97 17    CALL  _DSM_StartRcv
(0209) 	}
(0210) 	Rcv_Timeout=TRUE;
    0EF8: 55 89 01 MOV   [Rcv_Timeout],0x1
(0211) 	cnt=(cnt+1)%4;
    0EFB: 51 03    MOV   A,[dsm.c:cnt|value|cnt+1]
    0EFD: 01 01    ADD   A,0x1
    0EFF: 53 16    MOV   [__r1],A
    0F01: 51 02    MOV   A,[dsm.c:cnt|value|cnt]
    0F03: 09 00    ADC   A,0x0
    0F05: 53 17    MOV   [__r0],A
    0F07: 50 00    MOV   A,0x0
    0F09: 08       PUSH  A
    0F0A: 50 04    MOV   A,0x4
    0F0C: 08       PUSH  A
    0F0D: 51 17    MOV   A,[__r0]
    0F0F: 08       PUSH  A
    0F10: 51 16    MOV   A,[__r1]
    0F12: 08       PUSH  A
    0F13: 7C 1E 2A LCALL 0x1E2A
    0F16: 38 FE    ADD   SP,0xFE
    0F18: 18       POP   A
    0F19: 53 03    MOV   [dsm.c:cnt|value|cnt+1],A
    0F1B: 18       POP   A
    0F1C: 53 02    MOV   [dsm.c:cnt|value|cnt],A
(0212) 	if (!DSM_Is_DSMX)
    0F1E: 3C 77 00 CMP   [config+4],0x0
    0F21: B0 2F    JNZ   0x0F51
(0213) 	{
(0214) 		if (lost_cnt++>30)
    0F23: 5F 16 48 MOV   [__r1],[lost_cnt]
    0F26: 55 17 00 MOV   [__r0],0x0
    0F29: 51 16    MOV   A,[__r1]
    0F2B: 01 01    ADD   A,0x1
    0F2D: 53 48    MOV   [lost_cnt],A
    0F2F: 50 1E    MOV   A,0x1E
    0F31: 12 16    SUB   A,[__r1]
    0F33: 50 00    MOV   A,0x0
    0F35: 31 80    XOR   A,0x80
    0F37: 53 0B    MOV   [__rX],A
    0F39: 50 80    MOV   A,0x80
    0F3B: 1A 0B    SBB   A,[__rX]
    0F3D: D0 13    JNC   0x0F51
(0215) 		{
(0216) 			Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);
    0F3F: 10       PUSH  X
    0F40: 50 56    MOV   A,0x56
    0F42: 7C 04 81 LCALL _Timer8_1_WritePeriod
    0F45: 20       POP   X
(0217) 			Timer_SetCallback(SYNC_AB_TimeOut_cb);
    0F46: 50 03    MOV   A,0x3
    0F48: 08       PUSH  A
    0F49: 50 1E    MOV   A,0x1E
    0F4B: 08       PUSH  A
    0F4C: 7C 1D 93 LCALL _Timer_SetCallback
    0F4F: 38 FE    ADD   SP,0xFE
(0218) 		}
(0219) 	}
    0F51: 7F       RET   
(0220) #ifdef DEBUG
(0221) 	CH2_OUT_Invert();
(0222) #endif
(0223) }
(0224) 
(0225) void DSM_Set_SyncX_State(void )
(0226) {
(0227) 		State=DSM_STATE_SYNC_X;
_DSM_Set_SyncX_State:
    0F52: 55 8B 0A MOV   [State],0xA
(0228) #ifdef DEBUG
(0229) 		CH0_OUT_Off();
(0230) #endif
(0231) 		lost_cnt=0;
    0F55: 55 48 00 MOV   [lost_cnt],0x0
(0232) 		Rcv_Timeout=FALSE;
    0F58: 55 89 00 MOV   [Rcv_Timeout],0x0
(0233) 		if (DSM_Is_DSMX)
    0F5B: 3C 77 00 CMP   [config+4],0x0
    0F5E: A0 0A    JZ    0x0F69
(0234) 			Timer_SetPeriod(DSM_FULL_SEQUENCE_TIME);
    0F60: 10       PUSH  X
    0F61: 50 55    MOV   A,0x55
    0F63: 7C 04 81 LCALL _Timer8_1_WritePeriod
    0F66: 20       POP   X
    0F67: 80 08    JMP   0x0F70
(0235) 		else
(0236) 			Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);
    0F69: 10       PUSH  X
    0F6A: 50 56    MOV   A,0x56
    0F6C: 7C 04 81 LCALL _Timer8_1_WritePeriod
    0F6F: 20       POP   X
(0237) 		Timer_SetCallback(SYNC_X_TimeOut_cb);
    0F70: 50 03    MOV   A,0x3
    0F72: 08       PUSH  A
    0F73: 50 1C    MOV   A,0x1C
    0F75: 08       PUSH  A
    0F76: 7C 1D 93 LCALL _Timer_SetCallback
    0F79: 38 FE    ADD   SP,0xFE
    0F7B: 7F       RET   
(0238) }
(0239) 
(0240) void Rcv_X_TimeOut_cb(void)
(0241) {
(0242) 	Timer_Stop();
_Rcv_X_TimeOut_cb:
    0F7C: 10       PUSH  X
    0F7D: 7C 04 7D LCALL _Timer8_1_Stop
    0F80: 20       POP   X
(0243) 	if(Ch_A)
    0F81: 3C 4C 00 CMP   [Ch_A],0x0
    0F84: A0 0A    JZ    0x0F8F
(0244) 		{
(0245) 		Timer_SetPeriod(DSM_TIME_CHA_CHB);
    0F86: 10       PUSH  X
    0F87: 50 0F    MOV   A,0xF
    0F89: 7C 04 81 LCALL _Timer8_1_WritePeriod
    0F8C: 20       POP   X
(0246) 		}
    0F8D: 80 0B    JMP   0x0F99
(0247) 	else
(0248) 		{
(0249) 		Timer_SetPeriod(DSM_Perriode);
    0F8F: 5F 17 8D MOV   [__r0],[DSM_Perriode+1]
    0F92: 10       PUSH  X
    0F93: 51 17    MOV   A,[__r0]
    0F95: 7C 04 81 LCALL _Timer8_1_WritePeriod
    0F98: 20       POP   X
(0250) 		}
(0251) 	if(lost_cnt++>DSM_CH_CNT/2 && !Ch_A)
    0F99: 5F 16 48 MOV   [__r1],[lost_cnt]
    0F9C: 55 17 00 MOV   [__r0],0x0
    0F9F: 51 16    MOV   A,[__r1]
    0FA1: 01 01    ADD   A,0x1
    0FA3: 53 48    MOV   [lost_cnt],A
    0FA5: 50 0B    MOV   A,0xB
    0FA7: 12 16    SUB   A,[__r1]
    0FA9: 50 00    MOV   A,0x0
    0FAB: 31 80    XOR   A,0x80
    0FAD: 53 0B    MOV   [__rX],A
    0FAF: 50 80    MOV   A,0x80
    0FB1: 1A 0B    SBB   A,[__rX]
    0FB3: D0 08    JNC   0x0FBC
    0FB5: 3C 4C 00 CMP   [Ch_A],0x0
    0FB8: B0 03    JNZ   0x0FBC
(0252) 		{
(0253) 		DSM_Set_SyncX_State();
    0FBA: 9F 96    CALL  _DSM_Set_SyncX_State
(0254) 		}
(0255) 	Timer_Start();
    0FBC: 10       PUSH  X
    0FBD: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    0FC0: 20       POP   X
(0256) 	DSM_ClearRxError();
    0FC1: 9E A4    CALL  _DSM_ClearRxError
(0257) 	SetCH_INC();
    0FC3: 9E 12    CALL  _SetCH_INC
(0258) 	DSM_StartRcv();	
    0FC5: 96 48    CALL  _DSM_StartRcv
(0259) 	New_RCV_Data=TRUE;
    0FC7: 55 47 01 MOV   [New_RCV_Data],0x1
    0FCA: 7F       RET   
(0260) #ifdef DEBUG
(0261) 	CH2_OUT_Invert();
(0262) #endif
(0263) }
(0264) 
(0265) void DSM_initialize_Recive(void)
(0266) {
_DSM_initialize_Recive:
    0FCB: 10       PUSH  X
    0FCC: 4F       MOV   X,SP
    0FCD: 38 02    ADD   SP,0x2
(0267) 	chidx=0;
    0FCF: 55 4D 00 MOV   [chidx],0x0
(0268) 	Ch_A=TRUE;
    0FD2: 55 4C 01 MOV   [Ch_A],0x1
(0269) 	Rcv_Timeout=FALSE;
    0FD5: 55 89 00 MOV   [Rcv_Timeout],0x0
(0270) 	New_RCV_Data=FALSE;
    0FD8: 55 47 00 MOV   [New_RCV_Data],0x0
(0271) 	lost_cnt=0;
    0FDB: 55 48 00 MOV   [lost_cnt],0x0
(0272) 	sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
    0FDE: 51 73    MOV   A,[config]
    0FE0: 02 74    ADD   A,[config+1]
    0FE2: 53 17    MOV   [__r0],A
    0FE4: 51 75    MOV   A,[config+2]
    0FE6: 04 17    ADD   [__r0],A
    0FE8: 06 17 02 ADD   [__r0],0x2
    0FEB: 51 17    MOV   A,[__r0]
    0FED: 21 07    AND   A,0x7
    0FEF: 53 4B    MOV   [sop_col],A
(0273)     data_col = 7 - sop_col;
    0FF1: 50 07    MOV   A,0x7
    0FF3: 12 4B    SUB   A,[sop_col]
    0FF5: 53 4A    MOV   [data_col],A
(0274) 	DSM_Load_Config(rcv_vals,sizeof(rcv_vals)/(sizeof(BYTE)*2));
    0FF7: 50 04    MOV   A,0x4
    0FF9: 08       PUSH  A
    0FFA: 50 02    MOV   A,0x2
    0FFC: 08       PUSH  A
    0FFD: 50 F6    MOV   A,0xF6
    0FFF: 08       PUSH  A
    1000: 9E 28    CALL  _DSM_Load_Config
    1002: 38 FD    ADD   SP,0xFD
(0275) 	if(DSM_Is_DSMX)
    1004: 3C 77 00 CMP   [config+4],0x0
    1007: A0 08    JZ    0x1010
(0276) 		{
(0277) 		calc_dsmx_channel();	
    1009: 92 74    CALL  _calc_dsmx_channel
(0278) 		State=DSM_STATE_SYNC_X;
    100B: 55 8B 0A MOV   [State],0xA
(0279) 		}
    100E: 80 0A    JMP   0x1019
(0280) 	else
(0281) 		{
(0282) 		channels[0]=channels[1]=1;	
    1010: 55 4F 01 MOV   [channels+1],0x1
    1013: 55 4E 01 MOV   [channels],0x1
(0283) 		State=DSM_STATE_SYNC_AB;
    1016: 55 8B 06 MOV   [State],0x6
(0284) 		}	
(0285) 	//set periode to be 11ms or 22ms	
(0286) 	DSM_Perriode=DSM_Is_11ms?DSM_TIME11MS:DSM_TIME22MS;
    1019: 3C 78 00 CMP   [config+5],0x0
    101C: A0 09    JZ    0x1026
    101E: 56 01 1B MOV   [X+1],0x1B
    1021: 56 00 00 MOV   [X+0],0x0
    1024: 80 07    JMP   0x102C
    1026: 56 01 46 MOV   [X+1],0x46
    1029: 56 00 00 MOV   [X+0],0x0
    102C: 52 01    MOV   A,[X+1]
    102E: 53 8D    MOV   [DSM_Perriode+1],A
    1030: 52 00    MOV   A,[X+0]
    1032: 53 8C    MOV   [DSM_Perriode],A
(0287) 
(0288) 	//calculate channel CRC SOP and data code for first channel to transmitt
(0289) 	Timer_Stop();
    1034: 10       PUSH  X
    1035: 7C 04 7D LCALL _Timer8_1_Stop
    1038: 20       POP   X
(0290) 	if(DSM_Is_DSMX)
    1039: 3C 77 00 CMP   [config+4],0x0
    103C: A0 15    JZ    0x1052
(0291) 		{	
(0292) 			Timer_SetPeriod(DSM_FULL_SEQUENCE_TIME);
    103E: 10       PUSH  X
    103F: 50 55    MOV   A,0x55
    1041: 7C 04 81 LCALL _Timer8_1_WritePeriod
    1044: 20       POP   X
(0293) 			Timer_SetCallback(SYNC_X_TimeOut_cb);
    1045: 50 03    MOV   A,0x3
    1047: 08       PUSH  A
    1048: 50 1C    MOV   A,0x1C
    104A: 08       PUSH  A
    104B: 7C 1D 93 LCALL _Timer_SetCallback
    104E: 38 FE    ADD   SP,0xFE
(0294) 		}
    1050: 80 13    JMP   0x1064
(0295) 	else 
(0296) 		{
(0297) 			Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);
    1052: 10       PUSH  X
    1053: 50 56    MOV   A,0x56
    1055: 7C 04 81 LCALL _Timer8_1_WritePeriod
    1058: 20       POP   X
(0298) 			Timer_SetCallback(SYNC_AB_TimeOut_cb);
    1059: 50 03    MOV   A,0x3
    105B: 08       PUSH  A
    105C: 50 1E    MOV   A,0x1E
    105E: 08       PUSH  A
    105F: 7C 1D 93 LCALL _Timer_SetCallback
    1062: 38 FE    ADD   SP,0xFE
(0299) 		}
(0300) 	SetChannel();
    1064: 9C 3A    CALL  _SetChannel
(0301) 	Timer_Start();
    1066: 10       PUSH  X
    1067: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    106A: 20       POP   X
(0302) 	DSM_StartRcv();	
    106B: 95 A2    CALL  _DSM_StartRcv
    106D: 38 FE    ADD   SP,0xFE
    106F: 20       POP   X
    1070: 7F       RET   
(0303) }
(0304) 
(0305) void Process_Rvc_Irq(void)
(0306) {
_Process_Rvc_Irq:
  n                    --> X+0
    1071: 10       PUSH  X
    1072: 4F       MOV   X,SP
    1073: 38 01    ADD   SP,0x1
(0307) 	BYTE n;
(0308) 	if ((( DSM_Is_DSMX) && (rx_buf[0] !=  cyrfmfg_id[2] || rx_buf[1] !=  cyrfmfg_id[3]))
    1075: 3C 77 00 CMP   [config+4],0x0
    1078: A0 0D    JZ    0x1086
    107A: 51 30    MOV   A,[mem+16]
    107C: 3A 75    CMP   A,[config+2]
    107E: B0 22    JNZ   0x10A1
    1080: 51 31    MOV   A,[mem+17]
    1082: 3A 76    CMP   A,[config+3]
    1084: B0 1C    JNZ   0x10A1
    1086: 3C 77 00 CMP   [config+4],0x0
    1089: B0 19    JNZ   0x10A3
    108B: 51 75    MOV   A,[config+2]
    108D: 73       CPL   A
    108E: 53 17    MOV   [__r0],A
    1090: 51 30    MOV   A,[mem+16]
    1092: 3A 17    CMP   A,[__r0]
    1094: B0 0C    JNZ   0x10A1
    1096: 51 76    MOV   A,[config+3]
    1098: 73       CPL   A
    1099: 53 17    MOV   [__r0],A
    109B: 51 31    MOV   A,[mem+17]
    109D: 3A 17    CMP   A,[__r0]
    109F: A0 03    JZ    0x10A3
(0309) 	  ||((!DSM_Is_DSMX) && (rx_buf[0] != ~cyrfmfg_id[2] || rx_buf[1] != ~cyrfmfg_id[3]))) 
(0310) 	{
(0311) 		goto Rvc_Error;
    10A1: 80 77    JMP   0x1119
(0312) 	}
(0313) #ifdef DEBUG
(0314) 	CH4_OUT_Invert();
(0315) #endif
(0316) 	Timer_Stop();
    10A3: 10       PUSH  X
    10A4: 7C 04 7D LCALL _Timer8_1_Stop
    10A7: 20       POP   X
(0317) 	if(Ch_A)
    10A8: 3C 4C 00 CMP   [Ch_A],0x0
    10AB: A0 0A    JZ    0x10B6
(0318) 		{
(0319) 		Timer_SetPeriod(DSM_TIME_CHA_CHB+DSM_TIME_EXTRA);
    10AD: 10       PUSH  X
    10AE: 50 10    MOV   A,0x10
    10B0: 7C 04 81 LCALL _Timer8_1_WritePeriod
    10B3: 20       POP   X
(0320) 		}
    10B4: 80 0A    JMP   0x10BF
(0321) 	else
(0322) 		{
(0323) 		Timer_SetPeriod(DSM_Perriode+DSM_TIME_EXTRA);
    10B6: 51 8D    MOV   A,[DSM_Perriode+1]
    10B8: 01 01    ADD   A,0x1
    10BA: 10       PUSH  X
    10BB: 7C 04 81 LCALL _Timer8_1_WritePeriod
    10BE: 20       POP   X
(0324) 		}
(0325) 
(0326) 	if (State==DSM_STATE_SYNC_AB)
    10BF: 3C 8B 06 CMP   [State],0x6
    10C2: B0 16    JNZ   0x10D9
(0327) 	{
(0328) 		if (chidx==1  && channels[0]!=channels[1])
    10C4: 3C 4D 01 CMP   [chidx],0x1
    10C7: B0 0A    JNZ   0x10D2
    10C9: 51 4E    MOV   A,[channels]
    10CB: 3A 4F    CMP   A,[channels+1]
    10CD: A0 04    JZ    0x10D2
(0329) 		{
(0330) 			State =DSM_STATE_SYNC_X;
    10CF: 55 8B 0A MOV   [State],0xA
(0331) 		}
(0332) 	Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);	
    10D2: 10       PUSH  X
    10D3: 50 56    MOV   A,0x56
    10D5: 7C 04 81 LCALL _Timer8_1_WritePeriod
    10D8: 20       POP   X
(0333) 	}
(0334) 
(0335) 	Timer_Start();
    10D9: 10       PUSH  X
    10DA: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    10DD: 20       POP   X
(0336) 
(0337) 	if (DSM_STATE_SYNC_X==State)
    10DE: 3C 8B 0A CMP   [State],0xA
    10E1: B0 0F    JNZ   0x10F1
(0338) 	{
(0339) 		State=DSM_STATE_LOCKED;
    10E3: 55 8B 0B MOV   [State],0xB
(0340) #ifdef DEBUG
(0341) 		CH0_OUT_On(); 
(0342) #endif
(0343) 		Timer_SetCallback(Rcv_X_TimeOut_cb);
    10E6: 50 03    MOV   A,0x3
    10E8: 08       PUSH  A
    10E9: 50 1A    MOV   A,0x1A
    10EB: 08       PUSH  A
    10EC: 7C 1D 93 LCALL _Timer_SetCallback
    10EF: 38 FE    ADD   SP,0xFE
(0344) 	}
(0345) 
(0346) 	SetCH_INC();
    10F1: 9C E4    CALL  _SetCH_INC
(0347) 		
(0348) 	//process data
(0349) 	for (n=2;n<0x10;n++)
    10F3: 56 00 02 MOV   [X+0],0x2
    10F6: 80 17    JMP   0x110E
(0350) 		rx_data[n]=rx_buf[n];
    10F8: 52 00    MOV   A,[X+0]
    10FA: 01 30    ADD   A,0x30
    10FC: 53 16    MOV   [__r1],A
    10FE: 3E 16    MVI   A,[__r1]
    1100: 53 17    MOV   [__r0],A
    1102: 52 00    MOV   A,[X+0]
    1104: 01 20    ADD   A,0x20
    1106: 53 14    MOV   [__r3],A
    1108: 51 17    MOV   A,[__r0]
    110A: 3F 14    MVI   [__r3],A
    110C: 77 00    INC   [X+0]
    110E: 3D 00 10 CMP   [X+0],0x10
    1111: CF E6    JC    0x10F8
(0351) 	//rx_data[0]=DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01);
(0352) 	//rx_data[1]=0;
(0353) 	New_RCV_Data=TRUE;
    1113: 55 47 01 MOV   [New_RCV_Data],0x1
(0354) 	lost_cnt=0;
    1116: 55 48 00 MOV   [lost_cnt],0x0
(0355) 	
(0356) Rvc_Error:
(0357) 	DSM_StartRcv();
    1119: 94 F4    CALL  _DSM_StartRcv
    111B: 38 FF    ADD   SP,0xFF
    111D: 20       POP   X
    111E: 7F       RET   
(0358) }
(0359) 
(0360) 
(0361) 	
(0362) BOOL ProcessRxIrqStatus(void)
(0363) {
_ProcessRxIrqStatus:
  Est                  --> X+2
  rx_cnt               --> X+2
  Irq_Status           --> X+0
    111F: 10       PUSH  X
    1120: 4F       MOV   X,SP
    1121: 38 03    ADD   SP,0x3
(0364) 		BYTE Irq_Status[2];
(0365) 		//read IRQ status
(0366) 		CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
    1123: 50 02    MOV   A,0x2
    1125: 08       PUSH  A
    1126: 51 17    MOV   A,[__r0]
    1128: 08       PUSH  A
    1129: 10       PUSH  X
    112A: 50 07    MOV   A,0x7
    112C: 08       PUSH  A
    112D: 7C 0B A9 LCALL _CYRF_ReadRegisterMulti
    1130: 38 FC    ADD   SP,0xFC
(0367) 		Irq_Status[0]|=Irq_Status[1]&RXE_IRQ;
    1132: 52 01    MOV   A,[X+1]
    1134: 21 01    AND   A,0x1
    1136: 2D 00    OR    [X+0],A
(0368) 		if(Irq_Status[0]&RXC_IRQ)
    1138: 48 00 02 TST   [X+0],0x2
    113B: A0 23    JZ    0x115F
(0369) 		{
(0370) 			BYTE rx_cnt=CYRF_Rx_cnt();
    113D: 50 09    MOV   A,0x9
    113F: 08       PUSH  A
    1140: 7C 0B 91 LCALL _CYRF_ReadRegister
    1143: 54 02    MOV   [X+2],A
(0371) 			CYRF_ReadRx_data(rx_buf,rx_cnt);
    1145: 52 02    MOV   A,[X+2]
    1147: 08       PUSH  A
    1148: 50 00    MOV   A,0x0
    114A: 08       PUSH  A
    114B: 50 30    MOV   A,0x30
    114D: 08       PUSH  A
    114E: 50 21    MOV   A,0x21
    1150: 08       PUSH  A
    1151: 7C 0B A9 LCALL _CYRF_ReadRegisterMulti
    1154: 38 FB    ADD   SP,0xFB
(0372) 			if(rx_cnt!=0x10)
    1156: 3D 02 10 CMP   [X+2],0x10
    1159: A0 05    JZ    0x115F
(0373) 			{
(0374) 				return FALSE;
    115B: 50 00    MOV   A,0x0
    115D: 80 16    JMP   0x1174
(0375) 			}
(0376) 		}
(0377) 		if (Irq_Status[0]&RXE_IRQ)
    115F: 48 00 01 TST   [X+0],0x1
    1162: A0 0F    JZ    0x1172
(0378) 		{
(0379) 			BYTE Est=CYRF_ReadRegister(CYRF_RX_STATUS);
    1164: 50 08    MOV   A,0x8
    1166: 08       PUSH  A
    1167: 7C 0B 91 LCALL _CYRF_ReadRegister
    116A: 38 FF    ADD   SP,0xFF
    116C: 54 02    MOV   [X+2],A
(0380) 			return FALSE;
    116E: 50 00    MOV   A,0x0
    1170: 80 03    JMP   0x1174
(0381) 		}
(0382) return TRUE;
    1172: 50 01    MOV   A,0x1
    1174: 38 FD    ADD   SP,0xFD
    1176: 20       POP   X
    1177: 7F       RET   
(0383) }
(0384) 
(0385) void ProcessNewData(void )
(0386) {
(0387) 		new_data= DSM_process_Data();
_ProcessNewData:
    1178: 96 D3    CALL  _DSM_process_Data
    117A: 53 8A    MOV   [new_data],A
    117C: 7F       RET   
(0388) }
(0389) 
(0390) 
(0391) void DSM_Cyclic(void)
(0392) {
_DSM_Cyclic:
  Irq_Status           --> X+2
    117D: 10       PUSH  X
    117E: 4F       MOV   X,SP
    117F: 38 06    ADD   SP,0x6
(0393) 	switch(State)
    1181: 51 8B    MOV   A,[State]
    1183: 54 01    MOV   [X+1],A
    1185: 56 00 00 MOV   [X+0],0x0
    1188: 3D 00 00 CMP   [X+0],0x0
    118B: B0 06    JNZ   0x1192
    118D: 3D 01 00 CMP   [X+1],0x0
    1190: A0 17    JZ    0x11A8
    1192: 3D 00 00 CMP   [X+0],0x0
    1195: B0 06    JNZ   0x119C
    1197: 3D 01 03 CMP   [X+1],0x3
    119A: A0 1A    JZ    0x11B5
    119C: 3D 00 00 CMP   [X+0],0x0
    119F: B0 06    JNZ   0x11A6
    11A1: 3D 01 05 CMP   [X+1],0x5
    11A4: A0 0C    JZ    0x11B1
    11A6: 80 12    JMP   0x11B9
(0394) 	{
(0395) 		case DSM_STATE_BIND:
(0396) 			{
(0397) 			DSM_ClearRxError();
    11A8: 9C BD    CALL  _DSM_ClearRxError
(0398) 			DSM_StartRcv();
    11AA: 94 63    CALL  _DSM_StartRcv
(0399) 			State=DSM_STATE_BIND_RCV;
    11AC: 55 8B 01 MOV   [State],0x1
(0400) 			}
(0401) 		break;
    11AF: 80 09    JMP   0x11B9
(0402) 		case DSM_STATE_BIND_DONE:
(0403) 			{
(0404) 				DSM_initialize_Recive();
    11B1: 9E 18    CALL  _DSM_initialize_Recive
(0405) 			}
(0406) 		break;
    11B3: 80 05    JMP   0x11B9
(0407) 		case DSM_STATE_BIND_RCV_START_ACK:
(0408) 			{
(0409) 			DSM_initialize_bind_ack();
    11B5: 94 C5    CALL  _DSM_initialize_bind_ack
(0410) 			DSM_StartBindAck();
    11B7: 94 68    CALL  _DSM_StartBindAck
(0411) 			}
(0412) 	}
(0413) 
(0414) 	//process interrupt
(0415) 	if(CY_irq) //we got an IRQ from CYRF6936
    11B9: 3C 40 00 CMP   [CY_irq],0x0
    11BC: A0 AC    JZ    0x1269
(0416) 	{
(0417) 		BYTE Irq_Status[2];
(0418) 		CY_irq=FALSE;
    11BE: 55 40 00 MOV   [CY_irq],0x0
(0419) 		switch(State)
    11C1: 51 8B    MOV   A,[State]
    11C3: 54 05    MOV   [X+5],A
    11C5: 56 04 00 MOV   [X+4],0x0
    11C8: 3D 04 00 CMP   [X+4],0x0
    11CB: B0 06    JNZ   0x11D2
    11CD: 3D 05 01 CMP   [X+5],0x1
    11D0: A0 58    JZ    0x1229
    11D2: 3D 04 00 CMP   [X+4],0x0
    11D5: B0 06    JNZ   0x11DC
    11D7: 3D 05 02 CMP   [X+5],0x2
    11DA: A0 4E    JZ    0x1229
    11DC: 3D 04 00 CMP   [X+4],0x0
    11DF: B0 06    JNZ   0x11E6
    11E1: 3D 05 04 CMP   [X+5],0x4
    11E4: A0 21    JZ    0x1206
    11E6: 3D 04 00 CMP   [X+4],0x0
    11E9: B0 06    JNZ   0x11F0
    11EB: 3D 05 06 CMP   [X+5],0x6
    11EE: A0 44    JZ    0x1233
    11F0: 3D 04 00 CMP   [X+4],0x0
    11F3: B0 06    JNZ   0x11FA
    11F5: 3D 05 0A CMP   [X+5],0xA
    11F8: A0 3A    JZ    0x1233
    11FA: 3D 04 00 CMP   [X+4],0x0
    11FD: B0 06    JNZ   0x1204
    11FF: 3D 05 0B CMP   [X+5],0xB
    1202: A0 30    JZ    0x1233
    1204: 80 38    JMP   0x123D
(0420) 		{
(0421) 			case DSM_STATE_BIND_ACK:
(0422) 				{
(0423) 				//read IRQ status
(0424) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    1206: 50 02    MOV   A,0x2
    1208: 08       PUSH  A
    1209: 5A 16    MOV   [__r1],X
    120B: 06 16 02 ADD   [__r1],0x2
    120E: 51 17    MOV   A,[__r0]
    1210: 08       PUSH  A
    1211: 51 16    MOV   A,[__r1]
    1213: 08       PUSH  A
    1214: 50 04    MOV   A,0x4
    1216: 08       PUSH  A
    1217: 7C 0B A9 LCALL _CYRF_ReadRegisterMulti
    121A: 38 FC    ADD   SP,0xFC
(0425) 				Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
    121C: 52 03    MOV   A,[X+3]
    121E: 21 01    AND   A,0x1
    1220: 2D 02    OR    [X+2],A
(0426) 				//TX done
(0427) 				if(Irq_Status[0]&TXC_IRQ)
    1222: 48 02 02 TST   [X+2],0x2
    1225: A0 55    JZ    0x127B
(0428) 					{
(0429) 					}
(0430) 				}
(0431) 				break;
    1227: 80 53    JMP   0x127B
(0432) 			case DSM_STATE_BIND_RCV:
(0433) 			case DSM_STATE_BIND_RCV_WAIT:
(0434) 				{
(0435) 					
(0436) 					if (ProcessRxIrqStatus())
    1229: 9E F4    CALL  _ProcessRxIrqStatus
    122B: 39 00    CMP   A,0x0
    122D: A0 4D    JZ    0x127B
(0437) 						{
(0438) 						//we got some thing
(0439) 						Process_BindRcvIrq();	
    122F: 94 A6    CALL  _Process_BindRcvIrq
(0440) 						}
(0441) 				}
(0442) 				break;
    1231: 80 49    JMP   0x127B
(0443) 			case DSM_STATE_SYNC_AB:
(0444) 			case DSM_STATE_SYNC_X:
(0445) 			case DSM_STATE_LOCKED:	
(0446) 				{
(0447) 					if(ProcessRxIrqStatus())
    1233: 9E EA    CALL  _ProcessRxIrqStatus
    1235: 39 00    CMP   A,0x0
    1237: A0 43    JZ    0x127B
(0448) 						{
(0449) 						//we got some thing
(0450) 						Process_Rvc_Irq();
    1239: 9E 36    CALL  _Process_Rvc_Irq
(0451) 						}
(0452) 				}
(0453) 				break;
    123B: 80 3F    JMP   0x127B
(0454) 			default :
(0455) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    123D: 50 02    MOV   A,0x2
    123F: 08       PUSH  A
    1240: 5A 16    MOV   [__r1],X
    1242: 06 16 02 ADD   [__r1],0x2
    1245: 51 17    MOV   A,[__r0]
    1247: 08       PUSH  A
    1248: 51 16    MOV   A,[__r1]
    124A: 08       PUSH  A
    124B: 50 04    MOV   A,0x4
    124D: 08       PUSH  A
    124E: 7C 0B A9 LCALL _CYRF_ReadRegisterMulti
(0456) 				CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
    1251: 50 02    MOV   A,0x2
    1253: 08       PUSH  A
    1254: 5A 16    MOV   [__r1],X
    1256: 06 16 02 ADD   [__r1],0x2
    1259: 51 17    MOV   A,[__r0]
    125B: 08       PUSH  A
    125C: 51 16    MOV   A,[__r1]
    125E: 08       PUSH  A
    125F: 50 07    MOV   A,0x7
    1261: 08       PUSH  A
    1262: 7C 0B A9 LCALL _CYRF_ReadRegisterMulti
    1265: 38 F8    ADD   SP,0xF8
(0457) 		}
(0458) 	}
    1267: 80 13    JMP   0x127B
(0459) 	else //no IRQ to process
(0460) 	{
(0461) 		if (New_RCV_Data&& Ch_A)
    1269: 3C 47 00 CMP   [New_RCV_Data],0x0
    126C: A0 0E    JZ    0x127B
    126E: 3C 4C 00 CMP   [Ch_A],0x0
    1271: A0 09    JZ    0x127B
(0462) 		{
(0463) 			New_RCV_Data=FALSE;
    1273: 55 47 00 MOV   [New_RCV_Data],0x0
(0464) 			Rcv_Timeout=FALSE;
    1276: 55 89 00 MOV   [Rcv_Timeout],0x0
(0465) 			ProcessNewData();
    1279: 9E FD    CALL  _ProcessNewData
(0466) 		}
(0467) 	}
    127B: 38 FA    ADD   SP,0xFA
    127D: 20       POP   X
    127E: 7F       RET   
(0468) }
(0469) 
(0470) 
(0471) //calculate dsmX channels 
(0472) //found on deviation-tx source
(0473) // math by Alexandr Alexandrov code by Sergey Gimaev
(0474) //pseudo random gennerator /Linear congruential generator based on "Numerical Recipes" Chapter 7.1
(0475) void calc_dsmx_channel(void)
(0476) {
_calc_dsmx_channel:
  count_52_76          --> X+20
  count_28_51          --> X+18
  count_3_27           --> X+16
  next_ch              --> X+15
  i                    --> X+13
  id                   --> X+5
  id_tmp               --> X+1
  idx                  --> X+0
    127F: 10       PUSH  X
    1280: 4F       MOV   X,SP
    1281: 38 16    ADD   SP,0x16
(0477)     BYTE idx; 
(0478) 	DWORD id_tmp;
(0479)     DWORD id = ~(((DWORD)cyrfmfg_id[0] << 24) | ((DWORD)cyrfmfg_id[1] << 16) | ((DWORD)cyrfmfg_id[2] << 8) | (((DWORD)cyrfmfg_id[3]) << 0));
    1283: 5F 14 76 MOV   [__r3],[config+3]
    1286: 56 09 00 MOV   [X+9],0x0
    1289: 56 0A 00 MOV   [X+10],0x0
    128C: 56 0B 00 MOV   [X+11],0x0
    128F: 51 14    MOV   A,[__r3]
    1291: 54 0C    MOV   [X+12],A
    1293: 5F 10 75 MOV   [__r7],[config+2]
    1296: 55 11 00 MOV   [__r6],0x0
    1299: 55 12 00 MOV   [__r5],0x0
    129C: 55 13 00 MOV   [__r4],0x0
    129F: 50 08    MOV   A,0x8
    12A1: 65 10    ASL   [__r7]
    12A3: 6B 11    RLC   [__r6]
    12A5: 6B 12    RLC   [__r5]
    12A7: 6B 13    RLC   [__r4]
    12A9: 78       DEC   A
    12AA: BF F6    JNZ   0x12A1
    12AC: 5F 0C 74 MOV   [__r11],[config+1]
    12AF: 55 0D 00 MOV   [__r10],0x0
    12B2: 55 0E 00 MOV   [__r9],0x0
    12B5: 55 0F 00 MOV   [__r8],0x0
    12B8: 50 10    MOV   A,0x10
    12BA: 65 0C    ASL   [__r11]
    12BC: 6B 0D    RLC   [__r10]
    12BE: 6B 0E    RLC   [__r9]
    12C0: 6B 0F    RLC   [__r8]
    12C2: 78       DEC   A
    12C3: BF F6    JNZ   0x12BA
    12C5: 5F 14 73 MOV   [__r3],[config]
    12C8: 55 15 00 MOV   [__r2],0x0
    12CB: 55 16 00 MOV   [__r1],0x0
    12CE: 55 17 00 MOV   [__r0],0x0
    12D1: 50 18    MOV   A,0x18
    12D3: 65 14    ASL   [__r3]
    12D5: 6B 15    RLC   [__r2]
    12D7: 6B 16    RLC   [__r1]
    12D9: 6B 17    RLC   [__r0]
    12DB: 78       DEC   A
    12DC: BF F6    JNZ   0x12D3
    12DE: 51 0C    MOV   A,[__r11]
    12E0: 2C 14    OR    [__r3],A
    12E2: 51 0D    MOV   A,[__r10]
    12E4: 2C 15    OR    [__r2],A
    12E6: 51 0E    MOV   A,[__r9]
    12E8: 2C 16    OR    [__r1],A
    12EA: 51 0F    MOV   A,[__r8]
    12EC: 2C 17    OR    [__r0],A
    12EE: 51 10    MOV   A,[__r7]
    12F0: 2C 14    OR    [__r3],A
    12F2: 51 11    MOV   A,[__r6]
    12F4: 2C 15    OR    [__r2],A
    12F6: 51 12    MOV   A,[__r5]
    12F8: 2C 16    OR    [__r1],A
    12FA: 51 13    MOV   A,[__r4]
    12FC: 2C 17    OR    [__r0],A
    12FE: 52 0C    MOV   A,[X+12]
    1300: 2C 14    OR    [__r3],A
    1302: 52 0B    MOV   A,[X+11]
    1304: 2C 15    OR    [__r2],A
    1306: 52 0A    MOV   A,[X+10]
    1308: 2C 16    OR    [__r1],A
    130A: 52 09    MOV   A,[X+9]
    130C: 2C 17    OR    [__r0],A
    130E: 51 17    MOV   A,[__r0]
    1310: 73       CPL   A
    1311: 54 05    MOV   [X+5],A
    1313: 51 16    MOV   A,[__r1]
    1315: 73       CPL   A
    1316: 54 06    MOV   [X+6],A
    1318: 51 15    MOV   A,[__r2]
    131A: 73       CPL   A
    131B: 54 07    MOV   [X+7],A
    131D: 51 14    MOV   A,[__r3]
    131F: 73       CPL   A
    1320: 54 08    MOV   [X+8],A
(0480) 	idx = 0;
    1322: 56 00 00 MOV   [X+0],0x0
(0481)     id_tmp = id;
    1325: 52 05    MOV   A,[X+5]
    1327: 54 01    MOV   [X+1],A
    1329: 52 06    MOV   A,[X+6]
    132B: 54 02    MOV   [X+2],A
    132D: 52 07    MOV   A,[X+7]
    132F: 54 03    MOV   [X+3],A
    1331: 52 08    MOV   A,[X+8]
    1333: 54 04    MOV   [X+4],A
    1335: 81 9B    JMP   0x14D1
(0482)     while(idx < 23) {
(0483)         int i;
(0484)         BYTE next_ch;
(0485) 		int count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;
    1337: 56 11 00 MOV   [X+17],0x0
    133A: 56 10 00 MOV   [X+16],0x0
    133D: 56 13 00 MOV   [X+19],0x0
    1340: 56 12 00 MOV   [X+18],0x0
    1343: 56 15 00 MOV   [X+21],0x0
    1346: 56 14 00 MOV   [X+20],0x0
(0486)         id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F; // Randomization
    1349: 52 01    MOV   A,[X+1]
    134B: 08       PUSH  A
    134C: 52 02    MOV   A,[X+2]
    134E: 08       PUSH  A
    134F: 52 03    MOV   A,[X+3]
    1351: 08       PUSH  A
    1352: 52 04    MOV   A,[X+4]
    1354: 08       PUSH  A
    1355: 50 00    MOV   A,0x0
    1357: 08       PUSH  A
    1358: 50 19    MOV   A,0x19
    135A: 08       PUSH  A
    135B: 50 66    MOV   A,0x66
    135D: 08       PUSH  A
    135E: 50 0D    MOV   A,0xD
    1360: 08       PUSH  A
    1361: 7C 1F 50 LCALL 0x1F50
    1364: 38 FC    ADD   SP,0xFC
    1366: 18       POP   A
    1367: 53 14    MOV   [__r3],A
    1369: 18       POP   A
    136A: 53 15    MOV   [__r2],A
    136C: 18       POP   A
    136D: 53 16    MOV   [__r1],A
    136F: 18       POP   A
    1370: 53 17    MOV   [__r0],A
    1372: 51 14    MOV   A,[__r3]
    1374: 01 5F    ADD   A,0x5F
    1376: 54 04    MOV   [X+4],A
    1378: 51 15    MOV   A,[__r2]
    137A: 09 F3    ADC   A,0xF3
    137C: 54 03    MOV   [X+3],A
    137E: 51 16    MOV   A,[__r1]
    1380: 09 6E    ADC   A,0x6E
    1382: 54 02    MOV   [X+2],A
    1384: 51 17    MOV   A,[__r0]
    1386: 09 3C    ADC   A,0x3C
    1388: 54 01    MOV   [X+1],A
(0487)         next_ch = ((id_tmp >> 8) % 0x49) + 3;       // Use least-significant byte and must be larger than 3
    138A: 52 01    MOV   A,[X+1]
    138C: 53 17    MOV   [__r0],A
    138E: 52 02    MOV   A,[X+2]
    1390: 53 16    MOV   [__r1],A
    1392: 52 03    MOV   A,[X+3]
    1394: 53 15    MOV   [__r2],A
    1396: 52 04    MOV   A,[X+4]
    1398: 53 14    MOV   [__r3],A
    139A: 50 08    MOV   A,0x8
    139C: 70 FB    AND   F,0xFB
    139E: 6E 17    RRC   [__r0]
    13A0: 6E 16    RRC   [__r1]
    13A2: 6E 15    RRC   [__r2]
    13A4: 6E 14    RRC   [__r3]
    13A6: 78       DEC   A
    13A7: BF F4    JNZ   0x139C
    13A9: 50 00    MOV   A,0x0
    13AB: 08       PUSH  A
    13AC: 08       PUSH  A
    13AD: 08       PUSH  A
    13AE: 50 49    MOV   A,0x49
    13B0: 08       PUSH  A
    13B1: 51 17    MOV   A,[__r0]
    13B3: 08       PUSH  A
    13B4: 51 16    MOV   A,[__r1]
    13B6: 08       PUSH  A
    13B7: 51 15    MOV   A,[__r2]
    13B9: 08       PUSH  A
    13BA: 51 14    MOV   A,[__r3]
    13BC: 08       PUSH  A
    13BD: 7C 1E 74 LCALL 0x1E74
    13C0: 38 FC    ADD   SP,0xFC
    13C2: 18       POP   A
    13C3: 53 14    MOV   [__r3],A
    13C5: 18       POP   A
    13C6: 18       POP   A
    13C7: 18       POP   A
    13C8: 06 14 03 ADD   [__r3],0x3
    13CB: 51 14    MOV   A,[__r3]
    13CD: 54 0F    MOV   [X+15],A
(0488)         if (((next_ch ^ id) & 0x01 )== 0)
    13CF: 52 0F    MOV   A,[X+15]
    13D1: 53 14    MOV   [__r3],A
    13D3: 55 15 00 MOV   [__r2],0x0
    13D6: 55 16 00 MOV   [__r1],0x0
    13D9: 55 17 00 MOV   [__r0],0x0
    13DC: 52 08    MOV   A,[X+8]
    13DE: 34 14    XOR   [__r3],A
    13E0: 52 07    MOV   A,[X+7]
    13E2: 34 15    XOR   [__r2],A
    13E4: 52 06    MOV   A,[X+6]
    13E6: 34 16    XOR   [__r1],A
    13E8: 52 05    MOV   A,[X+5]
    13EA: 34 17    XOR   [__r0],A
    13EC: 26 14 01 AND   [__r3],0x1
    13EF: 26 15 00 AND   [__r2],0x0
    13F2: 26 16 00 AND   [__r1],0x0
    13F5: 26 17 00 AND   [__r0],0x0
    13F8: B0 12    JNZ   0x140B
    13FA: 3C 16 00 CMP   [__r1],0x0
    13FD: B0 0D    JNZ   0x140B
    13FF: 3C 15 00 CMP   [__r2],0x0
    1402: B0 08    JNZ   0x140B
    1404: 3C 14 00 CMP   [__r3],0x0
    1407: B0 03    JNZ   0x140B
(0489)             continue;
    1409: 80 C7    JMP   0x14D1
(0490)         for (i = 0; i < idx; i++) {
    140B: 56 0E 00 MOV   [X+14],0x0
    140E: 56 0D 00 MOV   [X+13],0x0
    1411: 80 47    JMP   0x1459
(0491)             if(channels[i] == next_ch)
    1413: 52 0E    MOV   A,[X+14]
    1415: 01 4E    ADD   A,0x4E
    1417: 53 16    MOV   [__r1],A
    1419: 3E 16    MVI   A,[__r1]
    141B: 3B 0F    CMP   A,[X+15]
    141D: B0 03    JNZ   0x1421
(0492)                 break;
    141F: 80 4F    JMP   0x146F
(0493)             if(channels[i] <= 27)
    1421: 52 0E    MOV   A,[X+14]
    1423: 01 4E    ADD   A,0x4E
    1425: 53 16    MOV   [__r1],A
    1427: 3E 16    MVI   A,[__r1]
    1429: 53 17    MOV   [__r0],A
    142B: 50 1B    MOV   A,0x1B
    142D: 3A 17    CMP   A,[__r0]
    142F: C0 08    JC    0x1438
(0494)                 count_3_27++;
    1431: 77 11    INC   [X+17]
    1433: 0F 10 00 ADC   [X+16],0x0
    1436: 80 1D    JMP   0x1454
(0495)             else if (channels[i] <= 51)
    1438: 52 0E    MOV   A,[X+14]
    143A: 01 4E    ADD   A,0x4E
    143C: 53 16    MOV   [__r1],A
    143E: 3E 16    MVI   A,[__r1]
    1440: 53 17    MOV   [__r0],A
    1442: 50 33    MOV   A,0x33
    1444: 3A 17    CMP   A,[__r0]
    1446: C0 08    JC    0x144F
(0496)                 count_28_51++;
    1448: 77 13    INC   [X+19]
    144A: 0F 12 00 ADC   [X+18],0x0
    144D: 80 06    JMP   0x1454
(0497)             else
(0498)                 count_52_76++;
    144F: 77 15    INC   [X+21]
    1451: 0F 14 00 ADC   [X+20],0x0
(0499)         }
    1454: 77 0E    INC   [X+14]
    1456: 0F 0D 00 ADC   [X+13],0x0
    1459: 52 00    MOV   A,[X+0]
    145B: 53 16    MOV   [__r1],A
    145D: 52 0E    MOV   A,[X+14]
    145F: 12 16    SUB   A,[__r1]
    1461: 50 00    MOV   A,0x0
    1463: 31 80    XOR   A,0x80
    1465: 53 0B    MOV   [__rX],A
    1467: 52 0D    MOV   A,[X+13]
    1469: 31 80    XOR   A,0x80
    146B: 1A 0B    SBB   A,[__rX]
    146D: CF A5    JC    0x1413
(0500)         if (i != idx)
    146F: 52 00    MOV   A,[X+0]
    1471: 53 16    MOV   [__r1],A
    1473: 55 17 00 MOV   [__r0],0x0
    1476: 52 0D    MOV   A,[X+13]
    1478: 3A 17    CMP   A,[__r0]
    147A: B0 07    JNZ   0x1482
    147C: 52 0E    MOV   A,[X+14]
    147E: 3A 16    CMP   A,[__r1]
    1480: A0 03    JZ    0x1484
(0501)             continue;
    1482: 80 4E    JMP   0x14D1
(0502)         if ((next_ch < 28 && count_3_27 < 8)
    1484: 3D 0F 1C CMP   [X+15],0x1C
    1487: D0 0D    JNC   0x1495
    1489: 52 11    MOV   A,[X+17]
    148B: 11 08    SUB   A,0x8
    148D: 52 10    MOV   A,[X+16]
    148F: 31 80    XOR   A,0x80
    1491: 19 80    SBB   A,0x80
    1493: C0 28    JC    0x14BC
    1495: 3D 0F 1C CMP   [X+15],0x1C
    1498: C0 12    JC    0x14AB
    149A: 3D 0F 34 CMP   [X+15],0x34
    149D: D0 0D    JNC   0x14AB
    149F: 52 13    MOV   A,[X+19]
    14A1: 11 07    SUB   A,0x7
    14A3: 52 12    MOV   A,[X+18]
    14A5: 31 80    XOR   A,0x80
    14A7: 19 80    SBB   A,0x80
    14A9: C0 12    JC    0x14BC
    14AB: 3D 0F 34 CMP   [X+15],0x34
    14AE: C0 22    JC    0x14D1
    14B0: 52 15    MOV   A,[X+21]
    14B2: 11 08    SUB   A,0x8
    14B4: 52 14    MOV   A,[X+20]
    14B6: 31 80    XOR   A,0x80
    14B8: 19 80    SBB   A,0x80
    14BA: D0 16    JNC   0x14D1
(0503)           ||(next_ch >= 28 && next_ch < 52 && count_28_51 < 7)
(0504)           ||(next_ch >= 52 && count_52_76 < 8))
(0505)         {
(0506)             channels[idx++] = next_ch;
    14BC: 52 00    MOV   A,[X+0]
    14BE: 53 16    MOV   [__r1],A
    14C0: 55 17 00 MOV   [__r0],0x0
    14C3: 01 01    ADD   A,0x1
    14C5: 54 00    MOV   [X+0],A
    14C7: 06 16 4E ADD   [__r1],0x4E
    14CA: 0E 17 00 ADC   [__r0],0x0
    14CD: 52 0F    MOV   A,[X+15]
    14CF: 3F 16    MVI   [__r1],A
(0507)         }
(0508)     }
    14D1: 3D 00 17 CMP   [X+0],0x17
    14D4: CE 62    JC    0x1337
    14D6: 38 EA    ADD   SP,0xEA
    14D8: 20       POP   X
    14D9: 7F       RET   
(0509) }
(0510) 
(0511) 
(0512) //initialise system
(0513) void DSM_Init(void)
(0514) {
_DSM_Init:
  n                    --> X+0
    14DA: 10       PUSH  X
    14DB: 4F       MOV   X,SP
    14DC: 38 01    ADD   SP,0x1
(0515) 	BYTE n;
(0516) 	new_data=FALSE;
    14DE: 55 8A 00 MOV   [new_data],0x0
(0517) 	//init CYRF6936
(0518) 	CYRF_Init();
    14E1: 7C 0A 6A LCALL _CYRF_Init
(0519) 	//set defalut values
(0520) 	DSM_Is_DSMX=FALSE;
    14E4: 55 77 00 MOV   [config+4],0x0
(0521) 	DSM_Is_11ms=FALSE;
    14E7: 55 78 00 MOV   [config+5],0x0
(0522) 	DSM_Is_11Bit=FALSE;
    14EA: 55 79 00 MOV   [config+6],0x0
(0523) 	Ch_A=TRUE;
    14ED: 55 4C 01 MOV   [Ch_A],0x1
(0524) 	chidx=0;
    14F0: 55 4D 00 MOV   [chidx],0x0
(0525) 	Preste_Failsafe=FALSE;
    14F3: 55 7A 00 MOV   [config+7],0x0
(0526) 	DSM_Load_Config(init_vals,sizeof(init_vals)/(sizeof(BYTE)*2));
    14F6: 50 0B    MOV   A,0xB
    14F8: 08       PUSH  A
    14F9: 50 02    MOV   A,0x2
    14FB: 08       PUSH  A
    14FC: 50 E0    MOV   A,0xE0
    14FE: 08       PUSH  A
    14FF: 99 29    CALL  _DSM_Load_Config
(0527) 
(0528) 	CYRF_WritePreamble(preamble);
    1501: 50 03    MOV   A,0x3
    1503: 08       PUSH  A
    1504: 50 02    MOV   A,0x2
    1506: 08       PUSH  A
    1507: 50 FE    MOV   A,0xFE
    1509: 08       PUSH  A
    150A: 50 24    MOV   A,0x24
    150C: 08       PUSH  A
    150D: 7C 0A BB LCALL _CYRF_WriteRegisterMulti
    1510: 38 F9    ADD   SP,0xF9
    1512: 38 FF    ADD   SP,0xFF
    1514: 20       POP   X
    1515: 7F       RET   
(0529) }
(0530) 
(0531) /*++++++++++BIND STUFF****************/
(0532) static const BYTE bind_vals[][2] = {
(0533)     {CYRF_TX_CFG,TX_DC_LEN|TX_DM(TX_DM_SDR)|DSM_BIND_POWER}, //0x38 Set 64 chip, SDR mode
(0534)     {CYRF_FRAMING_CFG,SOP_LEN|0xE}, //0x4A set sop len  32 chip and threshold =0xE 
(0535)     {CYRF_RX_OVERRIDE, DIS_RXCRC|FRC_RXDR}, //0x14 disable rx CRC Force Receive Data Rate
(0536)     {CYRF_EOP_CTRL, 0x02}, //set EOP sync == 2
(0537)     {CYRF_TX_OVERRIDE, DIS_TXCRC}, //0x4 disable tx CRC
(0538) };
(0539) BYTE Bind_cnt;		//bind ack pulse counter
(0540) BYTE bind_channal;	//channel used to send bind packes
(0541) 
(0542) 
(0543) //initialize bind state
(0544) void DSM_initialize_bind(void)
(0545) {	
(0546) 	State=DSM_STATE_BIND;
_DSM_initialize_bind:
    1516: 55 8B 00 MOV   [State],0x0
(0547) 	DSM_Load_Config(bind_vals,sizeof(bind_vals)/(sizeof(BYTE)*2));
    1519: 50 05    MOV   A,0x5
    151B: 08       PUSH  A
    151C: 50 03    MOV   A,0x3
    151E: 08       PUSH  A
    151F: 50 01    MOV   A,0x1
    1521: 08       PUSH  A
    1522: 99 06    CALL  _DSM_Load_Config
    1524: 38 FD    ADD   SP,0xFD
(0548) 	bind_channal=1;
    1526: 55 45 01 MOV   [bind_channal],0x1
(0549) 	Bind_cnt=0;
    1529: 55 46 00 MOV   [Bind_cnt],0x0
(0550) 	CYRF_SetRFChannel(bind_channal);
    152C: 51 45    MOV   A,[bind_channal]
    152E: 08       PUSH  A
    152F: 50 00    MOV   A,0x0
    1531: 08       PUSH  A
    1532: 7C 0A A2 LCALL _CYRF_WriteRegister
(0551) 	CYRF_SetDataCode(pncodes[0][8], 16);
    1535: 50 10    MOV   A,0x10
    1537: 08       PUSH  A
    1538: 50 01    MOV   A,0x1
    153A: 08       PUSH  A
    153B: 50 B8    MOV   A,0xB8
    153D: 08       PUSH  A
    153E: 50 23    MOV   A,0x23
    1540: 08       PUSH  A
    1541: 7C 0A BB LCALL _CYRF_WriteRegisterMulti
    1544: 38 FA    ADD   SP,0xFA
(0552) 	Timer_SetPeriod(DSM_TIME_BIND_RCV);
    1546: 10       PUSH  X
    1547: 50 2E    MOV   A,0x2E
    1549: 7C 04 81 LCALL _Timer8_1_WritePeriod
    154C: 20       POP   X
(0553) 	Timer_SetCallback(Bind_TimeOut_cb);
    154D: 50 03    MOV   A,0x3
    154F: 08       PUSH  A
    1550: 50 18    MOV   A,0x18
    1552: 08       PUSH  A
    1553: 7C 1D 93 LCALL _Timer_SetCallback
    1556: 38 FE    ADD   SP,0xFE
(0554) 	Timer_Start();
    1558: 10       PUSH  X
    1559: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    155C: 20       POP   X
    155D: 7F       RET   
(0555) }
(0556) 
(0557) 
(0558) void DSM_Build_Ack_package(void)
(0559) {
_DSM_Build_Ack_package:
  ckSum                --> X+1
  i                    --> X+0
    155E: 10       PUSH  X
    155F: 4F       MOV   X,SP
    1560: 38 0D    ADD   SP,0xD
(0560) 	BYTE i;
(0561)     WORD ckSum = 0x170;
    1562: 56 02 70 MOV   [X+2],0x70
    1565: 56 01 01 MOV   [X+1],0x1
(0562) 	tx_buf[0]=rx_buf[0];
    1568: 5F 20 30 MOV   [mem],[mem+16]
(0563) 	tx_buf[1]=rx_buf[1];
    156B: 5F 21 31 MOV   [mem+1],[mem+17]
(0564) 	tx_buf[2]=rx_buf[2];
    156E: 5F 22 32 MOV   [mem+2],[mem+18]
(0565) 	tx_buf[3]=rx_buf[3];
    1571: 5F 23 33 MOV   [mem+3],[mem+19]
(0566)     tx_buf[4]=rx_buf[10];
    1574: 5F 24 3A MOV   [mem+4],[mem+26]
(0567)     tx_buf[5]=num_channels;
    1577: 5F 25 49 MOV   [mem+5],[num_channels]
(0568)     tx_buf[6]=DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01); //rx_buf[12]; //protocoll
    157A: 3C 77 00 CMP   [config+4],0x0
    157D: A0 1E    JZ    0x159C
    157F: 3C 78 00 CMP   [config+5],0x0
    1582: A0 09    JZ    0x158C
    1584: 56 06 B2 MOV   [X+6],0xB2
    1587: 56 05 00 MOV   [X+5],0x0
    158A: 80 07    JMP   0x1592
    158C: 56 06 A2 MOV   [X+6],0xA2
    158F: 56 05 00 MOV   [X+5],0x0
    1592: 52 06    MOV   A,[X+6]
    1594: 54 04    MOV   [X+4],A
    1596: 52 05    MOV   A,[X+5]
    1598: 54 03    MOV   [X+3],A
    159A: 80 46    JMP   0x15E1
    159C: 3C 79 00 CMP   [config+6],0x0
    159F: A0 1E    JZ    0x15BE
    15A1: 3C 78 00 CMP   [config+5],0x0
    15A4: A0 09    JZ    0x15AE
    15A6: 56 0A 12 MOV   [X+10],0x12
    15A9: 56 09 00 MOV   [X+9],0x0
    15AC: 80 07    JMP   0x15B4
    15AE: 56 0A 11 MOV   [X+10],0x11
    15B1: 56 09 00 MOV   [X+9],0x0
    15B4: 52 0A    MOV   A,[X+10]
    15B6: 54 08    MOV   [X+8],A
    15B8: 52 09    MOV   A,[X+9]
    15BA: 54 07    MOV   [X+7],A
    15BC: 80 1C    JMP   0x15D9
    15BE: 3C 78 00 CMP   [config+5],0x0
    15C1: A0 09    JZ    0x15CB
    15C3: 56 0C 02 MOV   [X+12],0x2
    15C6: 56 0B 00 MOV   [X+11],0x0
    15C9: 80 07    JMP   0x15D1
    15CB: 56 0C 01 MOV   [X+12],0x1
    15CE: 56 0B 00 MOV   [X+11],0x0
    15D1: 52 0C    MOV   A,[X+12]
    15D3: 54 08    MOV   [X+8],A
    15D5: 52 0B    MOV   A,[X+11]
    15D7: 54 07    MOV   [X+7],A
    15D9: 52 08    MOV   A,[X+8]
    15DB: 54 04    MOV   [X+4],A
    15DD: 52 07    MOV   A,[X+7]
    15DF: 54 03    MOV   [X+3],A
    15E1: 52 04    MOV   A,[X+4]
    15E3: 53 26    MOV   [mem+6],A
(0569)     tx_buf[7]=rx_buf[13];//???
    15E5: 5F 27 3D MOV   [mem+7],[mem+29]
(0570) 
(0571) 	for (i = 0; i < 8; i++)
    15E8: 56 00 00 MOV   [X+0],0x0
    15EB: 80 12    JMP   0x15FE
(0572)          ckSum += tx_buf[i];
    15ED: 52 00    MOV   A,[X+0]
    15EF: 01 20    ADD   A,0x20
    15F1: 53 16    MOV   [__r1],A
    15F3: 3E 16    MVI   A,[__r1]
    15F5: 05 02    ADD   [X+2],A
    15F7: 50 00    MOV   A,0x0
    15F9: 0F 01 00 ADC   [X+1],0x0
    15FC: 77 00    INC   [X+0]
    15FE: 3D 00 08 CMP   [X+0],0x8
    1601: CF EB    JC    0x15ED
(0573) 	tx_buf[8]=(ckSum >> 8);
    1603: 52 01    MOV   A,[X+1]
    1605: 53 28    MOV   [mem+8],A
(0574) 	tx_buf[9]=(ckSum & 0xff);
    1607: 52 02    MOV   A,[X+2]
    1609: 53 29    MOV   [mem+9],A
    160B: 38 F3    ADD   SP,0xF3
    160D: 20       POP   X
    160E: 7F       RET   
(0575) }
(0576) 
(0577) 
(0578) //start waiting for the bind recive signal
(0579) void DSM_StartRcv(void)
(0580) {
(0581) 		CYRF_StartReceive();
_DSM_StartRcv:
    160F: 50 83    MOV   A,0x83
    1611: 08       PUSH  A
    1612: 50 05    MOV   A,0x5
    1614: 08       PUSH  A
    1615: 7C 0A A2 LCALL _CYRF_WriteRegister
(0582) 		CYRF_ReadRSSI();
    1618: 50 13    MOV   A,0x13
    161A: 08       PUSH  A
    161B: 7C 0B 91 LCALL _CYRF_ReadRegister
    161E: 38 FD    ADD   SP,0xFD
    1620: 7F       RET   
(0583) }
(0584) 
(0585) void DSM_StartBindAck(void)
(0586) {
(0587) 	CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
_DSM_StartBindAck:
    1621: 50 02    MOV   A,0x2
    1623: 08       PUSH  A
    1624: 50 00    MOV   A,0x0
    1626: 08       PUSH  A
    1627: 50 00    MOV   A,0x0
    1629: 08       PUSH  A
    162A: 50 01    MOV   A,0x1
    162C: 08       PUSH  A
    162D: 7C 0B 7B LCALL _CYRF_WriteRegisterInc
(0588) 	CYRF_WriteTx_Data(tx_buf);
    1630: 50 10    MOV   A,0x10
    1632: 08       PUSH  A
    1633: 50 00    MOV   A,0x0
    1635: 08       PUSH  A
    1636: 50 20    MOV   A,0x20
    1638: 08       PUSH  A
    1639: 50 20    MOV   A,0x20
    163B: 08       PUSH  A
    163C: 7C 0B 20 LCALL _CYRF_WriteRegisterMultiD
    163F: 38 F8    ADD   SP,0xF8
    1641: 7F       RET   
(0589) }
(0590) 
(0591) 
(0592) void Bind_xfer_cb(void)
(0593) {
_Bind_xfer_cb:
  i                    --> X+0
    1642: 10       PUSH  X
    1643: 4F       MOV   X,SP
    1644: 38 01    ADD   SP,0x1
(0594) 	BYTE i;
(0595) 
(0596) 	if (Bind_cnt)
    1646: 3C 46 00 CMP   [Bind_cnt],0x0
    1649: A0 07    JZ    0x1651
(0597) 	{
(0598) 		Bind_cnt--;
    164B: 7A 46    DEC   [Bind_cnt]
(0599) 		DSM_StartBindAck();
    164D: 9F D2    CALL  _DSM_StartBindAck
(0600) 	}
    164F: 80 28    JMP   0x1678
(0601) 	else 
(0602) 	{
(0603) 		State=DSM_STATE_BIND_DONE;
    1651: 55 8B 05 MOV   [State],0x5
(0604) #ifdef DEBUG
(0605) 		CH0_OUT_Off();
(0606) #endif
(0607) 		//save Mfg ID of transmitter
(0608) 		cyrfmfg_id[0]=~tx_buf[0];
    1654: 51 20    MOV   A,[mem]
    1656: 73       CPL   A
    1657: 53 73    MOV   [config],A
(0609) 		cyrfmfg_id[1]=~tx_buf[1];
    1659: 51 21    MOV   A,[mem+1]
    165B: 73       CPL   A
    165C: 53 74    MOV   [config+1],A
(0610) 		cyrfmfg_id[2]=~tx_buf[2];
    165E: 51 22    MOV   A,[mem+2]
    1660: 73       CPL   A
    1661: 53 75    MOV   [config+2],A
(0611) 		cyrfmfg_id[3]=~tx_buf[3];
    1663: 51 23    MOV   A,[mem+3]
    1665: 73       CPL   A
    1666: 53 76    MOV   [config+3],A
(0612) 		Timer_Stop();
    1668: 10       PUSH  X
    1669: 7C 04 7D LCALL _Timer8_1_Stop
    166C: 20       POP   X
(0613) 		Timer_SetCallback(0);
    166D: 50 03    MOV   A,0x3
    166F: 08       PUSH  A
    1670: 50 16    MOV   A,0x16
    1672: 08       PUSH  A
    1673: 7C 1D 93 LCALL _Timer_SetCallback
    1676: 38 FE    ADD   SP,0xFE
(0614) 	}
    1678: 38 FF    ADD   SP,0xFF
    167A: 20       POP   X
    167B: 7F       RET   
(0615) }
(0616) 
(0617) void DSM_initialize_bind_ack(void)
(0618) {
(0619)  	DSM_Build_Ack_package();
_DSM_initialize_bind_ack:
    167C: 9E E0    CALL  _DSM_Build_Ack_package
(0620) 	State=DSM_STATE_BIND_ACK;
    167E: 55 8B 04 MOV   [State],0x4
(0621)     CYRF_SetDataCode(pn_bind, 16);
    1681: 50 10    MOV   A,0x10
    1683: 08       PUSH  A
    1684: 50 01    MOV   A,0x1
    1686: 08       PUSH  A
    1687: 50 70    MOV   A,0x70
    1689: 08       PUSH  A
    168A: 50 23    MOV   A,0x23
    168C: 08       PUSH  A
    168D: 7C 0A BB LCALL _CYRF_WriteRegisterMulti
    1690: 38 FC    ADD   SP,0xFC
(0622) 	Timer_Stop();
    1692: 10       PUSH  X
    1693: 7C 04 7D LCALL _Timer8_1_Stop
(0623) 	Timer_SetPeriod(DSM_TIME_BIND_ACK);
    1696: 50 27    MOV   A,0x27
    1698: 7C 04 81 LCALL _Timer8_1_WritePeriod
    169B: 20       POP   X
(0624) 	Timer_SetCallback(Bind_xfer_cb);
    169C: 50 03    MOV   A,0x3
    169E: 08       PUSH  A
    169F: 50 14    MOV   A,0x14
    16A1: 08       PUSH  A
    16A2: 7C 1D 93 LCALL _Timer_SetCallback
    16A5: 38 FE    ADD   SP,0xFE
(0625) 	Timer_Start();
    16A7: 10       PUSH  X
    16A8: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    16AB: 20       POP   X
    16AC: 7F       RET   
(0626) }
(0627) 
(0628) void Bind_TimeOut_cb(void)
(0629) {
(0630) 		DSM_ClearRxError();
_Bind_TimeOut_cb:
    16AD: 7C 0E 67 LCALL _DSM_ClearRxError
(0631) #ifdef DEBUG
(0632) 		CH2_OUT_Invert();
(0633) #endif
(0634) 		if (State==DSM_STATE_BIND_RCV_WAIT) //wait for done
    16B0: 3C 8B 02 CMP   [State],0x2
    16B3: B0 09    JNZ   0x16BD
(0635) 		{ 
(0636) 			Bind_cnt=DSM_BIND_ACK_NUM;
    16B5: 55 46 64 MOV   [Bind_cnt],0x64
(0637) 			State=DSM_STATE_BIND_RCV_START_ACK;
    16B8: 55 8B 03 MOV   [State],0x3
(0638) 		}
    16BB: 80 1A    JMP   0x16D6
(0639) 		else 
(0640) 		{
(0641) 		bind_channal=bind_channal+2;
    16BD: 06 45 02 ADD   [bind_channal],0x2
(0642) 		if (bind_channal>DSM_MAX_CH)
    16C0: 50 4F    MOV   A,0x4F
    16C2: 3A 45    CMP   A,[bind_channal]
    16C4: D0 04    JNC   0x16C9
(0643) 			bind_channal=1;
    16C6: 55 45 01 MOV   [bind_channal],0x1
(0644) 		CYRF_SetRFChannel(bind_channal);
    16C9: 51 45    MOV   A,[bind_channal]
    16CB: 08       PUSH  A
    16CC: 50 00    MOV   A,0x0
    16CE: 08       PUSH  A
    16CF: 7C 0A A2 LCALL _CYRF_WriteRegister
    16D2: 38 FE    ADD   SP,0xFE
(0645) 		DSM_StartRcv();
    16D4: 9F 39    CALL  _DSM_StartRcv
(0646) 		}
    16D6: 7F       RET   
(0647) }
(0648) 
(0649) void Process_BindRcvIrq(void)
(0650) {
_Process_BindRcvIrq:
  ckSum                --> X+1
  n                    --> X+0
    16D7: 10       PUSH  X
    16D8: 4F       MOV   X,SP
    16D9: 38 07    ADD   SP,0x7
(0651) 	BYTE n;
(0652)     WORD ckSum= 384 - 0x10;
    16DB: 56 02 70 MOV   [X+2],0x70
    16DE: 56 01 01 MOV   [X+1],0x1
(0653) 	Timer_Stop();
    16E1: 10       PUSH  X
    16E2: 7C 04 7D LCALL _Timer8_1_Stop
(0654) 	Timer_SetPeriod(DSM_TIME_BIND_RCV);
    16E5: 50 2E    MOV   A,0x2E
    16E7: 7C 04 81 LCALL _Timer8_1_WritePeriod
(0655) 	Timer_Start();
    16EA: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    16ED: 20       POP   X
(0656) #ifdef DEBUG
(0657) 	CH4_OUT_Invert();
(0658) #endif
(0659) 	//check recived data
(0660) 	if(rx_buf[0]!=rx_buf[4] || rx_buf[1]!=rx_buf[5] ||rx_buf[2]!=rx_buf[6] || rx_buf[3]!=rx_buf[7])
    16EE: 51 30    MOV   A,[mem+16]
    16F0: 3A 34    CMP   A,[mem+20]
    16F2: B0 13    JNZ   0x1706
    16F4: 51 31    MOV   A,[mem+17]
    16F6: 3A 35    CMP   A,[mem+21]
    16F8: B0 0D    JNZ   0x1706
    16FA: 51 32    MOV   A,[mem+18]
    16FC: 3A 36    CMP   A,[mem+22]
    16FE: B0 07    JNZ   0x1706
    1700: 51 33    MOV   A,[mem+19]
    1702: 3A 37    CMP   A,[mem+23]
    1704: A0 03    JZ    0x1708
(0661) 	{
(0662) 		goto Bind_rcv_error;
    1706: 80 E4    JMP   0x17EB
(0663) 	}
(0664) 	//gennerate first checksum
(0665)     for(n = 0; n < 8; n++)
    1708: 56 00 00 MOV   [X+0],0x0
    170B: 80 12    JMP   0x171E
(0666)         ckSum += rx_buf[n];
    170D: 52 00    MOV   A,[X+0]
    170F: 01 30    ADD   A,0x30
    1711: 53 16    MOV   [__r1],A
    1713: 3E 16    MVI   A,[__r1]
    1715: 05 02    ADD   [X+2],A
    1717: 50 00    MOV   A,0x0
    1719: 0F 01 00 ADC   [X+1],0x0
    171C: 77 00    INC   [X+0]
    171E: 3D 00 08 CMP   [X+0],0x8
    1721: CF EB    JC    0x170D
(0667) 	if(rx_buf[8] != (ckSum >> 8) || rx_buf[9] !=(ckSum & 0xff))
    1723: 52 01    MOV   A,[X+1]
    1725: 53 16    MOV   [__r1],A
    1727: 55 17 00 MOV   [__r0],0x0
    172A: 5F 14 38 MOV   [__r3],[mem+24]
    172D: 50 00    MOV   A,0x0
    172F: 3A 17    CMP   A,[__r0]
    1731: B0 1D    JNZ   0x174F
    1733: 51 14    MOV   A,[__r3]
    1735: 3A 16    CMP   A,[__r1]
    1737: B0 17    JNZ   0x174F
    1739: 52 02    MOV   A,[X+2]
    173B: 53 16    MOV   [__r1],A
    173D: 55 17 00 MOV   [__r0],0x0
    1740: 5F 14 39 MOV   [__r3],[mem+25]
    1743: 50 00    MOV   A,0x0
    1745: 3A 17    CMP   A,[__r0]
    1747: B0 07    JNZ   0x174F
    1749: 51 14    MOV   A,[__r3]
    174B: 3A 16    CMP   A,[__r1]
    174D: A0 03    JZ    0x1751
(0668) 	{
(0669) 		goto Bind_rcv_error;
    174F: 80 9B    JMP   0x17EB
(0670) 	}
(0671)     //gennerate second checksum 
(0672) 	for(n = 8; n < 14; n++)
    1751: 56 00 08 MOV   [X+0],0x8
    1754: 80 12    JMP   0x1767
(0673)         ckSum += rx_buf[n];
    1756: 52 00    MOV   A,[X+0]
    1758: 01 30    ADD   A,0x30
    175A: 53 16    MOV   [__r1],A
    175C: 3E 16    MVI   A,[__r1]
    175E: 05 02    ADD   [X+2],A
    1760: 50 00    MOV   A,0x0
    1762: 0F 01 00 ADC   [X+1],0x0
    1765: 77 00    INC   [X+0]
    1767: 3D 00 0E CMP   [X+0],0xE
    176A: CF EB    JC    0x1756
(0674) 	if(rx_buf[14] != (ckSum >> 8) || rx_buf[15] !=(ckSum & 0xff))
    176C: 52 01    MOV   A,[X+1]
    176E: 53 16    MOV   [__r1],A
    1770: 55 17 00 MOV   [__r0],0x0
    1773: 5F 14 3E MOV   [__r3],[mem+30]
    1776: 50 00    MOV   A,0x0
    1778: 3A 17    CMP   A,[__r0]
    177A: B0 1D    JNZ   0x1798
    177C: 51 14    MOV   A,[__r3]
    177E: 3A 16    CMP   A,[__r1]
    1780: B0 17    JNZ   0x1798
    1782: 52 02    MOV   A,[X+2]
    1784: 53 16    MOV   [__r1],A
    1786: 55 17 00 MOV   [__r0],0x0
    1789: 5F 14 3F MOV   [__r3],[mem+31]
    178C: 50 00    MOV   A,0x0
    178E: 3A 17    CMP   A,[__r0]
    1790: B0 07    JNZ   0x1798
    1792: 51 14    MOV   A,[__r3]
    1794: 3A 16    CMP   A,[__r1]
    1796: A0 03    JZ    0x179A
(0675) 	{
(0676) 		goto Bind_rcv_error;
    1798: 80 52    JMP   0x17EB
(0677) 	}
(0678) 	if (rx_buf[10] != 0x01)
    179A: 3C 3A 01 CMP   [mem+26],0x1
    179D: A0 03    JZ    0x17A1
(0679) 	{
(0680) 		goto Bind_rcv_error;
    179F: 80 4B    JMP   0x17EB
(0681) 	}
(0682) 	num_channels=rx_buf[11];
    17A1: 5F 49 3B MOV   [num_channels],[mem+27]
(0683) 	if (num_channels>PPM_PULSE_COUNT)
    17A4: 50 07    MOV   A,0x7
    17A6: 3A 49    CMP   A,[num_channels]
    17A8: D0 04    JNC   0x17AD
(0684) 		num_channels=PPM_PULSE_COUNT;
    17AA: 55 49 07 MOV   [num_channels],0x7
(0685) 	DSM_Is_DSMX=PROTOC_IS_DSMX(rx_buf[12]);
    17AD: 51 3C    MOV   A,[mem+28]
    17AF: 21 A0    AND   A,0xA0
    17B1: 39 A0    CMP   A,0xA0
    17B3: B0 09    JNZ   0x17BD
    17B5: 56 04 01 MOV   [X+4],0x1
    17B8: 56 03 00 MOV   [X+3],0x0
    17BB: 80 07    JMP   0x17C3
    17BD: 56 04 00 MOV   [X+4],0x0
    17C0: 56 03 00 MOV   [X+3],0x0
    17C3: 52 04    MOV   A,[X+4]
    17C5: 53 77    MOV   [config+4],A
(0686) 	DSM_Is_11ms=FALSE; //PROTOC_IS_DSM_11MS(rx_buf[12]);
    17C7: 55 78 00 MOV   [config+5],0x0
(0687) 	DSM_Is_11Bit=PROTOC_IS_DSM_11BIT(rx_buf[12]);
    17CA: 51 3C    MOV   A,[mem+28]
    17CC: 21 30    AND   A,0x30
    17CE: 67       ASR   A
    17CF: 67       ASR   A
    17D0: 67       ASR   A
    17D1: 67       ASR   A
    17D2: 21 0F    AND   A,0xF
    17D4: A0 09    JZ    0x17DE
    17D6: 56 06 01 MOV   [X+6],0x1
    17D9: 56 05 00 MOV   [X+5],0x0
    17DC: 80 07    JMP   0x17E4
    17DE: 56 06 00 MOV   [X+6],0x0
    17E1: 56 05 00 MOV   [X+5],0x0
    17E4: 52 06    MOV   A,[X+6]
    17E6: 53 79    MOV   [config+6],A
(0688) 	State=DSM_STATE_BIND_RCV_WAIT; 	
    17E8: 55 8B 02 MOV   [State],0x2
(0689) 
(0690) 	Bind_rcv_error:
(0691) 	DSM_StartRcv();
    17EB: 9E 22    CALL  _DSM_StartRcv
    17ED: 38 F9    ADD   SP,0xF9
    17EF: 20       POP   X
    17F0: 7F       RET   
(0692) }
(0693) //determin if we got 10 or 11 Bit data
(0694) // tryout
(0695) BYTE DSM_DeterminBitCount(void)
(0696) {
_DSM_DeterminBitCount:
  min                  --> X+3
  max                  --> X+2
  n                    --> X+1
  chanal               --> X+0
    17F1: 10       PUSH  X
    17F2: 4F       MOV   X,SP
    17F3: 38 04    ADD   SP,0x4
(0697) 	//tryout
(0698) 	BYTE min=0xff;
    17F5: 56 03 FF MOV   [X+3],0xFF
(0699) 	BYTE max=0;
    17F8: 56 02 00 MOV   [X+2],0x0
(0700) 	BYTE chanal;
(0701) 	BYTE n;
(0702) 	//try 10 Bits
(0703) 	for (n=0;n<7;n++)
    17FB: 56 01 00 MOV   [X+1],0x0
    17FE: 80 30    JMP   0x182F
(0704) 	{
(0705) 		chanal=(rx_data[n*2+2]>>2)&0xF;
    1800: 52 01    MOV   A,[X+1]
    1802: 97 BD    CALL  0x1FC1
    1804: 40       NOP   
    1805: 54 00    MOV   [X+0],A
(0706) 		if (chanal && chanal<min)
    1807: 3D 00 00 CMP   [X+0],0x0
    180A: A0 0B    JZ    0x1816
    180C: 52 00    MOV   A,[X+0]
    180E: 3B 03    CMP   A,[X+3]
    1810: D0 05    JNC   0x1816
(0707) 			min=chanal;
    1812: 52 00    MOV   A,[X+0]
    1814: 54 03    MOV   [X+3],A
(0708) 		if(rx_data[n*2+2]!=0xFF  && chanal>max)
    1816: 52 01    MOV   A,[X+1]
    1818: 64       ASL   A
    1819: 01 22    ADD   A,0x22
    181B: 53 16    MOV   [__r1],A
    181D: 3E 16    MVI   A,[__r1]
    181F: 39 FF    CMP   A,0xFF
    1821: A0 0B    JZ    0x182D
    1823: 52 02    MOV   A,[X+2]
    1825: 3B 00    CMP   A,[X+0]
    1827: D0 05    JNC   0x182D
(0709) 			max=chanal;
    1829: 52 00    MOV   A,[X+0]
    182B: 54 02    MOV   [X+2],A
(0710) 	}		
    182D: 77 01    INC   [X+1]
    182F: 3D 01 07 CMP   [X+1],0x7
    1832: CF CD    JC    0x1800
(0711) 	if (min==1 &&  max && max <7)
    1834: 3D 03 01 CMP   [X+3],0x1
    1837: B0 0F    JNZ   0x1847
    1839: 3D 02 00 CMP   [X+2],0x0
    183C: A0 0A    JZ    0x1847
    183E: 3D 02 07 CMP   [X+2],0x7
    1841: D0 05    JNC   0x1847
(0712) 		return 10;
    1843: 50 0A    MOV   A,0xA
    1845: 80 03    JMP   0x1849
(0713) 	else 
(0714) 		return 11;
    1847: 50 0B    MOV   A,0xB
    1849: 38 FC    ADD   SP,0xFC
    184B: 20       POP   X
    184C: 7F       RET   
(0715) }
(0716) 
(0717) #define PPM_OFFSET (PPM_OUT_CENTER_LEN-1024)
(0718) //Extract chanal data from serial data
(0719) BOOL DSM_process_Data(void)
(0720) {
_DSM_process_Data:
  n                    --> X+0
    184D: 10       PUSH  X
    184E: 4F       MOV   X,SP
    184F: 38 01    ADD   SP,0x1
(0721) static BYTE bits;	
(0722) 	if (!bits) //check if we have 10 or 11 Bit data
    1851: 3C 41 00 CMP   [CY_irq+1],0x0
    1854: B0 05    JNZ   0x185A
(0723) 		bits=DSM_DeterminBitCount();
    1856: 9F 99    CALL  _DSM_DeterminBitCount
    1858: 53 41    MOV   [CY_irq+1],A
(0724) 	if (bits)
    185A: 3C 41 00 CMP   [CY_irq+1],0x0
    185D: A1 03    JZ    0x1961
(0725) 	{
(0726) 	BYTE n;
(0727) 	//static to safe stack space		
(0728) 	static BYTE chanal; 
(0729) 	static WORD value;	
(0730) 		//loop thru the words 
(0731) 		for (n=0;n<7;n++)
    185F: 56 00 00 MOV   [X+0],0x0
    1862: 80 F5    JMP   0x1958
(0732) 		{	//extract chanal number
(0733) 			if (bits==10)
    1864: 3C 41 0A CMP   [CY_irq+1],0xA
    1867: B0 0A    JNZ   0x1872
(0734) 				chanal=(rx_data[n*2+2]>>2)&0xF;
    1869: 52 00    MOV   A,[X+0]
    186B: 97 54    CALL  0x1FC1
    186D: 40       NOP   
    186E: 53 42    MOV   [CY_irq+2],A
    1870: 80 11    JMP   0x1882
(0735) 			else 
(0736) 				chanal=(rx_data[n*2+2]>>3)&0xF;
    1872: 52 00    MOV   A,[X+0]
    1874: 64       ASL   A
    1875: 01 22    ADD   A,0x22
    1877: 53 16    MOV   [__r1],A
    1879: 3E 16    MVI   A,[__r1]
    187B: 67       ASR   A
    187C: 67       ASR   A
    187D: 67       ASR   A
    187E: 21 0F    AND   A,0xF
    1880: 53 42    MOV   [CY_irq+2],A
(0737) 			//check if chanal numer is in range
(0738) 			if (chanal<PPM_PULSE_COUNT && rx_data[n*2+2]!=0xFF)
    1882: 3C 42 07 CMP   [CY_irq+2],0x7
    1885: D0 D0    JNC   0x1956
    1887: 52 00    MOV   A,[X+0]
    1889: 64       ASL   A
    188A: 01 22    ADD   A,0x22
    188C: 53 16    MOV   [__r1],A
    188E: 3E 16    MVI   A,[__r1]
    1890: 39 FF    CMP   A,0xFF
    1892: A0 C3    JZ    0x1956
(0739) 				//extract chanal value
(0740) 			{
(0741) 				if (bits==10)
    1894: 3C 41 0A CMP   [CY_irq+1],0xA
    1897: B0 21    JNZ   0x18B9
(0742) 				{
(0743) 					value=(((WORD)rx_data[n*2+2]<<8)+rx_data[n*2+3])&0x3FF;
    1899: 52 00    MOV   A,[X+0]
    189B: 64       ASL   A
    189C: 53 16    MOV   [__r1],A
    189E: 01 23    ADD   A,0x23
    18A0: 53 14    MOV   [__r3],A
    18A2: 3E 14    MVI   A,[__r3]
    18A4: 53 15    MOV   [__r2],A
    18A6: 06 16 22 ADD   [__r1],0x22
    18A9: 3E 16    MVI   A,[__r1]
    18AB: 53 17    MOV   [__r0],A
    18AD: 51 15    MOV   A,[__r2]
    18AF: 53 44    MOV   [CY_irq+4],A
    18B1: 51 17    MOV   A,[__r0]
    18B3: 21 03    AND   A,0x3
    18B5: 53 43    MOV   [CY_irq+3],A
(0744) 				}
    18B7: 80 1F    JMP   0x18D7
(0745) 				else
(0746) 				{
(0747) 					value=(((WORD)rx_data[n*2+2]<<8)+rx_data[n*2+3])&0x7FF;
    18B9: 52 00    MOV   A,[X+0]
    18BB: 64       ASL   A
    18BC: 53 16    MOV   [__r1],A
    18BE: 01 23    ADD   A,0x23
    18C0: 53 14    MOV   [__r3],A
    18C2: 3E 14    MVI   A,[__r3]
    18C4: 53 15    MOV   [__r2],A
    18C6: 06 16 22 ADD   [__r1],0x22
    18C9: 3E 16    MVI   A,[__r1]
    18CB: 53 17    MOV   [__r0],A
    18CD: 51 15    MOV   A,[__r2]
    18CF: 53 44    MOV   [CY_irq+4],A
    18D1: 51 17    MOV   A,[__r0]
    18D3: 21 07    AND   A,0x7
    18D5: 53 43    MOV   [CY_irq+3],A
(0748) 				}
(0749) 				//PPM has resulution of 2000/1ms so 10 Bit datta (0 to 1024) needs to be multipleid by 2
(0750) 				//best would be a linear scale like "Value=PPM_MIN + (value*(PPM_MAX-PPM_MIN))/(1<<Bits)" but that takes to mutch time.
(0751) 				if (bits==10) 
    18D7: 3C 41 0A CMP   [CY_irq+1],0xA
    18DA: B0 23    JNZ   0x18FE
(0752) 					ppm_Data[chanal]=PPM_OFFSET+ value*2;
    18DC: 5F 16 44 MOV   [__r1],[CY_irq+4]
    18DF: 5F 17 43 MOV   [__r0],[CY_irq+3]
    18E2: 65 16    ASL   [__r1]
    18E4: 6B 17    RLC   [__r0]
    18E6: 06 16 B8 ADD   [__r1],0xB8
    18E9: 0E 17 07 ADC   [__r0],0x7
    18EC: 5F 14 42 MOV   [__r3],[CY_irq+2]
    18EF: 65 14    ASL   [__r3]
    18F1: 06 14 65 ADD   [__r3],0x65
    18F4: 51 17    MOV   A,[__r0]
    18F6: 3F 14    MVI   [__r3],A
    18F8: 51 16    MOV   A,[__r1]
    18FA: 3F 14    MVI   [__r3],A
    18FC: 80 19    JMP   0x1916
(0753) 				else 
(0754) 					ppm_Data[chanal]=PPM_OFFSET+ value;
    18FE: 51 44    MOV   A,[CY_irq+4]
    1900: 01 B8    ADD   A,0xB8
    1902: 53 16    MOV   [__r1],A
    1904: 51 43    MOV   A,[CY_irq+3]
    1906: 09 07    ADC   A,0x7
    1908: 5F 14 42 MOV   [__r3],[CY_irq+2]
    190B: 65 14    ASL   [__r3]
    190D: 06 14 65 ADD   [__r3],0x65
    1910: 3F 14    MVI   [__r3],A
    1912: 51 16    MOV   A,[__r1]
    1914: 3F 14    MVI   [__r3],A
(0755) 				//limit to MIN / MAX
(0756) 				if (PPM_OUT_MAX_LEN<ppm_Data[chanal])
    1916: 5F 16 42 MOV   [__r1],[CY_irq+2]
    1919: 96 8C    CALL  0x1FA7
    191B: 40       NOP   
    191C: 53 16    MOV   [__r1],A
    191E: 50 B8    MOV   A,0xB8
    1920: 12 16    SUB   A,[__r1]
    1922: 50 0F    MOV   A,0xF
    1924: 1A 17    SBB   A,[__r0]
    1926: D0 11    JNC   0x1938
(0757) 					ppm_Data[chanal]=PPM_OUT_MAX_LEN;
    1928: 5F 16 42 MOV   [__r1],[CY_irq+2]
    192B: 65 16    ASL   [__r1]
    192D: 06 16 65 ADD   [__r1],0x65
    1930: 50 0F    MOV   A,0xF
    1932: 3F 16    MVI   [__r1],A
    1934: 50 B8    MOV   A,0xB8
    1936: 3F 16    MVI   [__r1],A
(0758) 				if (PPM_OUT_MIN_LEN>ppm_Data[chanal])
    1938: 5F 16 42 MOV   [__r1],[CY_irq+2]
    193B: 96 6A    CALL  0x1FA7
    193D: 40       NOP   
    193E: 11 B8    SUB   A,0xB8
    1940: 51 17    MOV   A,[__r0]
    1942: 19 07    SBB   A,0x7
    1944: D0 11    JNC   0x1956
(0759) 					ppm_Data[chanal]=PPM_OUT_MIN_LEN;
    1946: 5F 16 42 MOV   [__r1],[CY_irq+2]
    1949: 65 16    ASL   [__r1]
    194B: 06 16 65 ADD   [__r1],0x65
    194E: 50 07    MOV   A,0x7
    1950: 3F 16    MVI   [__r1],A
    1952: 50 B8    MOV   A,0xB8
    1954: 3F 16    MVI   [__r1],A
(0760) 			}
(0761) 		}
    1956: 77 00    INC   [X+0]
    1958: 3D 00 07 CMP   [X+0],0x7
    195B: CF 08    JC    0x1864
(0762) 		return 1;
    195D: 50 01    MOV   A,0x1
    195F: 80 03    JMP   0x1963
(0763) 	}
(0764) 	return 0;
    1961: 50 00    MOV   A,0x0
    1963: 38 FF    ADD   SP,0xFF
    1965: 20       POP   X
    1966: 7F       RET   
(0765) }
(0766) 
(0767) void DSM_Save_Failsafe_Presets(void)
(0768) {
_DSM_Save_Failsafe_Presets:
  n                    --> X+0
    1967: 10       PUSH  X
    1968: 4F       MOV   X,SP
    1969: 38 01    ADD   SP,0x1
(0769) BYTE n;
(0770) #ifdef DEBUG
(0771) 	CH5_OUT_Invert();
(0772) 	CH5_OUT_Invert();
(0773) #endif
(0774) 	for(n=0;n<PPM_PULSE_COUNT;n++)
    196B: 56 00 00 MOV   [X+0],0x0
    196E: 80 22    JMP   0x1991
(0775) 	{	
(0776) 		ppm_fs_Data[n]=ppm_Data[n];
    1970: 96 29    CALL  <created procedures>
    1972: 40       NOP   
    1973: 51 16    MOV   A,[__r1]
    1975: 01 65    ADD   A,0x65
    1977: 53 14    MOV   [__r3],A
    1979: 3E 14    MVI   A,[__r3]
    197B: 53 15    MOV   [__r2],A
    197D: 3E 14    MVI   A,[__r3]
    197F: 53 14    MOV   [__r3],A
    1981: 06 16 7B ADD   [__r1],0x7B
    1984: 0E 17 00 ADC   [__r0],0x0
    1987: 51 15    MOV   A,[__r2]
    1989: 3F 16    MVI   [__r1],A
    198B: 51 14    MOV   A,[__r3]
    198D: 3F 16    MVI   [__r1],A
(0777) 	}
    198F: 77 00    INC   [X+0]
    1991: 3D 00 07 CMP   [X+0],0x7
    1994: CF DB    JC    0x1970
(0778) Preste_Failsafe=TRUE;
    1996: 55 7A 01 MOV   [config+7],0x1
    1999: 38 FF    ADD   SP,0xFF
    199B: 20       POP   X
    199C: 7F       RET   
(0779) }
(0780) 
(0781) void DSM_Load_FS_Data(void)
(0782) {
_DSM_Load_FS_Data:
  n                    --> X+0
    199D: 10       PUSH  X
    199E: 4F       MOV   X,SP
    199F: 38 01    ADD   SP,0x1
(0783) BYTE n;
(0784) #ifdef DEBUG
(0785) 	CH5_OUT_Invert();
(0786) 	CH5_OUT_Invert();
(0787) #endif
(0788) 	if (Preste_Failsafe)
    19A1: 3C 7A 00 CMP   [config+7],0x0
    19A4: A0 2E    JZ    0x19D3
(0789) 	{
(0790) 		for(n=0;n<PPM_PULSE_COUNT;n++)
    19A6: 56 00 00 MOV   [X+0],0x0
    19A9: 80 22    JMP   0x19CC
(0791) 		{	
(0792) 			ppm_Data[n]=ppm_fs_Data[n];
    19AB: 95 EE    CALL  <created procedures>
    19AD: 40       NOP   
    19AE: 51 16    MOV   A,[__r1]
    19B0: 01 7B    ADD   A,0x7B
    19B2: 53 14    MOV   [__r3],A
    19B4: 3E 14    MVI   A,[__r3]
    19B6: 53 15    MOV   [__r2],A
    19B8: 3E 14    MVI   A,[__r3]
    19BA: 53 14    MOV   [__r3],A
    19BC: 06 16 65 ADD   [__r1],0x65
    19BF: 0E 17 00 ADC   [__r0],0x0
    19C2: 51 15    MOV   A,[__r2]
    19C4: 3F 16    MVI   [__r1],A
    19C6: 51 14    MOV   A,[__r3]
    19C8: 3F 16    MVI   [__r1],A
(0793) 		}
    19CA: 77 00    INC   [X+0]
    19CC: 3D 00 07 CMP   [X+0],0x7
    19CF: CF DB    JC    0x19AB
(0794) 	}
    19D1: 80 07    JMP   0x19D9
(0795) 	else 
(0796) 	{
(0797) 		ppm_Data[0]=PPM_OUT_MIN_LEN;
    19D3: 55 66 B8 MOV   [ppm_Data+1],0xB8
    19D6: 55 65 07 MOV   [ppm_Data],0x7
(0798) 	}
    19D9: 38 FF    ADD   SP,0xFF
    19DB: 20       POP   X
    19DC: 7F       RET   
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) //98000BFE295413FE26A81BFE0154 //DSMX
(0006) 
(0007) //900005FF14AA09FF13540DFF00AA   //DSM2
(0008) 
(0009) #include <m8c.h>        // part specific constants and macros
(0010) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0011) #include "timer.h"
(0012) #include "CYRF6936.h"
(0013) #include "DSM.h"
(0014) #include "config.h"
(0015) #include "ppm.h"
(0016) 
(0017) 
(0018) 
(0019) //global data
(0020) BOOL LV_Detect=FALSE;
(0021) //#define DEBUG
(0022) 
(0023) // Declare LVD_ISR as ISR
(0024) #pragma interrupt_handler LVD_ISR
(0025) void LVD_ISR(void)
(0026) {
_LVD_ISR:
    19DD: 08       PUSH  A
(0027)  	LV_Detect=TRUE;
    19DE: 55 04 01 MOV   [LV_Detect],0x1
(0028) 	M8C_ClearIntFlag(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR);
    19E1: 41 E0 FE AND   REG[0xE0],0xFE
(0029) 	M8C_DisableIntMask(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR); 
    19E4: 41 E0 FE AND   REG[0xE0],0xFE
    19E7: 18       POP   A
    19E8: 7E       RETI  
(0030) }
(0031) 
(0032) 
(0033) void main(void)
(0034) {
_main:
  n                    --> X+5
  Bind                 --> X+0
    19E9: 10       PUSH  X
    19EA: 4F       MOV   X,SP
    19EB: 38 0C    ADD   SP,0xC
(0035) 	BOOL Bind;
(0036) 	//initialize everiting
(0037) 
(0038) 	//enable glogal interrupts
(0039) 	M8C_EnableGInt;		
    19ED: 71 01    OR    F,0x1
(0040) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR); 
    19EF: 43 E0 01 OR    REG[0xE0],0x1
(0041) 	ppm_Init();
    19F2: 7C 1B C8 LCALL _ppm_Init
(0042) 
(0043) 	LED_1_Start();
    19F5: 10       PUSH  X
    19F6: 7C 05 08 LCALL wPWM16_1_ReadCounter|_PWM16_1_wReadPulseWidth|wPWM16_1_ReadPulseWidth|_LED_1_Off|_PWM16_1_wReadCounter|LED_1_Start|_wPWM16_1_ReadCounter|_LED_1_Start|_wPWM16_1_ReadPulseWidth|LED_1_On|LED_1_Stop|_LED_1_Stop|LED_1_Off
(0044) 	CH0_OUT_Start();
    19F9: 7C 05 A9 LCALL CH0_OUT_Off|_CH0_OUT_Start|CH0_OUT_Stop|_CH0_OUT_Off|CH1_OUT_GetState|CH0_OUT_On|CH0_OUT_Start|_CH0_OUT_Stop|CH1_OUT_Invert
(0045) 	CH1_OUT_Start();
    19FC: 7C 05 96 LCALL CH2_OUT_GetState|_CH1_OUT_Off|_CH1_OUT_Stop|CH1_OUT_On|CH1_OUT_Off|CH2_OUT_Invert|CH1_OUT_Stop|_CH1_OUT_Start|CH1_OUT_Start
(0046) 	CH2_OUT_Start();
    19FF: 7C 05 83 LCALL _CH2_OUT_Start|CH2_OUT_Off|CH2_OUT_Start|CH2_OUT_Stop|CH3_OUT_GetState|_CH2_OUT_Off|CH3_OUT_Invert|_CH2_OUT_Stop|CH2_OUT_On
(0047) 	CH3_OUT_Start();
    1A02: 7C 05 70 LCALL CH4_OUT_GetState|CH4_OUT_Invert|CH3_OUT_Stop|_CH3_OUT_Start|CH3_OUT_On|_CH3_OUT_Stop|_CH3_OUT_Off|CH3_OUT_Off|CH3_OUT_Start
(0048) 	CH4_OUT_Start();
    1A05: 7C 05 5D LCALL CH4_OUT_Off|_CH4_OUT_Stop|CH5_OUT_GetState|CH4_OUT_Start|CH5_OUT_Invert|CH4_OUT_On|CH4_OUT_Stop|_CH4_OUT_Start|_CH4_OUT_Off
(0049) 	CH5_OUT_Start();
    1A08: 7C 05 4A LCALL _CH5_OUT_Off|CS_PIN_GetState|CH5_OUT_On|CH5_OUT_Start|CH5_OUT_Stop|_CH5_OUT_Stop|CS_PIN_Invert|CH5_OUT_Off|_CH5_OUT_Start
    1A0B: 20       POP   X
(0050) 	Timer_init();
    1A0C: 7C 1D 81 LCALL _Timer_init
(0051) 	DSM_Init();
    1A0F: 7C 14 DA LCALL _DSM_Init
(0052) 
(0053) #ifndef DEBUG
(0054) 	E2PROM_1_Start();
    1A12: 10       PUSH  X
    1A13: 7C 05 1B LCALL LED_1_Invert|E2PROM_1_Start|_E2PROM_1_Start|LED_1_GetState
    1A16: 20       POP   X
(0055) #endif
(0056) 
(0057) 
(0058) Bind=(Bind_Port_Data_ADDR&Bind_Port_MASK)?FALSE:TRUE;
    1A17: 5D 0C    MOV   A,REG[0xC]
    1A19: 53 17    MOV   [__r0],A
    1A1B: 47 17 04 TST   [__r0],0x4
    1A1E: A0 09    JZ    0x1A28
    1A20: 56 02 00 MOV   [X+2],0x0
    1A23: 56 01 00 MOV   [X+1],0x0
    1A26: 80 07    JMP   0x1A2E
    1A28: 56 02 01 MOV   [X+2],0x1
    1A2B: 56 01 00 MOV   [X+1],0x0
    1A2E: 52 02    MOV   A,[X+2]
    1A30: 54 00    MOV   [X+0],A
(0059) Bind=Bind||!ReadConfig(&config,sizeof (config_s));	
    1A32: 3D 00 00 CMP   [X+0],0x0
    1A35: B0 13    JNZ   0x1A49
    1A37: 50 16    MOV   A,0x16
    1A39: 08       PUSH  A
    1A3A: 50 00    MOV   A,0x0
    1A3C: 08       PUSH  A
    1A3D: 50 73    MOV   A,0x73
    1A3F: 08       PUSH  A
    1A40: 7C 0A 08 LCALL _ReadConfig
    1A43: 38 FD    ADD   SP,0xFD
    1A45: 39 00    CMP   A,0x0
    1A47: B0 09    JNZ   0x1A51
    1A49: 56 04 01 MOV   [X+4],0x1
    1A4C: 56 03 00 MOV   [X+3],0x0
    1A4F: 80 07    JMP   0x1A57
    1A51: 56 04 00 MOV   [X+4],0x0
    1A54: 56 03 00 MOV   [X+3],0x0
    1A57: 52 04    MOV   A,[X+4]
    1A59: 54 00    MOV   [X+0],A
(0060) 	
(0061) 
(0062) if (Bind)
    1A5B: 3D 00 00 CMP   [X+0],0x0
    1A5E: A0 E1    JZ    0x1B40
(0063) 	{
(0064) 	BYTE n=0;
    1A60: 56 05 00 MOV   [X+5],0x0
(0065) 	DSM_initialize_bind();
    1A63: 7C 15 16 LCALL _DSM_initialize_bind
(0066) 	do
(0067) 		{
(0068) 		if (LV_Detect)	
    1A66: 3C 04 00 CMP   [LV_Detect],0x0
    1A69: A0 31    JZ    0x1A9B
(0069) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x340)==0x340?1:0);
    1A6B: 10       PUSH  X
    1A6C: 7C 04 CA LCALL _SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTimer|SleepTimer_1_iGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_SyncWait|_SleepTimer_1_bGetTickCntr
    1A6F: 5A 17    MOV   [__r0],X
    1A71: 53 16    MOV   [__r1],A
    1A73: 20       POP   X
    1A74: 26 16 40 AND   [__r1],0x40
    1A77: 26 17 03 AND   [__r0],0x3
    1A7A: 3C 17 03 CMP   [__r0],0x3
    1A7D: B0 0E    JNZ   0x1A8C
    1A7F: 3C 16 40 CMP   [__r1],0x40
    1A82: B0 09    JNZ   0x1A8C
    1A84: 56 07 01 MOV   [X+7],0x1
    1A87: 56 06 00 MOV   [X+6],0x0
    1A8A: 80 07    JMP   0x1A92
    1A8C: 56 07 00 MOV   [X+7],0x0
    1A8F: 56 06 00 MOV   [X+6],0x0
    1A92: 52 07    MOV   A,[X+7]
    1A94: 10       PUSH  X
    1A95: 7C 05 0A LCALL _LED_1_Switch
    1A98: 20       POP   X
    1A99: 80 66    JMP   0x1B00
(0070) 		else if (DSM_BIND_WAIT())
    1A9B: 3C 8B 02 CMP   [State],0x2
    1A9E: D0 31    JNC   0x1AD0
(0071) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x100)==0x100?1:0);
    1AA0: 10       PUSH  X
    1AA1: 7C 04 CA LCALL _SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTimer|SleepTimer_1_iGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_SyncWait|_SleepTimer_1_bGetTickCntr
    1AA4: 5A 17    MOV   [__r0],X
    1AA6: 53 16    MOV   [__r1],A
    1AA8: 20       POP   X
    1AA9: 26 16 00 AND   [__r1],0x0
    1AAC: 26 17 01 AND   [__r0],0x1
    1AAF: 3C 17 01 CMP   [__r0],0x1
    1AB2: B0 0E    JNZ   0x1AC1
    1AB4: 3C 16 00 CMP   [__r1],0x0
    1AB7: B0 09    JNZ   0x1AC1
    1AB9: 56 09 01 MOV   [X+9],0x1
    1ABC: 56 08 00 MOV   [X+8],0x0
    1ABF: 80 07    JMP   0x1AC7
    1AC1: 56 09 00 MOV   [X+9],0x0
    1AC4: 56 08 00 MOV   [X+8],0x0
    1AC7: 52 09    MOV   A,[X+9]
    1AC9: 10       PUSH  X
    1ACA: 7C 05 0A LCALL _LED_1_Switch
    1ACD: 20       POP   X
    1ACE: 80 31    JMP   0x1B00
(0072) 		else if (DSM_BIND_ACK())
    1AD0: 3C 8B 03 CMP   [State],0x3
    1AD3: C0 2C    JC    0x1B00
(0073) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x40)==0x40?1:0);
    1AD5: 10       PUSH  X
    1AD6: 7C 04 CA LCALL _SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTimer|SleepTimer_1_iGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_SyncWait|_SleepTimer_1_bGetTickCntr
    1AD9: 5A 17    MOV   [__r0],X
    1ADB: 53 16    MOV   [__r1],A
    1ADD: 20       POP   X
    1ADE: 26 16 40 AND   [__r1],0x40
    1AE1: 26 17 00 AND   [__r0],0x0
    1AE4: B0 0E    JNZ   0x1AF3
    1AE6: 3C 16 40 CMP   [__r1],0x40
    1AE9: B0 09    JNZ   0x1AF3
    1AEB: 56 0B 01 MOV   [X+11],0x1
    1AEE: 56 0A 00 MOV   [X+10],0x0
    1AF1: 80 07    JMP   0x1AF9
    1AF3: 56 0B 00 MOV   [X+11],0x0
    1AF6: 56 0A 00 MOV   [X+10],0x0
    1AF9: 52 0B    MOV   A,[X+11]
    1AFB: 10       PUSH  X
    1AFC: 7C 05 0A LCALL _LED_1_Switch
    1AFF: 20       POP   X
(0074) 		DSM_Cyclic();
    1B00: 7C 11 7D LCALL _DSM_Cyclic
(0075) 		}
(0076) 	//wait till binding is done
(0077) 	while(!DSM_BIND_DONE());
    1B03: 3C 8B 0B CMP   [State],0xB
    1B06: CF 5F    JC    0x1A66
(0078) 	
(0079) 	do 	//wait for stable
(0080) 		{
(0081) 			if (new_data)
    1B08: 3C 8A 00 CMP   [new_data],0x0
    1B0B: A0 06    JZ    0x1B12
(0082) 				{
(0083) 				new_data=0;	
    1B0D: 55 8A 00 MOV   [new_data],0x0
(0084) 				n++;	
    1B10: 77 05    INC   [X+5]
(0085) 				}
(0086) 		DSM_Cyclic();
    1B12: 7C 11 7D LCALL _DSM_Cyclic
(0087) 		}
(0088) 	while (n<5);
    1B15: 3D 05 05 CMP   [X+5],0x5
    1B18: CF EF    JC    0x1B08
(0089) 		
(0090) 	//save falisave position
(0091) 	if(Bind_Port_Data_ADDR&Bind_Port_MASK)
    1B1A: 5D 0C    MOV   A,REG[0xC]
    1B1C: 53 17    MOV   [__r0],A
    1B1E: 47 17 04 TST   [__r0],0x4
    1B21: A0 04    JZ    0x1B26
(0092) 	{
(0093) 			DSM_Save_Failsafe_Presets();
    1B23: 7C 19 67 LCALL _DSM_Save_Failsafe_Presets
(0094) 	}
(0095) 	
(0096) 
(0097) 	//save configuration to FLASH
(0098) 	Timer_Stop();
    1B26: 10       PUSH  X
    1B27: 7C 04 7D LCALL _Timer8_1_Stop
    1B2A: 20       POP   X
(0099) 	SaveConfig(&config,sizeof (config_s));
    1B2B: 50 16    MOV   A,0x16
    1B2D: 08       PUSH  A
    1B2E: 50 00    MOV   A,0x0
    1B30: 08       PUSH  A
    1B31: 50 73    MOV   A,0x73
    1B33: 08       PUSH  A
    1B34: 7C 09 A9 LCALL _FlashReadBlock|__UserModules_end|__text_start|_SaveConfig|_SaveConfig
    1B37: 38 FD    ADD   SP,0xFD
(0100) 	Timer_Start();
    1B39: 10       PUSH  X
    1B3A: 7C 04 79 LCALL _Timer8_1_Start|_Timer8_1_DisableInt|Timer8_1_Start
    1B3D: 20       POP   X
(0101) 	}
    1B3E: 80 12    JMP   0x1B51
(0102) 	else 
(0103) 	{
(0104) 		DSM_initialize_Recive();	
    1B40: 7C 0F CB LCALL _DSM_initialize_Recive
(0105) 		do 
(0106) 		{
(0107) 			Rcv_Timeout=FALSE;
    1B43: 55 89 00 MOV   [Rcv_Timeout],0x0
(0108) 			new_data=FALSE;	
    1B46: 55 8A 00 MOV   [new_data],0x0
(0109) 			DSM_Cyclic();
    1B49: 7C 11 7D LCALL _DSM_Cyclic
(0110) 		}while (!DSM_INSYNC());
    1B4C: 3C 8B 0B CMP   [State],0xB
    1B4F: CF F3    JC    0x1B43
(0111) 	}
(0112) 		do
(0113) 			{
(0114) 			DSM_Cyclic();
    1B51: 7C 11 7D LCALL _DSM_Cyclic
(0115) 			if (LV_Detect)	
    1B54: 3C 04 00 CMP   [LV_Detect],0x0
    1B57: A0 31    JZ    0x1B89
(0116) 				LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x340)==0x340?1:0);
    1B59: 10       PUSH  X
    1B5A: 7C 04 CA LCALL _SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTimer|SleepTimer_1_iGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_SyncWait|_SleepTimer_1_bGetTickCntr
    1B5D: 5A 17    MOV   [__r0],X
    1B5F: 53 16    MOV   [__r1],A
    1B61: 20       POP   X
    1B62: 26 16 40 AND   [__r1],0x40
    1B65: 26 17 03 AND   [__r0],0x3
    1B68: 3C 17 03 CMP   [__r0],0x3
    1B6B: B0 0E    JNZ   0x1B7A
    1B6D: 3C 16 40 CMP   [__r1],0x40
    1B70: B0 09    JNZ   0x1B7A
    1B72: 56 06 01 MOV   [X+6],0x1
    1B75: 56 05 00 MOV   [X+5],0x0
    1B78: 80 07    JMP   0x1B80
    1B7A: 56 06 00 MOV   [X+6],0x0
    1B7D: 56 05 00 MOV   [X+5],0x0
    1B80: 52 06    MOV   A,[X+6]
    1B82: 10       PUSH  X
    1B83: 7C 05 0A LCALL _LED_1_Switch
    1B86: 20       POP   X
    1B87: 80 1B    JMP   0x1BA3
(0117) 			else	
(0118) 				LED_1_Switch(DSM_INSYNC());
    1B89: 3C 8B 0B CMP   [State],0xB
    1B8C: C0 09    JC    0x1B96
    1B8E: 56 08 01 MOV   [X+8],0x1
    1B91: 56 07 00 MOV   [X+7],0x0
    1B94: 80 07    JMP   0x1B9C
    1B96: 56 08 00 MOV   [X+8],0x0
    1B99: 56 07 00 MOV   [X+7],0x0
    1B9C: 52 08    MOV   A,[X+8]
    1B9E: 10       PUSH  X
    1B9F: 7C 05 0A LCALL _LED_1_Switch
    1BA2: 20       POP   X
(0119) 			if (Rcv_Timeout)
    1BA3: 3C 89 00 CMP   [Rcv_Timeout],0x0
    1BA6: A0 0A    JZ    0x1BB1
(0120) 			{
(0121) 				DSM_Load_FS_Data();
    1BA8: 7C 19 9D LCALL _DSM_Load_FS_Data
(0122) 				Rcv_Timeout=FALSE;
    1BAB: 55 89 00 MOV   [Rcv_Timeout],0x0
(0123) 				new_data=TRUE;
    1BAE: 55 8A 01 MOV   [new_data],0x1
(0124) 			}
(0125) 			if (PPM_IS_PPM_DONE())
    1BB1: 3C 06 00 CMP   [ppm_Run],0x0
    1BB4: B0 0C    JNZ   0x1BC1
(0126) 				{
(0127) 				if (new_data)
    1BB6: 3C 8A 00 CMP   [new_data],0x0
    1BB9: A0 07    JZ    0x1BC1
(0128) 					{
(0129) 					new_data=FALSE;	
    1BBB: 55 8A 00 MOV   [new_data],0x0
(0130) 					PPM_START_ONE_PPM_TRAIN();
    1BBE: 7C 1C 9C LCALL _PPM_Start_One_PPM_Train
(0131) 					}
(0132) 				}
(0133) 			}
(0134) 		while (1);	
    1BC1: 8F 8F    JMP   0x1B51
    1BC3: 38 F4    ADD   SP,0xF4
    1BC5: 20       POP   X
    1BC6: 8F FF    JMP   0x1BC6
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\ppm.c
(0001) /*
(0002) *PPM.C
(0003) *A 16 Bit PWM module  is used to gennerate the PPM train
(0004) *The PWM actually gennerates an inverted CPPM __|_|_|_|_|_|_|_|_|___|_|_|_|_|_|_|_|_|___|_
(0005) *this has the advantage that the pulse width can stay constant, only the periode has to be changed
(0006) *on everey compare match interrupt the periode value for the next chanel is loaded
(0007) *the last chanal value has an extra large value and is used to gennerate the sync gap
(0008) */
(0009) 
(0010) #include <m8c.h>        // part specific constants and macros
(0011) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0012) #include "config.h"
(0013) #include "ppm.h"
(0014) 
(0015) //#define DEBUG
(0016) 
(0017) volatile BYTE ppm_Nr=0;//the chanal counter
(0018) volatile BOOL ppm_Run=0;//start one pulse train
(0019) BOOL TC_IRQ;
(0020) 
(0021) #define PWM_TC_IRQ 0x31;
(0022) #define PWM_CM_IRQ 0x39;
(0023) //initialize PPM output
(0024) void ppm_Init(void )
(0025) {
_ppm_Init:
  n                    --> X+0
    1BC8: 10       PUSH  X
    1BC9: 4F       MOV   X,SP
    1BCA: 38 02    ADD   SP,0x2
(0026) 	
(0027) int n;
(0028) 	//Init PPM_DATA array
(0029) 	for (n=0;n<PPM_PULSE_COUNT;n++)
    1BCC: 56 01 00 MOV   [X+1],0x0
    1BCF: 56 00 00 MOV   [X+0],0x0
(0030) 	{	//set to center
(0031) 		ppm_Data[n]=PPM_OUT_CENTER_LEN;
    1BD2: 52 01    MOV   A,[X+1]
    1BD4: 64       ASL   A
    1BD5: 01 65    ADD   A,0x65
    1BD7: 53 16    MOV   [__r1],A
    1BD9: 50 0B    MOV   A,0xB
    1BDB: 3F 16    MVI   [__r1],A
    1BDD: 50 B8    MOV   A,0xB8
    1BDF: 3F 16    MVI   [__r1],A
(0032) 	}
    1BE1: 77 01    INC   [X+1]
    1BE3: 0F 00 00 ADC   [X+0],0x0
    1BE6: 52 01    MOV   A,[X+1]
    1BE8: 11 07    SUB   A,0x7
    1BEA: 52 00    MOV   A,[X+0]
    1BEC: 31 80    XOR   A,0x80
    1BEE: 19 80    SBB   A,0x80
    1BF0: CF E1    JC    0x1BD2
(0033) 	//enable compare match interrupt of the PWM
(0034) 	PWM16_1_EnableInt();
    1BF2: 10       PUSH  X
    1BF3: 7C 04 F0 LCALL _PWM16_1_EnableInt
(0035) 	//pulse widht is actually the small gap between the PPM pulses
(0036) 	PWM16_1_WritePulseWidth(PPM_OUT_PULSE_GAP_LEN_US);
    1BF6: 57 01    MOV   X,0x1
    1BF8: 50 90    MOV   A,0x90
    1BFA: 7C 05 02 LCALL _PWM16_1_WritePulseWidth
    1BFD: 20       POP   X
(0037) 	//disconnect the PIN from the PWM and  set the pin to High
(0038) 	PPM_DISCON_SET_OUT_PIN_HIGH;
    1BFE: 43 B4 0F OR    REG[0xB4],0xF
(0039) 	//init pulse counter, will loop thru the cannels
(0040) 	ppm_Nr=0;		
    1C01: 55 05 00 MOV   [ppm_Nr],0x0
(0041) 	TC_IRQ=TRUE;
    1C04: 55 8E 01 MOV   [TC_IRQ],0x1
(0042) 	PWM16_1_FUNC_MSB_REG=PWM_TC_IRQ;
    1C07: 71 10    OR    F,0x10
    1C09: 62 24 31 MOV   REG[0x24],0x31
(0043) 	//set a initial pulse len, just to have somthing in ther will be change in the interrupt service
(0044) 	PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN);
    1C0C: 10       PUSH  X
    1C0D: 57 17    MOV   X,0x17
    1C0F: 50 70    MOV   A,0x70
    1C11: 70 CF    AND   F,0xCF
    1C13: 7C 04 FC LCALL _PWM16_1_WritePeriod
    1C16: 20       POP   X
    1C17: 38 FE    ADD   SP,0xFE
    1C19: 20       POP   X
    1C1A: 7F       RET   
(0045) }//END OFF ppm_Init
(0046) 
(0047) void Switch_LED(BYTE val)
(0048) {
_Switch_LED:
  val                  --> X-4
    1C1B: 10       PUSH  X
    1C1C: 4F       MOV   X,SP
    1C1D: 38 02    ADD   SP,0x2
(0049) #ifndef DEBUG	
(0050) 	switch (ppm_Nr)
    1C1F: 51 05    MOV   A,[ppm_Nr]
    1C21: 54 01    MOV   [X+1],A
    1C23: 56 00 00 MOV   [X+0],0x0
    1C26: 3D 00 00 CMP   [X+0],0x0
    1C29: B0 06    JNZ   0x1C30
    1C2B: 3D 01 02 CMP   [X+1],0x2
    1C2E: A0 35    JZ    0x1C64
    1C30: 3D 00 00 CMP   [X+0],0x0
    1C33: B0 06    JNZ   0x1C3A
    1C35: 3D 01 03 CMP   [X+1],0x3
    1C38: A0 34    JZ    0x1C6D
    1C3A: 3D 00 00 CMP   [X+0],0x0
    1C3D: B0 06    JNZ   0x1C44
    1C3F: 3D 01 04 CMP   [X+1],0x4
    1C42: A0 33    JZ    0x1C76
    1C44: 3D 00 00 CMP   [X+0],0x0
    1C47: B0 06    JNZ   0x1C4E
    1C49: 3D 01 05 CMP   [X+1],0x5
    1C4C: A0 32    JZ    0x1C7F
    1C4E: 3D 00 00 CMP   [X+0],0x0
    1C51: B0 06    JNZ   0x1C58
    1C53: 3D 01 06 CMP   [X+1],0x6
    1C56: A0 31    JZ    0x1C88
    1C58: 3D 00 00 CMP   [X+0],0x0
    1C5B: B0 06    JNZ   0x1C62
    1C5D: 3D 01 07 CMP   [X+1],0x7
    1C60: A0 30    JZ    0x1C91
    1C62: 80 35    JMP   0x1C98
(0051) 	{
(0052) 		case 2:
(0053) 		{
(0054) 			CH0_OUT_Switch(val);
    1C64: 10       PUSH  X
    1C65: 52 FC    MOV   A,[X-4]
    1C67: 7C 05 AB LCALL _CH0_OUT_Switch
    1C6A: 20       POP   X
(0055) 		}
(0056) 		break;
    1C6B: 80 2C    JMP   0x1C98
(0057) 		case 3:
(0058) 		{
(0059) 			CH1_OUT_Switch(val);
    1C6D: 10       PUSH  X
    1C6E: 52 FC    MOV   A,[X-4]
    1C70: 7C 05 98 LCALL _CH1_OUT_Switch
    1C73: 20       POP   X
(0060) 		}
(0061) 		break;
    1C74: 80 23    JMP   0x1C98
(0062) 		case 4:
(0063) 		{
(0064) 			CH2_OUT_Switch(val);
    1C76: 10       PUSH  X
    1C77: 52 FC    MOV   A,[X-4]
    1C79: 7C 05 85 LCALL _CH2_OUT_Switch
    1C7C: 20       POP   X
(0065) 		}
(0066) 		break;
    1C7D: 80 1A    JMP   0x1C98
(0067) 		case 5:
(0068) 		{
(0069) 			CH3_OUT_Switch(val);
    1C7F: 10       PUSH  X
    1C80: 52 FC    MOV   A,[X-4]
    1C82: 7C 05 72 LCALL _CH3_OUT_Switch
    1C85: 20       POP   X
(0070) 		}
(0071) 		break;
    1C86: 80 11    JMP   0x1C98
(0072) 		case 6:
(0073) 		{
(0074) 			CH4_OUT_Switch(val);
    1C88: 10       PUSH  X
    1C89: 52 FC    MOV   A,[X-4]
    1C8B: 7C 05 5F LCALL _CH4_OUT_Switch
    1C8E: 20       POP   X
(0075) 		}
(0076) 		break;
    1C8F: 80 08    JMP   0x1C98
(0077) 		case 7:
(0078) 		{
(0079) 			CH5_OUT_Switch(val);
    1C91: 10       PUSH  X
    1C92: 52 FC    MOV   A,[X-4]
    1C94: 7C 05 4C LCALL _CH5_OUT_Switch
    1C97: 20       POP   X
(0080) 		}
(0081) 		break;
    1C98: 38 FE    ADD   SP,0xFE
    1C9A: 20       POP   X
    1C9B: 7F       RET   
(0082) 	}
(0083) #endif
(0084) }
(0085) 
(0086) void PPM_Start_One_PPM_Train(void )
(0087) {
(0088) 	ppm_Run=TRUE;
_PPM_Start_One_PPM_Train:
    1C9C: 55 06 01 MOV   [ppm_Run],0x1
(0089) 	PPM_RECON_OUT_PIN;	//reconect i/O PIN to PWM
    1C9F: 41 B4 FC AND   REG[0xB4],0xFC
(0090) 	ppm_Nr=1;//reset counter
    1CA2: 55 05 01 MOV   [ppm_Nr],0x1
(0091) 	PWM16_1_WritePeriod(ppm_Data[0]+PPM_OUT_PULSE_GAP_LEN_US);//load pulse len of first channel
    1CA5: 51 66    MOV   A,[ppm_Data+1]
    1CA7: 01 90    ADD   A,0x90
    1CA9: 53 16    MOV   [__r1],A
    1CAB: 51 65    MOV   A,[ppm_Data]
    1CAD: 09 01    ADC   A,0x1
    1CAF: 10       PUSH  X
    1CB0: 08       PUSH  A
    1CB1: 51 16    MOV   A,[__r1]
    1CB3: 20       POP   X
    1CB4: 7C 04 FC LCALL _PWM16_1_WritePeriod
(0092) 	//start the PWM Module
(0093) 	PWM16_1_Start();
    1CB7: 7C 04 F4 LCALL _PWM16_1_DisableInt|PWM16_1_Start|_PWM16_1_Start
    1CBA: 20       POP   X
    1CBB: 7F       RET   
(0094) }
(0095) 
(0096) /*inerrupt service routine for the PWM module
(0097) *will be called on TC
(0098) *-load pulse len of the next PPM pulse
(0099) *- increase pulse counter
(0100) */
(0101) #pragma interrupt_handler PWM16_1_CMP_ISR
(0102) void PWM16_1_CMP_ISR(void )
(0103) {
_PWM16_1_CMP_ISR:
    1CBC: 08       PUSH  A
    1CBD: 51 17    MOV   A,[__r0]
    1CBF: 08       PUSH  A
    1CC0: 51 16    MOV   A,[__r1]
    1CC2: 08       PUSH  A
    1CC3: 51 15    MOV   A,[__r2]
    1CC5: 08       PUSH  A
    1CC6: 51 14    MOV   A,[__r3]
    1CC8: 08       PUSH  A
    1CC9: 51 13    MOV   A,[__r4]
    1CCB: 08       PUSH  A
    1CCC: 51 12    MOV   A,[__r5]
    1CCE: 08       PUSH  A
    1CCF: 51 11    MOV   A,[__r6]
    1CD1: 08       PUSH  A
    1CD2: 51 10    MOV   A,[__r7]
    1CD4: 08       PUSH  A
    1CD5: 51 0F    MOV   A,[__r8]
    1CD7: 08       PUSH  A
    1CD8: 51 0E    MOV   A,[__r9]
    1CDA: 08       PUSH  A
    1CDB: 51 0D    MOV   A,[__r10]
    1CDD: 08       PUSH  A
    1CDE: 51 0C    MOV   A,[__r11]
    1CE0: 08       PUSH  A
    1CE1: 51 0B    MOV   A,[__rX]
    1CE3: 08       PUSH  A
    1CE4: 51 0A    MOV   A,[__rY]
    1CE6: 08       PUSH  A
    1CE7: 51 09    MOV   A,[__rZ]
    1CE9: 08       PUSH  A
(0104) 	if (TC_IRQ)
    1CEA: 3C 8E 00 CMP   [TC_IRQ],0x0
    1CED: A0 53    JZ    0x1D41
(0105) 	{
(0106) 		//Sync is send out we are done 
(0107) 		if (ppm_Nr==PPM_PULSE_COUNT+2) 
    1CEF: 3C 05 09 CMP   [ppm_Nr],0x9
    1CF2: B0 0B    JNZ   0x1CFE
(0108) 			{ //we are done 
(0109) 				PWM16_1_Stop();
    1CF4: 10       PUSH  X
    1CF5: 7C 04 F8 LCALL _PWM16_1_Stop
    1CF8: 20       POP   X
(0110) 				ppm_Run=0;		//signal that we are done
    1CF9: 55 06 00 MOV   [ppm_Run],0x0
(0111) 			}
    1CFC: 80 2F    JMP   0x1D2C
(0112) 		else if (ppm_Nr==PPM_PULSE_COUNT+1) 
    1CFE: 3C 05 08 CMP   [ppm_Nr],0x8
    1D01: B0 06    JNZ   0x1D08
(0113) 			{ //we are done 
(0114) 				PPM_DISCON_SET_OUT_PIN_HIGH;	//disconect IO pin from PWM and set to High
    1D03: 43 B4 0F OR    REG[0xB4],0xF
(0115) 			}
    1D06: 80 25    JMP   0x1D2C
(0116) 		//load pulse len of next chanal
(0117) 		else 
(0118) 		{	//check if that is the last chanel is done
(0119) 			if(ppm_Nr==PPM_PULSE_COUNT)
    1D08: 3C 05 07 CMP   [ppm_Nr],0x7
    1D0B: B0 0C    JNZ   0x1D18
(0120) 			{
(0121) 				PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN); 
    1D0D: 10       PUSH  X
    1D0E: 57 17    MOV   X,0x17
    1D10: 50 70    MOV   A,0x70
    1D12: 7C 04 FC LCALL _PWM16_1_WritePeriod
    1D15: 20       POP   X
(0122) 			}
    1D16: 80 15    JMP   0x1D2C
(0123) 			else 
(0124) 			{
(0125) 				PWM16_1_WritePeriod(ppm_Data[ppm_Nr]+PPM_OUT_PULSE_GAP_LEN_US);//load pulse len of the next pulse
    1D18: 5F 16 05 MOV   [__r1],[ppm_Nr]
    1D1B: 92 8A    CALL  0x1FA7
    1D1D: 40       NOP   
    1D1E: 01 90    ADD   A,0x90
    1D20: 53 16    MOV   [__r1],A
    1D22: 0E 17 01 ADC   [__r0],0x1
    1D25: 10       PUSH  X
    1D26: 58 17    MOV   X,[__r0]
    1D28: 7C 04 FC LCALL _PWM16_1_WritePeriod
    1D2B: 20       POP   X
(0126) 			}
(0127) 		}
(0128) 		ppm_Nr++;
    1D2C: 76 05    INC   [ppm_Nr]
(0129) 		Switch_LED(TRUE);
    1D2E: 50 01    MOV   A,0x1
    1D30: 08       PUSH  A
    1D31: 9E E8    CALL  _Switch_LED
    1D33: 38 FF    ADD   SP,0xFF
(0130) 		TC_IRQ=FALSE;
    1D35: 55 8E 00 MOV   [TC_IRQ],0x0
(0131) 		PWM16_1_FUNC_MSB_REG=PWM_CM_IRQ;
    1D38: 71 10    OR    F,0x10
    1D3A: 62 24 39 MOV   REG[0x24],0x39
(0132) 	}
    1D3D: 70 CF    AND   F,0xCF
    1D3F: 80 12    JMP   0x1D52
(0133) 	else 
(0134) 	{
(0135) 		Switch_LED(FALSE);
    1D41: 50 00    MOV   A,0x0
    1D43: 08       PUSH  A
    1D44: 9E D5    CALL  _Switch_LED
    1D46: 38 FF    ADD   SP,0xFF
(0136) 		TC_IRQ=TRUE;
    1D48: 55 8E 01 MOV   [TC_IRQ],0x1
(0137) 		PWM16_1_FUNC_MSB_REG=PWM_TC_IRQ;
    1D4B: 71 10    OR    F,0x10
    1D4D: 62 24 31 MOV   REG[0x24],0x31
(0138) 	}
    1D50: 70 CF    AND   F,0xCF
(0139) }//END OFF PWM16_1_CMP_ISR
(0140) 
FILE: E:\WORKSP~1\cypress\DSM_RE~1\DSM_RE~1\timer.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "timer.h"
(0003) 
(0004) //WORD systic=0;   //will be incremented once per 1,953125 ms
(0005) WORD cnt_last;
(0006) tmr_callback_t timer_cb=0;
(0007) 
(0008) 
(0009) 
(0010) 
(0011) void Timer_init (void)
(0012) {
(0013) timer_cb=0;
_Timer_init:
    1D81: 55 08 20 MOV   [timer_cb+1],0x20
    1D84: 55 07 03 MOV   [timer_cb],0x3
(0014) SleepTimer_1_EnableInt();
    1D87: 10       PUSH  X
    1D88: 7C 04 AA LCALL _SleepTimer_1_EnableInt
(0015) SleepTimer_1_Start();
    1D8B: 7C 04 AE LCALL _SleepTimer_1_DisableInt|_SleepTimer_1_Start|SleepTimer_1_Start
(0016) Timer8_1_EnableInt();
    1D8E: 7C 04 75 LCALL _Timer8_1_EnableInt
    1D91: 20       POP   X
    1D92: 7F       RET   
(0017) }
(0018) 
(0019) 
(0020) 
(0021) 
(0022) void Timer_SetCallback(tmr_callback_t cb_fn)
(0023) {
_Timer_SetCallback:
  cb_fn                --> X-5
    1D93: 10       PUSH  X
    1D94: 4F       MOV   X,SP
(0024) 	timer_cb=cb_fn;
    1D95: 52 FC    MOV   A,[X-4]
    1D97: 53 08    MOV   [timer_cb+1],A
    1D99: 52 FB    MOV   A,[X-5]
    1D9B: 53 07    MOV   [timer_cb],A
    1D9D: 20       POP   X
    1D9E: 7F       RET   
(0025) }
(0026) 
(0027) //#pragma interrupt_handler Sleep_Timer_Interrupt
(0028) 
(0029) /*/interrupt handler on TC of LSB
(0030) /void Sleep_Timer_Interrupt(void )
(0031) {
(0032) 	systic++;
(0033) }*/
(0034) 
(0035) #pragma interrupt_handler Timer8_1_Interrupt
(0036) 
(0037) void Timer8_1_Interrupt(void)
(0038) {
_Timer8_1_Interrupt:
    1D9F: 08       PUSH  A
    1DA0: 51 17    MOV   A,[__r0]
    1DA2: 08       PUSH  A
    1DA3: 51 16    MOV   A,[__r1]
    1DA5: 08       PUSH  A
    1DA6: 51 15    MOV   A,[__r2]
    1DA8: 08       PUSH  A
    1DA9: 51 14    MOV   A,[__r3]
    1DAB: 08       PUSH  A
    1DAC: 51 13    MOV   A,[__r4]
    1DAE: 08       PUSH  A
    1DAF: 51 12    MOV   A,[__r5]
    1DB1: 08       PUSH  A
    1DB2: 51 11    MOV   A,[__r6]
    1DB4: 08       PUSH  A
    1DB5: 51 10    MOV   A,[__r7]
    1DB7: 08       PUSH  A
    1DB8: 51 0F    MOV   A,[__r8]
    1DBA: 08       PUSH  A
    1DBB: 51 0E    MOV   A,[__r9]
    1DBD: 08       PUSH  A
    1DBE: 51 0D    MOV   A,[__r10]
    1DC0: 08       PUSH  A
    1DC1: 51 0C    MOV   A,[__r11]
    1DC3: 08       PUSH  A
    1DC4: 51 0B    MOV   A,[__rX]
    1DC6: 08       PUSH  A
    1DC7: 51 0A    MOV   A,[__rY]
    1DC9: 08       PUSH  A
    1DCA: 51 09    MOV   A,[__rZ]
    1DCC: 08       PUSH  A
(0039) 	if(timer_cb!=0)
    1DCD: 5F 16 08 MOV   [__r1],[timer_cb+1]
    1DD0: 51 07    MOV   A,[timer_cb]
    1DD2: 10       PUSH  X
    1DD3: 58 16    MOV   X,[__r1]
    1DD5: 08       PUSH  A
    1DD6: 28       ROMX  
    1DD7: 53 17    MOV   [__r0],A
    1DD9: 18       POP   A
    1DDA: 75       INC   X
    1DDB: 09 00    ADC   A,0x0
    1DDD: 28       ROMX  
    1DDE: 20       POP   X
    1DDF: 3C 17 00 CMP   [__r0],0x0
    1DE2: B0 05    JNZ   0x1DE8
    1DE4: 39 00    CMP   A,0x0
    1DE6: A0 10    JZ    0x1DF7
(0040) 		timer_cb();
    1DE8: 5F 16 08 MOV   [__r1],[timer_cb+1]
    1DEB: 5F 17 07 MOV   [__r0],[timer_cb]
    1DEE: 10       PUSH  X
    1DEF: 58 16    MOV   X,[__r1]
    1DF1: 51 17    MOV   A,[__r0]
    1DF3: 7C 1F 8E LCALL __plcall
    1DF6: 20       POP   X
    1DF7: 18       POP   A
    1DF8: 53 09    MOV   [__rZ],A
    1DFA: 18       POP   A
    1DFB: 53 0A    MOV   [__rY],A
    1DFD: 18       POP   A
    1DFE: 53 0B    MOV   [__rX],A
    1E00: 18       POP   A
    1E01: 53 0C    MOV   [__r11],A
    1E03: 18       POP   A
    1E04: 53 0D    MOV   [__r10],A
    1E06: 18       POP   A
    1E07: 53 0E    MOV   [__r9],A
    1E09: 18       POP   A
    1E0A: 53 0F    MOV   [__r8],A
    1E0C: 18       POP   A
    1E0D: 53 10    MOV   [__r7],A
    1E0F: 18       POP   A
    1E10: 53 11    MOV   [__r6],A
    1E12: 18       POP   A
    1E13: 53 12    MOV   [__r5],A
    1E15: 18       POP   A
    1E16: 53 13    MOV   [__r4],A
    1E18: 18       POP   A
    1E19: 53 14    MOV   [__r3],A
    1E1B: 18       POP   A
    1E1C: 53 15    MOV   [__r2],A
    1E1E: 18       POP   A
    1E1F: 53 16    MOV   [__r1],A
    1E21: 18       POP   A
    1E22: 53 17    MOV   [__r0],A
    1E24: 18       POP   A
    1E25: 7E       RETI  
FILE: lib\psocgpioint.asm               (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
1E26: 7D 0A 55 LJMP  _GPIO_ISR          (0059)    ljmp _GPIO_ISR
                                        (0060)    ;---------------------------------------------------
                                        (0061)    ; Insert your custom code above this banner
                                        (0062)    ;---------------------------------------------------
                                        (0063)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0064) 
1E29: 7E       RETI                     (0065)    reti
                                        (0066) 
                                        (0067) 
                                        (0068) ; end of file PSoCGPIOINT.asm
__plcall:
    1F8E: 53 0B    MOV   [__rX],A
    1F90: 28       ROMX  
    1F91: 08       PUSH  A
    1F92: 51 0B    MOV   A,[__rX]
    1F94: 75       INC   X
    1F95: 09 00    ADC   A,0x0
    1F97: 28       ROMX  
    1F98: 08       PUSH  A
    1F99: 7F       RET   
    1F9A: 30       HALT  
<created procedures>:
    1F9B: 52 00    MOV   A,[X+0]
    1F9D: 53 16    MOV   [__r1],A
    1F9F: 55 17 00 MOV   [__r0],0x0
    1FA2: 65 16    ASL   [__r1]
    1FA4: 6B 17    RLC   [__r0]
    1FA6: 7F       RET   
    1FA7: 65 16    ASL   [__r1]
    1FA9: 06 16 65 ADD   [__r1],0x65
    1FAC: 3E 16    MVI   A,[__r1]
    1FAE: 53 17    MOV   [__r0],A
    1FB0: 3E 16    MVI   A,[__r1]
    1FB2: 7F       RET   
    1FB3: 5F 16 74 MOV   [__r1],[config+1]
    1FB6: 55 17 00 MOV   [__r0],0x0
    1FB9: 5F 15 73 MOV   [__r2],[config]
    1FBC: 50 00    MOV   A,0x0
    1FBE: 02 16    ADD   A,[__r1]
    1FC0: 7F       RET   
    1FC1: 64       ASL   A
    1FC2: 01 22    ADD   A,0x22
    1FC4: 53 16    MOV   [__r1],A
    1FC6: 3E 16    MVI   A,[__r1]
    1FC8: 67       ASR   A
    1FC9: 67       ASR   A
    1FCA: 21 0F    AND   A,0xF
    1FCC: 7F       RET   
