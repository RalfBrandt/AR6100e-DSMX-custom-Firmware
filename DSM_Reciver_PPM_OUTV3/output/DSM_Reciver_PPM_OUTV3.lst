FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x34 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
                                        (0108)     ;halt                           ;Stop execution if power falls too low
0004: 7D 19 AE LJMP  _LVD_ISR           (0109)     ljmp _LVD_ISR	
0007: 7E       RETI                     (0110)     reti
                                        (0111) 
                                        (0112)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0113)     // call	void_handler
0008: 7E       RETI                     (0114)     reti
                                        (0115) 
                                        (0116)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0117)     // call	void_handler
000C: 7E       RETI                     (0118)     reti
                                        (0119) 
                                        (0120)     org   18h                      ;VC3 Interrupt Vector
                                        (0121)     // call	void_handler
0018: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 1D F7 LJMP  PSoC_GPIO_ISR      (0125)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0129)     // call	void_handler
0020: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 04 F6 LJMP  RST_GetState|_PWM16_1_ISR|RST_Invert(0133)     ljmp	_PWM16_1_ISR
0027: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0137)     // call	void_handler
0028: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 04 7B LJMP  _Timer8_1_ISR      (0141)     ljmp	_Timer8_1_ISR
002F: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0145)     // call	void_handler
0060: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   64h                      ;Sleep Timer Interrupt Vector
0064: 7D 04 9C LJMP  _SleepTimer_1_ISR  (0149)     ljmp	_SleepTimer_1_ISR
0067: 7E       RETI                     (0150)     reti
0068: 71 10    OR    F,0x10             
                                        (0151)     ;---------------------------------------------------
                                        (0152)     ; Insert your custom code above this banner
                                        (0153)     ;---------------------------------------------------
                                        (0154)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0155) 
                                        (0156) ;-----------------------------------------------------------------------------
                                        (0157) ;  Start of Execution.
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0160) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0161) ;
                                        (0162) 
                                        (0163) IF	(TOOLCHAIN & HITECH)
                                        (0164)  	AREA PD_startup(CODE, REL, CON)
                                        (0165) ELSE
                                        (0166)     org 68h
                                        (0167) ENDIF
                                        (0168) __Start:
                                        (0169) 
                                        (0170)     ; initialize SMP values for voltage stabilization, if required,
                                        (0171)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0172)     ; least for now. 
                                        (0173)     ;
                                        (0174)     M8C_SetBank1
006A: 62 E3 81 MOV   REG[0xE3],0x81     (0175)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0176)     M8C_SetBank0
                                        (0177) 
                                        (0178) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0179) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0180)     M8C_EnableWatchDog
                                        (0181) ENDIF
                                        (0182) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0183)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0184) 
                                        (0185)     ;---------------------------
                                        (0186)     ; Set up the Temporary stack
                                        (0187)     ;---------------------------
                                        (0188)     ; A temporary stack is set up for the SSC instructions.
                                        (0189)     ; The real stack start will be assigned later.
                                        (0190)     ;
                                        (0191) _stack_start:          equ 80h
0075: 50 80    MOV   A,0x80             (0192)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0193)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
007B: 5D D0    MOV   A,REG[0xD0]        
007D: 08       PUSH  A                  
007E: 62 D0 00 MOV   REG[0xD0],0x0      
0081: 55 FA 01 MOV   [_ramareas_end+105],0x1
0084: 4F       MOV   X,SP               
0085: 5B       MOV   A,X                
0086: 01 03    ADD   A,0x3              
0088: 53 F9    MOV   [_ramareas_end+104],A
008A: 55 F8 3A MOV   [_ramareas_end+103],0x3A
008D: 50 06    MOV   A,0x6              
008F: 00       SWI                      
0090: 71 10    OR    F,0x10             
0092: 51 F9    MOV   A,[_ramareas_end+104]
0094: 60 E8    MOV   REG[0xE8],A        
0096: 51 F8    MOV   A,[_ramareas_end+103]
0098: 60 EA    MOV   REG[0xEA],A        
009A: 70 EF    AND   F,0xEF             
009C: 18       POP   A                  
009D: 60 D0    MOV   REG[0xD0],A        
                                        (0194) 
                                        (0195)     ;------------------------
                                        (0196)     ; Set Power-related Trim 
                                        (0197)     ;------------------------
                                        (0198)     
                                        (0199) M8C_ClearWDTAndSleep
                                        (0200) 
                                        (0201) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0202)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0203)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0204)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0205)  ENDIF
                                        (0206) ENDIF ; 5.0 V Operation
                                        (0207) 
                                        (0208) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0209)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0210)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0211)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0212)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0213)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0214)  ENDIF
                                        (0215) ENDIF ; 3.3 Volt Operation
                                        (0216) 
                                        (0217) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0218)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0219)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0220) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0221) 
                                        (0222) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0223)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0224)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0225) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0226) 
009F: 55 F8 00 MOV   [_ramareas_end+103],0x0(0227)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00A2: 55 F9 00 MOV   [_ramareas_end+104],0x0(0228)     mov  [bSSC_KEYSP], 0
00A5: 71 10    OR    F,0x10             
                                        (0229) 
                                        (0230)     ;---------------------------------------
                                        (0231)     ; Initialize Crystal Oscillator and PLL
                                        (0232)     ;---------------------------------------
                                        (0233) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0234)     M8C_SetBank1
                                        (0235)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0236)     M8C_SetBank0
                                        (0237)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0238) 
                                        (0239) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0240)     M8C_SetBank1
00A7: 62 E0 02 MOV   REG[0xE0],0x2      (0241)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00AA: 70 EF    AND   F,0xEF             
00AC: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0242)     M8C_SetBank0
                                        (0243)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0244) 
                                        (0245) ENDIF
                                        (0246) 
                                        (0247) 	;-------------------------------------------------------
                                        (0248)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0249)     ;-------------------------------------------------------
                                        (0250) 
                                        (0251)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0252) 
                                        (0253) IF (SYSCLK_SOURCE)
                                        (0254)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0255) ENDIF
                                        (0256)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0257) 
                                        (0258) IF	(TOOLCHAIN & HITECH)
                                        (0259)     ;---------------------------------------------
                                        (0260)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0261)     ;---------------------------------------------
                                        (0262) 	global		__Lstackps
                                        (0263) 	mov     a,low __Lstackps
                                        (0264) 	swap    a,sp
                                        (0265) 
                                        (0266) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0267)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0268)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0269)     RAM_SETPAGE_CUR 0
                                        (0270)     RAM_SETPAGE_MVW 0
                                        (0271)     RAM_SETPAGE_MVR 0
                                        (0272)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0273)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0274)     ELSE
                                        (0275)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0276)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0277) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0278) ELSE
                                        (0279)     ;---------------------------------------------
                                        (0280)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0281)     ;---------------------------------------------
                                        (0282) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0283)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0284)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
                                        (0285)     swap  A, SP
                                        (0286)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0287)     RAM_SETPAGE_CUR 0
                                        (0288)     RAM_SETPAGE_MVW 0
                                        (0289)     RAM_SETPAGE_MVR 0
                                        (0290) 
                                        (0291)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0292)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0293)   ELSE
                                        (0294)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0295)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0296) ELSE
00AF: 50 91    MOV   A,0x91             (0297)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00B1: 4E       SWAP  SP,A               (0298)     swap  SP, A
                                        (0299) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0300) ENDIF ;	TOOLCHAIN
                                        (0301) 
                                        (0302)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0303)     ;---------------------------------------------------
                                        (0304)     ; Insert your custom code below this banner
                                        (0305)     ;---------------------------------------------------
                                        (0306) 
                                        (0307)     ;---------------------------------------------------
                                        (0308)     ; Insert your custom code above this banner
                                        (0309)     ;---------------------------------------------------
                                        (0310)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0311) 
                                        (0312)     ;-------------------------
                                        (0313)     ; Load Base Configuration
                                        (0314)     ;-------------------------
                                        (0315)     ; Load global parameter settings and load the user modules in the
                                        (0316)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0317)     ; to minimize start up time; (2) We may still need to play with the
                                        (0318)     ; Sleep Timer.
                                        (0319)     ;
00B2: 7C 04 68 LCALL 0x0468             (0320)     lcall LoadConfigInit
                                        (0321) 
                                        (0322)     ;-----------------------------------
                                        (0323)     ; Initialize C Run-Time Environment
                                        (0324)     ;-----------------------------------
                                        (0325) IF ( C_LANGUAGE_SUPPORT )
                                        (0326) IF ( SYSTEM_SMALL_MEMORY_MODEL )
00B5: 50 00    MOV   A,0x0              (0327)     mov  A,0                           ; clear the 'bss' segment to zero
00B7: 55 17 20 MOV   [__r0],0x20        (0328)     mov  [__r0],<__bss_start
                                        (0329) BssLoop:
00BA: 3C 17 91 CMP   [__r0],0x91        (0330)     cmp  [__r0],<__bss_end
00BD: A0 05    JZ    0x00C3             (0331)     jz   BssDone
00BF: 3F 17    MVI   [__r0],A           (0332)     mvi  [__r0],A
00C1: 8F F8    JMP   0x00BA             (0333)     jmp  BssLoop
                                        (0334) BssDone:
00C3: 50 03    MOV   A,0x3              (0335)     mov  A,>__idata_start              ; copy idata to data segment
00C5: 57 15    MOV   X,0x15             (0336)     mov  X,<__idata_start
00C7: 55 17 00 MOV   [__r0],0x0         (0337)     mov  [__r0],<__data_start
                                        (0338) IDataLoop:
00CA: 3C 17 09 CMP   [__r0],0x9         (0339)     cmp  [__r0],<__data_end
00CD: A0 0B    JZ    0x00D9             (0340)     jz   C_RTE_Done
00CF: 08       PUSH  A                  (0341)     push A
00D0: 28       ROMX                     (0342)     romx
00D1: 3F 17    MVI   [__r0],A           (0343)     mvi  [__r0],A
00D3: 18       POP   A                  (0344)     pop  A
00D4: 75       INC   X                  (0345)     inc  X
00D5: 09 00    ADC   A,0x0              (0346)     adc  A,0
00D7: 8F F2    JMP   0x00CA             (0347)     jmp  IDataLoop
00D9: 71 10    OR    F,0x10             
                                        (0348) 
                                        (0349) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0350) 
                                        (0351) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0352)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0353)                                        ; to use the Virtual Register page.
                                        (0354) 
                                        (0355)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0356)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0357)     ; text segment and may have been relocated by the Code Compressor.
                                        (0358)     ;
                                        (0359)     mov   A, >__pXIData                ; Get the address of the flash
                                        (0360)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                        (0361)     push  A
                                        (0362)     romx                               ; get the MSB of xidata's address
                                        (0363)     mov   [__r0], A
                                        (0364)     pop   A
                                        (0365)     inc   X
                                        (0366)     adc   A, 0
                                        (0367)     romx                               ; get the LSB of xidata's address
                                        (0368)     swap  A, X
                                        (0369)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0370)                                        ;   XIData structure list in flash
                                        (0371)     jmp   .AccessStruct
                                        (0372) 
                                        (0373)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0374)     ; values of C variables. Each structure contains 3 member elements.
                                        (0375)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0376)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0377)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0378)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0379)     ; value in the second member element, an unsigned byte:
                                        (0380)     ; (1) If the value of the second element is non-zero, it represents
                                        (0381)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0382)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0383)     ; the bytes are copied to the block of RAM.
                                        (0384)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0385)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0386)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0387) 
                                        (0388) .AccessNextStructLoop:
                                        (0389)     inc   X                            ; pXIData++
                                        (0390)     adc   A, 0
                                        (0391) .AccessStruct:                         ; Entry point for first block
                                        (0392)     ;
                                        (0393)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0394)     ;
                                        (0395)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                        (0396)     push  A
                                        (0397)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                        (0398)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                        (0399)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                        (0400)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                        (0401)     pop   A                            ; restore pXIData to [A,X]
                                        (0402)     inc   X                            ; pXIData++
                                        (0403)     adc   A, 0
                                        (0404)     push  A
                                        (0405)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                        (0406)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                        (0407)     pop   A                            ; restore pXIData to [A,X]
                                        (0408)     inc   X                            ; pXIData++ (point to size)
                                        (0409)     adc   A, 0
                                        (0410)     push  A
                                        (0411)     romx                               ; Get the size (CPU.A <- *pXIData)
                                        (0412)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                        (0413)     mov   [__r1], A                    ;             else downcount in __r1
                                        (0414)     pop   A                            ; restore pXIData to [A,X]
                                        (0415) 
                                        (0416) .CopyNextByteLoop:
                                        (0417)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0418)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0419)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0420)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0421)     ;
                                        (0422)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0423)     adc   A, 0
                                        (0424)     push  A
                                        (0425)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                        (0426)     mvi   [__r0], A                    ; Transfer the data to RAM
                                        (0427)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0428)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                        (0429)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0430)     inc   A
                                        (0431)     mov   reg[ MVW_PP], A
                                        (0432) .CopyLoopTail:
                                        (0433)     pop   A                            ; restore pXIData to [A,X]
                                        (0434)     dec   [__r1]                       ; End of this array in flash?
                                        (0435)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                        (0436)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0437) 
                                        (0438) .ClearRAMBlockToZero:
                                        (0439)     pop   A                            ; restore pXIData to [A,X]
                                        (0440)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0441)     adc   A, 0
                                        (0442)     push  A
                                        (0443)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                        (0444)     mov   [__r1], A                    ; Initialize downcounter
                                        (0445)     mov   A, 0                         ; Initialize source data
                                        (0446) 
                                        (0447) .ClearRAMBlockLoop:
                                        (0448)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0449)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0450)     ;
                                        (0451)     mvi   [__r0], A                    ; Clear a byte
                                        (0452)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0453)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                        (0454)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0455)     inc   A
                                        (0456)     mov   reg[ MVW_PP], A
                                        (0457)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0458) .ClearLoopTail:
                                        (0459)     dec   [__r1]                       ; Was this the last byte?
                                        (0460)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                        (0461)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                        (0462)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0463) 
                                        (0464) .C_RTE_WrapUp:
                                        (0465)     pop   A                            ; balance stack
                                        (0466) 
                                        (0467) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0468) 
                                        (0469) C_RTE_Done:
                                        (0470) 
                                        (0471) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0472) 
                                        (0473)     ;-------------------------------
                                        (0474)     ; Voltage Stabilization for SMP
                                        (0475)     ;-------------------------------
                                        (0476) 
                                        (0477) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0478) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0479)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0480)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0481)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0482)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0483)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0484)     M8C_SetBank1
                                        (0485)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0486)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0487)     M8C_SetBank0
                                        (0488)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0489)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0490) .WaitFor2ms:
                                        (0491)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0492)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0493) ENDIF ; SMP is operational
                                        (0494) ENDIF ; 5.0V Operation
                                        (0495) 
                                        (0496)     ;-------------------------------
                                        (0497)     ; Set Power-On Reset (POR) Level
                                        (0498)     ;-------------------------------
                                        (0499)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0500)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0501)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0502)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0503)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0504) 
                                        (0505)     M8C_SetBank1
                                        (0506) 
                                        (0507) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0508)                                                ;  Yes, lowest trip already set
                                        (0509) ELSE                                           ;   No, must adjust POR...
                                        (0510) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
00DB: 43 E3 10 OR    REG[0xE3],0x10     (0511)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
00DE: 70 EF    AND   F,0xEF             
                                        (0512) ELSE
                                        (0513) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0514)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0515)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0516)  ELSE                                          ;    No, fast mode
                                        (0517)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                        (0518)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
                                        (0519)   ELSE ; 24HMz                                 ;
                                        (0520)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0521)   ENDIF ; 24MHz
                                        (0522)  ENDIF ; Slow Mode
                                        (0523) ENDIF ; 5.0V Operation
                                        (0524) ENDIF ; 3.3V Operation
                                        (0525) ENDIF ; 2.7V Operation
                                        (0526) 
                                        (0527)     M8C_SetBank0
                                        (0528) 
                                        (0529)     ;----------------------------
                                        (0530)     ; Wrap up and invoke "main"
                                        (0531)     ;----------------------------
                                        (0532) 
                                        (0533)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0534)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0535)     ;
00E0: 62 E0 00 MOV   REG[0xE0],0x0      (0536)     mov  reg[INT_MSK0],0
00E3: 71 10    OR    F,0x10             
                                        (0537) 
                                        (0538)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0539)     ;
                                        (0540)     M8C_SetBank1
00E5: 62 E0 02 MOV   REG[0xE0],0x2      (0541)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00E8: 70 EF    AND   F,0xEF             
                                        (0542)     M8C_SetBank0
                                        (0543) 
                                        (0544)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0545)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0546)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0547)     ;
00EA: 62 E2 00 MOV   REG[0xE2],0x0      (0548)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0549)                                    ; have been set during the boot process.
                                        (0550) IF	(TOOLCHAIN & HITECH)
                                        (0551) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0552) ELSE
                                        (0553) IF ENABLE_LJMP_TO_MAIN
                                        (0554)     ljmp  _main                    ; goto main (no return)
                                        (0555) ELSE
00ED: 7C 19 BA LCALL _main              (0556)     lcall _main                    ; call main
                                        (0557) .Exit:
00F0: 8F FF    JMP   0x00F0             (0558)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0559) ENDIF
                                        (0560) ENDIF ; TOOLCHAIN
                                        (0561) 
                                        (0562)     ;---------------------------------
                                        (0563)     ; Library Access to Global Parms
                                        (0564)     ;---------------------------------
                                        (0565)     ;
                                        (0566)  bGetPowerSetting:
                                        (0567) _bGetPowerSetting:
                                        (0568)     ; Returns value of POWER_SETTING in the A register.
                                        (0569)     ; No inputs. No Side Effects.
                                        (0570)     ;
                                        (0571) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0572)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0573) ELSE
00F2: 50 08    MOV   A,0x8              (0574)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0575) ENDIF
00F4: 7F       RET                      (0576)     ret
                                        (0577) 
                                        (0578) IF	(TOOLCHAIN & HITECH)
                                        (0579) ELSE
                                        (0580)     ;---------------------------------
                                        (0581)     ; Order Critical RAM & ROM AREAs
                                        (0582)     ;---------------------------------
                                        (0583)     ;  'TOP' is all that has been defined so far...
                                        (0584) 
                                        (0585)     ;  ROM AREAs for C CONST, static & global items
                                        (0586)     ;
                                        (0587)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0588)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0589) __idata_start:
                                        (0590) 
                                        (0591)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0592) __func_lit_start:
                                        (0593) 
                                        (0594) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0595)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0596)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0597)     ; relocated by the code compressor, but the text area may shrink and
                                        (0598)     ; that moves xidata around.
                                        (0599)     ;
                                        (0600) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0601) ENDIF
                                        (0602) 
                                        (0603)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0604)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0605) 
                                        (0606)     ; CODE segment for general use
                                        (0607)     ;
                                        (0608)     AREA text (ROM, REL, CON)
                                        (0609) __text_start:
                                        (0610) 
                                        (0611)     ; RAM area usage
                                        (0612)     ;
                                        (0613)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0614) __data_start:
                                        (0615) 
                                        (0616)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0617)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0618)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0619) __bss_start:
                                        (0620) ENDIF ; TOOLCHAIN
                                        (0621) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.3191
032C: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_dsm_reciver
                                        (0019) AREA psoc_config(rom, rel)
                                        (0020) LoadConfigTBL_dsm_reciver:
                                        (0021) 	M8C_SetBank0
                                        (0022) ;  Global Register values Bank 0
032E: 62 60 04 MOV   REG[0x60],0x4      (0023) 	mov	reg[60h], 04h		; AnalogColumnInputSelect register (AMX_IN)
0331: 62 64 00 MOV   REG[0x64],0x0      (0024) 	mov	reg[64h], 00h		; AnalogComparatorControl0 register (CMP_CR0)
0334: 62 66 00 MOV   REG[0x66],0x0      (0025) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
0337: 62 61 00 MOV   REG[0x61],0x0      (0026) 	mov	reg[61h], 00h		; AnalogMuxBusConfig register (AMUXCFG)
033A: 62 E6 00 MOV   REG[0xE6],0x0      (0027) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
033D: 62 E7 00 MOV   REG[0xE7],0x0      (0028) 	mov	reg[e7h], 00h		; DecimatorControl_1 register (DEC_CR1)
0340: 62 D6 00 MOV   REG[0xD6],0x0      (0029) 	mov	reg[d6h], 00h		; I2CConfig register (I2CCFG)
0343: 62 62 00 MOV   REG[0x62],0x0      (0030) 	mov	reg[62h], 00h		; PWM_Control register (PWM_CR)
0346: 62 B0 30 MOV   REG[0xB0],0x30     (0031) 	mov	reg[b0h], 30h		; Row_0_InputMux register (RDI0RI)
0349: 62 B1 01 MOV   REG[0xB1],0x1      (0032) 	mov	reg[b1h], 01h		; Row_0_InputSync register (RDI0SYN)
034C: 62 B2 00 MOV   REG[0xB2],0x0      (0033) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
034F: 62 B3 3C MOV   REG[0xB3],0x3C     (0034) 	mov	reg[b3h], 3ch		; Row_0_LogicSelect_0 register (RDI0LT0)
0352: 62 B4 3F MOV   REG[0xB4],0x3F     (0035) 	mov	reg[b4h], 3fh		; Row_0_LogicSelect_1 register (RDI0LT1)
0355: 62 B5 20 MOV   REG[0xB5],0x20     (0036) 	mov	reg[b5h], 20h		; Row_0_OutputDrive_0 register (RDI0SRO0)
0358: 62 B6 14 MOV   REG[0xB6],0x14     (0037) 	mov	reg[b6h], 14h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0038) ;  Instance name CS_PIN, User Module LED
                                        (0039) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0040) ;  Instance name LED_1, User Module LED
                                        (0041) ;  Instance name LED_1_0, User Module LED
                                        (0042) ;  Instance name LED_1_1, User Module LED
                                        (0043) ;  Instance name LED_1_4, User Module LED
                                        (0044) ;  Instance name LED_1_5, User Module LED
                                        (0045) ;  Instance name LED_1_6, User Module LED
                                        (0046) ;  Instance name LED_1_7, User Module LED
                                        (0047) ;  Instance name PWM16_1, User Module PWM16
                                        (0048) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
035B: 62 23 00 MOV   REG[0x23],0x0      (0049) 	mov	reg[23h], 00h		;PWM16_1_CONTROL_LSB_REG(DBB00CR0)
035E: 62 21 C8 MOV   REG[0x21],0xC8     (0050) 	mov	reg[21h], c8h		;PWM16_1_PERIOD_LSB_REG(DBB00DR1)
0361: 62 22 C8 MOV   REG[0x22],0xC8     (0051) 	mov	reg[22h], c8h		;PWM16_1_COMPARE_LSB_REG(DBB00DR2)
                                        (0052) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
0364: 62 27 00 MOV   REG[0x27],0x0      (0053) 	mov	reg[27h], 00h		;PWM16_1_CONTROL_MSB_REG(DBB01CR0)
0367: 62 25 08 MOV   REG[0x25],0x8      (0054) 	mov	reg[25h], 08h		;PWM16_1_PERIOD_MSB_REG(DBB01DR1)
036A: 62 26 00 MOV   REG[0x26],0x0      (0055) 	mov	reg[26h], 00h		;PWM16_1_COMPARE_MSB_REG(DBB01DR2)
                                        (0056) ;  Instance name RST, User Module LED
                                        (0057) ;  Instance name SPIM_1, User Module SPIM
                                        (0058) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
036D: 62 2B 00 MOV   REG[0x2B],0x0      (0059) 	mov	reg[2bh], 00h		;SPIM_1_CONTROL_REG  (DCB02CR0)
0370: 62 29 00 MOV   REG[0x29],0x0      (0060) 	mov	reg[29h], 00h		;SPIM_1_TX_BUFFER_REG(DCB02DR1)
0373: 62 2A 00 MOV   REG[0x2A],0x0      (0061) 	mov	reg[2ah], 00h		;SPIM_1_RX_BUFFER_REG(DCB02DR2)
                                        (0062) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0063) ;  Instance name Timer8_1, User Module Timer8
                                        (0064) ;       Instance name Timer8_1, Block Name TIMER8(DCB03)
0376: 62 2F 04 MOV   REG[0x2F],0x4      (0065) 	mov	reg[2fh], 04h		;Timer8_1_CONTROL_REG(DCB03CR0)
0379: 62 2D FF MOV   REG[0x2D],0xFF     (0066) 	mov	reg[2dh], ffh		;Timer8_1_PERIOD_REG(DCB03DR1)
037C: 62 2E 00 MOV   REG[0x2E],0x0      (0067) 	mov	reg[2eh], 00h		;Timer8_1_COMPARE_REG(DCB03DR2)
037F: 71 10    OR    F,0x10             
                                        (0068) 	M8C_SetBank1
                                        (0069) ;  Global Register values Bank 1
0381: 62 61 00 MOV   REG[0x61],0x0      (0070) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
0384: 62 6B 04 MOV   REG[0x6B],0x4      (0071) 	mov	reg[6bh], 04h		; AnalogColumnClockDivide register (CLK_CR3)
0387: 62 60 00 MOV   REG[0x60],0x0      (0072) 	mov	reg[60h], 00h		; AnalogColumnClockSelect register (CLK_CR0)
038A: 62 62 80 MOV   REG[0x62],0x80     (0073) 	mov	reg[62h], 80h		; AnalogIOControl_0 register (ABF_CR0)
038D: 62 67 00 MOV   REG[0x67],0x0      (0074) 	mov	reg[67h], 00h		; AnalogLUTControl0 register (ALT_CR0)
0390: 62 64 00 MOV   REG[0x64],0x0      (0075) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
0393: 62 FD 00 MOV   REG[0xFD],0x0      (0076) 	mov	reg[fdh], 00h		; DAC_Control register (DAC_CR)
0396: 62 D1 00 MOV   REG[0xD1],0x0      (0077) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
0399: 62 D3 00 MOV   REG[0xD3],0x0      (0078) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
039C: 62 D0 00 MOV   REG[0xD0],0x0      (0079) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
039F: 62 D2 00 MOV   REG[0xD2],0x0      (0080) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
03A2: 62 E1 B1 MOV   REG[0xE1],0xB1     (0081) 	mov	reg[e1h], b1h		; OscillatorControl_1 register (OSC_CR1)
03A5: 62 E2 01 MOV   REG[0xE2],0x1      (0082) 	mov	reg[e2h], 01h		; OscillatorControl_2 register (OSC_CR2)
03A8: 62 DF FF MOV   REG[0xDF],0xFF     (0083) 	mov	reg[dfh], ffh		; OscillatorControl_3 register (OSC_CR3)
03AB: 62 DE 02 MOV   REG[0xDE],0x2      (0084) 	mov	reg[deh], 02h		; OscillatorControl_4 register (OSC_CR4)
03AE: 62 DD 00 MOV   REG[0xDD],0x0      (0085) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
03B1: 62 D8 00 MOV   REG[0xD8],0x0      (0086) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
03B4: 62 D9 00 MOV   REG[0xD9],0x0      (0087) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
03B7: 62 DA 00 MOV   REG[0xDA],0x0      (0088) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
03BA: 62 DB 00 MOV   REG[0xDB],0x0      (0089) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
                                        (0090) ;  Instance name CS_PIN, User Module LED
                                        (0091) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0092) ;  Instance name LED_1, User Module LED
                                        (0093) ;  Instance name LED_1_0, User Module LED
                                        (0094) ;  Instance name LED_1_1, User Module LED
                                        (0095) ;  Instance name LED_1_4, User Module LED
                                        (0096) ;  Instance name LED_1_5, User Module LED
                                        (0097) ;  Instance name LED_1_6, User Module LED
                                        (0098) ;  Instance name LED_1_7, User Module LED
                                        (0099) ;  Instance name PWM16_1, User Module PWM16
                                        (0100) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
03BD: 62 20 11 MOV   REG[0x20],0x11     (0101) 	mov	reg[20h], 11h		;PWM16_1_FUNC_LSB_REG(DBB00FN)
03C0: 62 21 15 MOV   REG[0x21],0x15     (0102) 	mov	reg[21h], 15h		;PWM16_1_INPUT_LSB_REG(DBB00IN)
03C3: 62 22 40 MOV   REG[0x22],0x40     (0103) 	mov	reg[22h], 40h		;PWM16_1_OUTPUT_LSB_REG(DBB00OU)
                                        (0104) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
03C6: 62 24 39 MOV   REG[0x24],0x39     (0105) 	mov	reg[24h], 39h		;PWM16_1_FUNC_MSB_REG(DBB01FN)
03C9: 62 25 35 MOV   REG[0x25],0x35     (0106) 	mov	reg[25h], 35h		;PWM16_1_INPUT_MSB_REG(DBB01IN)
03CC: 62 26 46 MOV   REG[0x26],0x46     (0107) 	mov	reg[26h], 46h		;PWM16_1_OUTPUT_MSB_REG(DBB01OU)
                                        (0108) ;  Instance name RST, User Module LED
                                        (0109) ;  Instance name SPIM_1, User Module SPIM
                                        (0110) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
03CF: 62 28 06 MOV   REG[0x28],0x6      (0111) 	mov	reg[28h], 06h		;SPIM_1_FUNCTION_REG (DCB02FN)
03D2: 62 29 C5 MOV   REG[0x29],0xC5     (0112) 	mov	reg[29h], c5h		;SPIM_1_INPUT_REG    (DCB02IN)
03D5: 62 2A 7D MOV   REG[0x2A],0x7D     (0113) 	mov	reg[2ah], 7dh		;SPIM_1_OUTPUT_REG   (DCB02OU)
                                        (0114) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0115) ;  Instance name Timer8_1, User Module Timer8
                                        (0116) ;       Instance name Timer8_1, Block Name TIMER8(DCB03)
03D8: 62 2C 20 MOV   REG[0x2C],0x20     (0117) 	mov	reg[2ch], 20h		;Timer8_1_FUNC_REG(DCB03FN)
03DB: 62 2D 11 MOV   REG[0x2D],0x11     (0118) 	mov	reg[2dh], 11h		;Timer8_1_INPUT_REG(DCB03IN)
03DE: 62 2E 40 MOV   REG[0x2E],0x40     (0119) 	mov	reg[2eh], 40h		;Timer8_1_OUTPUT_REG(DCB03OU)
03E1: 70 EF    AND   F,0xEF             
03E3: 70 EF    AND   F,0xEF             
                                        (0120) 	M8C_SetBank0
                                        (0121) ;  Ordered Global Register values
                                        (0122) 	M8C_SetBank0
03E5: 62 00 00 MOV   REG[0x0],0x0       (0123) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
03E8: 71 10    OR    F,0x10             
                                        (0124) 	M8C_SetBank1
03EA: 62 00 BC MOV   REG[0x0],0xBC      (0125) 	mov	reg[00h], bch		; Port_0_DriveMode_0 register (PRT0DM0)
03ED: 62 01 43 MOV   REG[0x1],0x43      (0126) 	mov	reg[01h], 43h		; Port_0_DriveMode_1 register (PRT0DM1)
03F0: 70 EF    AND   F,0xEF             
                                        (0127) 	M8C_SetBank0
03F2: 62 03 02 MOV   REG[0x3],0x2       (0128) 	mov	reg[03h], 02h		; Port_0_DriveMode_2 register (PRT0DM2)
03F5: 62 02 29 MOV   REG[0x2],0x29      (0129) 	mov	reg[02h], 29h		; Port_0_GlobalSelect register (PRT0GS)
03F8: 71 10    OR    F,0x10             
                                        (0130) 	M8C_SetBank1
03FA: 62 02 00 MOV   REG[0x2],0x0       (0131) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
03FD: 62 03 40 MOV   REG[0x3],0x40      (0132) 	mov	reg[03h], 40h		; Port_0_IntCtrl_1 register (PRT0IC1)
0400: 70 EF    AND   F,0xEF             
                                        (0133) 	M8C_SetBank0
0402: 62 01 40 MOV   REG[0x1],0x40      (0134) 	mov	reg[01h], 40h		; Port_0_IntEn register (PRT0IE)
0405: 62 04 00 MOV   REG[0x4],0x0       (0135) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
0408: 71 10    OR    F,0x10             
                                        (0136) 	M8C_SetBank1
040A: 62 04 FB MOV   REG[0x4],0xFB      (0137) 	mov	reg[04h], fbh		; Port_1_DriveMode_0 register (PRT1DM0)
040D: 62 05 04 MOV   REG[0x5],0x4       (0138) 	mov	reg[05h], 04h		; Port_1_DriveMode_1 register (PRT1DM1)
0410: 70 EF    AND   F,0xEF             
                                        (0139) 	M8C_SetBank0
0412: 62 07 04 MOV   REG[0x7],0x4       (0140) 	mov	reg[07h], 04h		; Port_1_DriveMode_2 register (PRT1DM2)
0415: 62 06 00 MOV   REG[0x6],0x0       (0141) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
0418: 71 10    OR    F,0x10             
                                        (0142) 	M8C_SetBank1
041A: 62 06 00 MOV   REG[0x6],0x0       (0143) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
041D: 62 07 00 MOV   REG[0x7],0x0       (0144) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
0420: 70 EF    AND   F,0xEF             
                                        (0145) 	M8C_SetBank0
0422: 62 05 00 MOV   REG[0x5],0x0       (0146) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
0425: 62 08 00 MOV   REG[0x8],0x0       (0147) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
0428: 71 10    OR    F,0x10             
                                        (0148) 	M8C_SetBank1
042A: 62 08 EF MOV   REG[0x8],0xEF      (0149) 	mov	reg[08h], efh		; Port_2_DriveMode_0 register (PRT2DM0)
042D: 62 09 10 MOV   REG[0x9],0x10      (0150) 	mov	reg[09h], 10h		; Port_2_DriveMode_1 register (PRT2DM1)
0430: 70 EF    AND   F,0xEF             
                                        (0151) 	M8C_SetBank0
0432: 62 0B 10 MOV   REG[0xB],0x10      (0152) 	mov	reg[0bh], 10h		; Port_2_DriveMode_2 register (PRT2DM2)
0435: 62 0A 00 MOV   REG[0xA],0x0       (0153) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
0438: 71 10    OR    F,0x10             
                                        (0154) 	M8C_SetBank1
043A: 62 0A 00 MOV   REG[0xA],0x0       (0155) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
043D: 62 0B 00 MOV   REG[0xB],0x0       (0156) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
0440: 70 EF    AND   F,0xEF             
                                        (0157) 	M8C_SetBank0
0442: 62 09 00 MOV   REG[0x9],0x0       (0158) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
0445: 62 0C 04 MOV   REG[0xC],0x4       (0159) 	mov	reg[0ch], 04h		; Port_3_Data register (PRT3DR)
0448: 71 10    OR    F,0x10             
                                        (0160) 	M8C_SetBank1
044A: 62 0C 0F MOV   REG[0xC],0xF       (0161) 	mov	reg[0ch], 0fh		; Port_3_DriveMode_0 register (PRT3DM0)
044D: 62 0D 04 MOV   REG[0xD],0x4       (0162) 	mov	reg[0dh], 04h		; Port_3_DriveMode_1 register (PRT3DM1)
0450: 70 EF    AND   F,0xEF             
                                        (0163) 	M8C_SetBank0
0452: 62 0F 00 MOV   REG[0xF],0x0       (0164) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0455: 62 0E 04 MOV   REG[0xE],0x4       (0165) 	mov	reg[0eh], 04h		; Port_3_GlobalSelect register (PRT3GS)
0458: 71 10    OR    F,0x10             
                                        (0166) 	M8C_SetBank1
045A: 62 0E 00 MOV   REG[0xE],0x0       (0167) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
045D: 62 0F 00 MOV   REG[0xF],0x0       (0168) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0460: 70 EF    AND   F,0xEF             
                                        (0169) 	M8C_SetBank0
0462: 62 0D 00 MOV   REG[0xD],0x0       (0170) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0465: 70 EF    AND   F,0xEF             
                                        (0171) 	M8C_SetBank0
0467: 7F       RET                      (0172) 	ret
                                        (0173) 
                                        (0174) 
                                        (0175) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_dsm_reciver
                                        (0026) export _LoadConfig_dsm_reciver
                                        (0027) export Port_0_Data_SHADE
                                        (0028) export _Port_0_Data_SHADE
                                        (0029) export Port_1_Data_SHADE
                                        (0030) export _Port_1_Data_SHADE
                                        (0031) export Port_3_Data_SHADE
                                        (0032) export _Port_3_Data_SHADE
                                        (0033) 
                                        (0034) 
                                        (0035) export NO_SHADOW
                                        (0036) export _NO_SHADOW
                                        (0037) 
                                        (0038) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0039) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0040) 
                                        (0041) AREA psoc_config(rom, rel)
                                        (0042) 
                                        (0043) 
                                        (0044) ;---------------------------------------------------------------------------
                                        (0045) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0046) ;                  parameters handled by boot code, like CPU speed). This
                                        (0047) ;                  function can be called from user code, but typically it
                                        (0048) ;                  is only called from boot.
                                        (0049) ;
                                        (0050) ;       INPUTS: None.
                                        (0051) ;      RETURNS: Nothing.
                                        (0052) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0053) ;               In the large memory model currently only the page
                                        (0054) ;               pointer registers listed below are modified.  This does
                                        (0055) ;               not guarantee that in future implementations of this
                                        (0056) ;               function other page pointer registers will not be
                                        (0057) ;               modified.
                                        (0058) ;          
                                        (0059) ;               Page Pointer Registers Modified: 
                                        (0060) ;               CUR_PP
                                        (0061) ;
                                        (0062) _LoadConfigInit:
                                        (0063)  LoadConfigInit:
                                        (0064)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0065)     
0468: 55 1D 00 MOV   [0x1D],0x0         (0066) 	mov		[Port_0_Data_SHADE], 0h
046B: 55 1E 00 MOV   [0x1E],0x0         (0067) 	mov		[Port_1_Data_SHADE], 0h
046E: 55 1F 04 MOV   [0x1F],0x4         (0068) 	mov		[Port_3_Data_SHADE], 4h
                                        (0069) 
0471: 7C 04 75 LCALL 0x0475             (0070) 	lcall	LoadConfig_dsm_reciver
                                        (0071) 
                                        (0072) 
                                        (0073)     RAM_EPILOGUE RAM_USE_CLASS_4
0474: 7F       RET                      (0074)     ret
                                        (0075) 
                                        (0076) ;---------------------------------------------------------------------------
                                        (0077) ; Load Configuration dsm_reciver
                                        (0078) ;
                                        (0079) ;    Load configuration registers for dsm_reciver.
                                        (0080) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0081) ;
                                        (0082) ;       INPUTS: None.
                                        (0083) ;      RETURNS: Nothing.
                                        (0084) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0085) ;               modified as may the Page Pointer registers!
                                        (0086) ;               In the large memory model currently only the page
                                        (0087) ;               pointer registers listed below are modified.  This does
                                        (0088) ;               not guarantee that in future implementations of this
                                        (0089) ;               function other page pointer registers will not be
                                        (0090) ;               modified.
                                        (0091) ;          
                                        (0092) ;               Page Pointer Registers Modified: 
                                        (0093) ;               CUR_PP
                                        (0094) ;
                                        (0095) _LoadConfig_dsm_reciver:
                                        (0096)  LoadConfig_dsm_reciver:
                                        (0097)     RAM_PROLOGUE RAM_USE_CLASS_4
0475: 7C 03 2C LCALL 0x032C             (0098)     lcall   LoadConfigTBL_dsm_reciver            ; Call load config table routine
0478: 70 EF    AND   F,0xEF             
                                        (0099) 
                                        (0100) 
                                        (0101)     M8C_SetBank0                    ; Force return to bank 0
                                        (0102)     RAM_EPILOGUE RAM_USE_CLASS_4
047A: 7F       RET                      (0103)     ret
                                        (0104) 
                                        (0105) 
                                        (0106) 
                                        (0107) AREA InterruptRAM(ram, rel)
                                        (0108) 
                                        (0109) NO_SHADOW:
                                        (0110) _NO_SHADOW:
                                        (0111) ; write only register shadows
                                        (0112) _Port_0_Data_SHADE:
                                        (0113) Port_0_Data_SHADE:	BLK	1
                                        (0114) _Port_1_Data_SHADE:
                                        (0115) Port_1_Data_SHADE:	BLK	1
                                        (0116) _Port_3_Data_SHADE:
                                        (0117) Port_3_Data_SHADE:	BLK	1
                                        (0118) 
FILE: lib\timer8_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1INT.asm
                                        (0004) ;;   Version: 2.70, Updated on 2015/3/4 at 22:27:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Timer8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Timer8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Timer8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Timer8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
047B: 7D 1D 70 LJMP  _Timer8_1_Interrupt(0081)    ljmp _Timer8_1_Interrupt
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
047E: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Timer8_1INT.asm
FILE: lib\timer8_1.asm                  (0001) ;;*****************************************************************************
047F: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1.asm
                                        (0004) ;;   Version: 2.70, Updated on 2015/3/4 at 22:27:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Timer8_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Timer8_1_EnableInt
                                        (0030) export _Timer8_1_EnableInt
                                        (0031) export  Timer8_1_DisableInt
                                        (0032) export _Timer8_1_DisableInt
                                        (0033) export  Timer8_1_Start
                                        (0034) export _Timer8_1_Start
                                        (0035) export  Timer8_1_Stop
                                        (0036) export _Timer8_1_Stop
                                        (0037) export  Timer8_1_WritePeriod
                                        (0038) export _Timer8_1_WritePeriod
                                        (0039) export  Timer8_1_WriteCompareValue
                                        (0040) export _Timer8_1_WriteCompareValue
                                        (0041) export  Timer8_1_bReadCompareValue
                                        (0042) export _Timer8_1_bReadCompareValue
                                        (0043) export  Timer8_1_bReadTimer
                                        (0044) export _Timer8_1_bReadTimer
                                        (0045) export  Timer8_1_bReadTimerSaveCV
                                        (0046) export _Timer8_1_bReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  bTimer8_1_ReadCompareValue  ; deprecated
                                        (0051) export _bTimer8_1_ReadCompareValue  ; deprecated
                                        (0052) export  bTimer8_1_ReadTimer         ; deprecated
                                        (0053) export _bTimer8_1_ReadTimer         ; deprecated
                                        (0054) export  bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0055) export _bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0056) 
                                        (0057) export  bTimer8_1_ReadCounter       ; obsolete
                                        (0058) export _bTimer8_1_ReadCounter       ; obsolete
                                        (0059) export  bTimer8_1_CaptureCounter    ; obsolete
                                        (0060) export _bTimer8_1_CaptureCounter    ; obsolete
                                        (0061) 
                                        (0062) 
                                        (0063) AREA dsm_reciver_RAM (RAM,REL)
                                        (0064) 
                                        (0065) ;-----------------------------------------------
                                        (0066) ;  Constant Definitions
                                        (0067) ;-----------------------------------------------
                                        (0068) 
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: Timer8_1_EnableInt
                                        (0080) ;
                                        (0081) ;  DESCRIPTION:
                                        (0082) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0083) ;     associated with this User Module. This function has no effect until and
                                        (0084) ;     unless the global interrupts are enabled (for example by using the
                                        (0085) ;     macro M8C_EnableGInt).
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;
                                        (0088) ;  ARGUMENTS:    None.
                                        (0089) ;  RETURNS:      Nothing.
                                        (0090) ;  SIDE EFFECTS: 
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  Timer8_1_EnableInt:
                                        (0098) _Timer8_1_EnableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    Timer8_1_EnableInt_M
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0482: 7F       RET                      (0102)    ret
0483: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0103) 
                                        (0104) .ENDSECTION
                                        (0105) 
                                        (0106) 
                                        (0107) .SECTION
                                        (0108) ;-----------------------------------------------------------------------------
                                        (0109) ;  FUNCTION NAME: Timer8_1_DisableInt
                                        (0110) ;
                                        (0111) ;  DESCRIPTION:
                                        (0112) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0113) ;     mask bit associated with this User Module.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS: 
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  Timer8_1_DisableInt:
                                        (0126) _Timer8_1_DisableInt:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    Timer8_1_DisableInt_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0130)    ret
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) 
                                        (0135) .SECTION
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  FUNCTION NAME: Timer8_1_Start
                                        (0138) ;
                                        (0139) ;  DESCRIPTION:
                                        (0140) ;     Sets the start bit in the Control register of this user module.  The
                                        (0141) ;     timer will begin counting on the next input clock.
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;
                                        (0144) ;  ARGUMENTS:    None
                                        (0145) ;  RETURNS:      Nothing
                                        (0146) ;  SIDE EFFECTS: 
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  Timer8_1_Start:
                                        (0154) _Timer8_1_Start:
                                        (0155)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0156)    Timer8_1_Start_M
                                        (0157)    RAM_EPILOGUE RAM_USE_CLASS_1
0486: 7F       RET                      (0158)    ret
0487: 41 2F FE AND   REG[0x2F],0xFE     
                                        (0159) 
                                        (0160) .ENDSECTION
                                        (0161) 
                                        (0162) 
                                        (0163) .SECTION
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;  FUNCTION NAME: Timer8_1_Stop
                                        (0166) ;
                                        (0167) ;  DESCRIPTION:
                                        (0168) ;     Disables timer operation by clearing the start bit in the Control
                                        (0169) ;     register.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    None
                                        (0173) ;  RETURNS:      Nothing
                                        (0174) ;  SIDE EFFECTS: 
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;
                                        (0181)  Timer8_1_Stop:
                                        (0182) _Timer8_1_Stop:
                                        (0183)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0184)    Timer8_1_Stop_M
                                        (0185)    RAM_EPILOGUE RAM_USE_CLASS_1
048A: 7F       RET                      (0186)    ret
                                        (0187) 
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) 
                                        (0191) .SECTION
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  FUNCTION NAME: Timer8_1_WritePeriod
                                        (0194) ;
                                        (0195) ;  DESCRIPTION:
                                        (0196) ;     Write the 8-bit period value into the Period register (DR1). If the
                                        (0197) ;     Timer user module is stopped, then this value will also be latched
                                        (0198) ;     into the Count register (DR0).
                                        (0199) ;-----------------------------------------------------------------------------
                                        (0200) ;
                                        (0201) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0202) ;  RETURNS:   Nothing
                                        (0203) ;  SIDE EFFECTS: 
                                        (0204) ;    The A and X registers may be modified by this or future implementations
                                        (0205) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0207) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0208) ;    functions.
                                        (0209) ;
                                        (0210)  Timer8_1_WritePeriod:
                                        (0211) _Timer8_1_WritePeriod:
                                        (0212)    RAM_PROLOGUE RAM_USE_CLASS_1
048B: 60 2D    MOV   REG[0x2D],A        (0213)    mov   reg[Timer8_1_PERIOD_REG], A
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_1
048D: 7F       RET                      (0215)    ret
                                        (0216) 
                                        (0217) .ENDSECTION
                                        (0218) 
                                        (0219) 
                                        (0220) .SECTION
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;  FUNCTION NAME: Timer8_1_WriteCompareValue
                                        (0223) ;
                                        (0224) ;  DESCRIPTION:
                                        (0225) ;     Writes compare value into the Compare register (DR2).
                                        (0226) ;
                                        (0227) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0228) ;           Compare register. (Call Timer8_1_Stop to disable).
                                        (0229) ;-----------------------------------------------------------------------------
                                        (0230) ;
                                        (0231) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0232) ;  RETURNS:      Nothing
                                        (0233) ;  SIDE EFFECTS: 
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240)  Timer8_1_WriteCompareValue:
                                        (0241) _Timer8_1_WriteCompareValue:
                                        (0242)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0243)    mov   reg[Timer8_1_COMPARE_REG], A
                                        (0244)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0245)    ret
                                        (0246) 
                                        (0247) .ENDSECTION
                                        (0248) 
                                        (0249) 
                                        (0250) .SECTION
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;  FUNCTION NAME: Timer8_1_bReadCompareValue
                                        (0253) ;
                                        (0254) ;  DESCRIPTION:
                                        (0255) ;     Reads the Compare register.
                                        (0256) ;-----------------------------------------------------------------------------
                                        (0257) ;
                                        (0258) ;  ARGUMENTS:    None
                                        (0259) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0260) ;  SIDE EFFECTS: 
                                        (0261) ;    The A and X registers may be modified by this or future implementations
                                        (0262) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0263) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0264) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0265) ;    functions.
                                        (0266) ;
                                        (0267)  Timer8_1_bReadCompareValue:
                                        (0268) _Timer8_1_bReadCompareValue:
                                        (0269)  bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0270) _bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0271)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0272)    mov   A, reg[Timer8_1_COMPARE_REG]
                                        (0273)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0274)    ret
                                        (0275) 
                                        (0276) .ENDSECTION
                                        (0277) 
                                        (0278) 
                                        (0279) .SECTION
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;  FUNCTION NAME: Timer8_1_bReadTimerSaveCV
                                        (0282) ;
                                        (0283) ;  DESCRIPTION:
                                        (0284) ;     Returns the value in the Count register (DR0), preserving the
                                        (0285) ;     value in the compare register (DR2).
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0292) ;     2) If enabled, Global interrupts are momentarily disabled.
                                        (0293) ;     3) The user module is stopped momentarily while the compare value is
                                        (0294) ;        restored.  This may cause the Count register to miss one or more
                                        (0295) ;        counts depending on the input clock speed.
                                        (0296) ;     4) The A and X registers may be modified by this or future implementations
                                        (0297) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0298) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0299) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0300) ;        functions.
                                        (0301) ;
                                        (0302) ;  THEORY of OPERATION:
                                        (0303) ;     1) Read and save the Compare register.
                                        (0304) ;     2) Read the Count register, causing its data to be latched into
                                        (0305) ;        the Compare register.
                                        (0306) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0307) ;        to the buffer.
                                        (0308) ;     4) Disable global interrupts
                                        (0309) ;     5) Halt the timer
                                        (0310) ;     6) Restore the Compare register values
                                        (0311) ;     7) Start the Timer again
                                        (0312) ;     8) Restore global interrupt state
                                        (0313) ;
                                        (0314)  Timer8_1_bReadTimerSaveCV:
                                        (0315) _Timer8_1_bReadTimerSaveCV:
                                        (0316)  bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0317) _bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0318)  bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0319) _bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0320) 
                                        (0321) CpuFlags:      equ   0
                                        (0322) bCount:        equ   1
                                        (0323) 
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0325)    mov   X, SP                                   ; X <- stack frame pointer
                                        (0326)    add   SP, 2                                   ; Reserve space for flags, count
                                        (0327)    mov   A, reg[Timer8_1_CONTROL_REG]            ; save the Control register
                                        (0328)    push  A
                                        (0329)    mov   A, reg[Timer8_1_COMPARE_REG]            ; save the Compare register
                                        (0330)    push  A
                                        (0331)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0332)                                                  ; This may cause an interrupt!
                                        (0333)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Now grab DR2 (DR0) and save
                                        (0334)    mov   [X+bCount], A
                                        (0335)    mov   A, 0                                    ; Guess the global interrupt state
                                        (0336)    tst   reg[CPU_F], FLAG_GLOBAL_IE              ; Currently Disabled?
                                        (0337)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
                                        (0338)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
                                        (0339) .SetupStatusFlag:                                ; and ...
                                        (0340)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
                                        (0341)    M8C_DisableGInt                               ; Disable interrupts globally
                                        (0342)    Timer8_1_Stop_M                               ; Stop the timer
                                        (0343)    pop   A                                       ; Restore the Compare register
                                        (0344)    mov   reg[Timer8_1_COMPARE_REG], A
                                        (0345)    pop   A                                       ; restore start state of the timer
                                        (0346)    mov   reg[Timer8_1_CONTROL_REG], A
                                        (0347)    pop   A                                       ; Return result stored in stack frame
                                        (0348)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0349)    reti                                          ; Flag Reg <- StackFrame[0]
                                        (0350) 
                                        (0351) .ENDSECTION
                                        (0352) 
                                        (0353) 
                                        (0354) .SECTION
                                        (0355) ;-----------------------------------------------------------------------------
                                        (0356) ;  FUNCTION NAME: Timer8_1_bReadTimer
                                        (0357) ;
                                        (0358) ;  DESCRIPTION:
                                        (0359) ;     Performs a software capture of the Count register.  A synchronous
                                        (0360) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0361) ;
                                        (0362) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;
                                        (0365) ;  ARGUMENTS:    None
                                        (0366) ;  RETURNS:      fastcall16 BYTE bCount, (value of DR0 in the A register)
                                        (0367) ;  SIDE EFFECTS:
                                        (0368) ;    May cause an interrupt.
                                        (0369) ;
                                        (0370) ;    The A and X registers may be modified by this or future implementations
                                        (0371) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0372) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0373) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0374) ;    functions.
                                        (0375) ;
                                        (0376) ;  THEORY of OPERATION:
                                        (0377) ;     1) Read the Count register - this causes the count value to be
                                        (0378) ;        latched into the Compare register.
                                        (0379) ;     2) Read and return the Count register values from the Compare
                                        (0380) ;        registers into the return buffer.
                                        (0381) ;
                                        (0382)  Timer8_1_bReadTimer:
                                        (0383) _Timer8_1_bReadTimer:
                                        (0384)  bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0385) _bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0386)  bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0387) _bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0388) 
                                        (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0390)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0391)                                                  ; This may cause an interrupt!
                                        (0392)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Return DR2 (actually DR0)
                                        (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0394)    ret
                                        (0395) 
                                        (0396) .ENDSECTION
                                        (0397) 
                                        (0398) ; End of File Timer8_1.asm
FILE: lib\spim_1.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: SPIM_1.asm
                                        (0004) ;;   Version: 2.6, Updated on 2015/3/4 at 22:27:42
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: SPIM User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "SPIM_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export   SPIM_1_EnableInt
                                        (0030) export  _SPIM_1_EnableInt
                                        (0031) export   SPIM_1_DisableInt
                                        (0032) export  _SPIM_1_DisableInt
                                        (0033) export   SPIM_1_Start
                                        (0034) export  _SPIM_1_Start
                                        (0035) export   SPIM_1_Stop
                                        (0036) export  _SPIM_1_Stop
                                        (0037) export   SPIM_1_SendTxData
                                        (0038) export  _SPIM_1_SendTxData
                                        (0039) export   SPIM_1_bReadRxData
                                        (0040) export  _SPIM_1_bReadRxData
                                        (0041) export   SPIM_1_bReadStatus
                                        (0042) export  _SPIM_1_bReadStatus
                                        (0043) 
                                        (0044) // These globals will be removed in a future release
                                        (0045) // Do not use
                                        (0046) export   bSPIM_1_ReadRxData
                                        (0047) export  _bSPIM_1_ReadRxData
                                        (0048) export   bSPIM_1_ReadStatus
                                        (0049) export  _bSPIM_1_ReadStatus
                                        (0050) 
                                        (0051) ;-----------------------------------------------
                                        (0052) ;  Constant Definitions
                                        (0053) ;-----------------------------------------------
                                        (0054) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0055) 
                                        (0056) 
                                        (0057) area UserModules (ROM, REL)
                                        (0058) 
                                        (0059) .SECTION
                                        (0060) ;-----------------------------------------------------------------------------
                                        (0061) ;  FUNCTION NAME: SPIM_1_EnableInt
                                        (0062) ;
                                        (0063) ;  DESCRIPTION:
                                        (0064) ;     Enables the SPIM interrupt by setting the interrupt enable mask
                                        (0065) ;     bit associated with this User Module.
                                        (0066) ;
                                        (0067) ;     NOTE:  Remember to enable the global interrupt by calling the
                                        (0068) ;           M8C global macro: M8C_EnableGInt
                                        (0069) ;
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:  none
                                        (0073) ;
                                        (0074) ;  RETURNS:  none
                                        (0075) ;
                                        (0076) ;  SIDE EFFECTS: 
                                        (0077) ;    The A and X registers may be modified by this or future implementations
                                        (0078) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0079) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0080) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0081) ;    functions.
                                        (0082) ;
                                        (0083) ;  THEORY of OPERATION or PROCEDURE:
                                        (0084) ;     Sets the specific user module interrupt enable mask bit.
                                        (0085) ;
                                        (0086)  SPIM_1_EnableInt:
                                        (0087) _SPIM_1_EnableInt:
                                        (0088)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0089)    M8C_EnableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0090)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0091)    ret
                                        (0092) 
                                        (0093) .ENDSECTION
                                        (0094) 
                                        (0095) .SECTION
                                        (0096) ;-----------------------------------------------------------------------------
                                        (0097) ;  FUNCTION NAME: SPIM_1_DisableInt
                                        (0098) ;
                                        (0099) ;  DESCRIPTION:
                                        (0100) ;     Disables this SPIM's interrupt by clearing the interrupt enable mask bit
                                        (0101) ;     associated with this User Module.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS:  none
                                        (0106) ;
                                        (0107) ;  RETURNS:  none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS: 
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116) ;  THEORY of OPERATION or PROCEDURE:
                                        (0117) ;     Clears the specific user module interrupt enable mask bit.
                                        (0118) ;
                                        (0119)  SPIM_1_DisableInt:
                                        (0120) _SPIM_1_DisableInt:
                                        (0121)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0122)    M8C_DisableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0123)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0124)    ret
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: SPIM_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit, SPI mode, and LSB/MSB first configuration of the SPIM
                                        (0134) ;     user module.
                                        (0135) ;
                                        (0136) ;     Transmission will begin transmitting when a byte is written into the TX buffer
                                        (0137) ;     using the SPIM_1_SendTxData function.
                                        (0138) ;
                                        (0139) ;-----------------------------------------------------------------------------
                                        (0140) ;
                                        (0141) ;  ARGUMENTS:
                                        (0142) ;     BYTE bConfiguration - Consists of SPI Mode and LSB/MSB first bit.
                                        (0143) ;           Use defined masks - masks can be OR'd together.
                                        (0144) ;     PASSED in Accumulator.
                                        (0145) ;
                                        (0146) ;  RETURNS:  none
                                        (0147) ;
                                        (0148) ;  SIDE EFFECTS: 
                                        (0149) ;    The A and X registers may be modified by this or future implementations
                                        (0150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0153) ;    functions.
                                        (0154) ;
                                        (0155) ;  THEORY of OPERATION or PROCEDURE:
                                        (0156) ;     1) Set all Slave Select outputs high
                                        (0157) ;     2) Set the specified SPI configuration bits in the Control register.
                                        (0158) ;
                                        (0159)  SPIM_1_Start:
                                        (0160) _SPIM_1_Start:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    ; setup the SPIM configuration setting
048E: 29 01    OR    A,0x1              (0163)    or    A, bfCONTROL_REG_START_BIT
0490: 60 2B    MOV   REG[0x2B],A        (0164)    mov   REG[SPIM_1_CONTROL_REG], A
                                        (0165)    RAM_EPILOGUE RAM_USE_CLASS_1
0492: 7F       RET                      (0166)    ret
                                        (0167) 
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: SPIM_1_Stop
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Disables SPIM operation.
                                        (0176) ;
                                        (0177) ;-----------------------------------------------------------------------------
                                        (0178) ;
                                        (0179) ;  ARGUMENTS:  none
                                        (0180) ;
                                        (0181) ;  RETURNS:  none
                                        (0182) ;
                                        (0183) ;  SIDE EFFECTS: 
                                        (0184) ;    The A and X registers may be modified by this or future implementations
                                        (0185) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0186) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0187) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0188) ;    functions.
                                        (0189) ;
                                        (0190) ;  THEORY of OPERATION or PROCEDURE:
                                        (0191) ;     Clear the start bit in the Control register.
                                        (0192) ;
                                        (0193)  SPIM_1_Stop:
                                        (0194) _SPIM_1_Stop:
                                        (0195)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0196)    ; clear the SPIM stop bits
                                        (0197)    and   REG[SPIM_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0198)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0199)    ret
                                        (0200) 
                                        (0201) .ENDSECTION
                                        (0202) 
                                        (0203) .SECTION
                                        (0204) ;-----------------------------------------------------------------------------
                                        (0205) ;  FUNCTION NAME: SPIM_1_SendTxData
                                        (0206) ;
                                        (0207) ;  DESCRIPTION:
                                        (0208) ;     Initiates an SPI data transfer.
                                        (0209) ;
                                        (0210) ;-----------------------------------------------------------------------------
                                        (0211) ;
                                        (0212) ;  ARGUMENTS:
                                        (0213) ;     BYTE  bTxData - data to transmit.
                                        (0214) ;        Passed in Accumulator.
                                        (0215) ;
                                        (0216) ;  RETURNS:  none
                                        (0217) ;
                                        (0218) ;  SIDE EFFECTS: 
                                        (0219) ;    The A and X registers may be modified by this or future implementations
                                        (0220) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0221) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0222) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0223) ;    functions.
                                        (0224) ;
                                        (0225) ;  THEORY of OPERATION or PROCEDURE:
                                        (0226) ;     Writes data to the TX buffer register.
                                        (0227) ;
                                        (0228)  SPIM_1_SendTxData:
                                        (0229) _SPIM_1_SendTxData:
                                        (0230)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0231)    ; Transmit the data!
0493: 60 29    MOV   REG[0x29],A        (0232)    mov REG[SPIM_1_TX_BUFFER_REG], A
                                        (0233)    RAM_EPILOGUE RAM_USE_CLASS_1
0495: 7F       RET                      (0234)    ret
                                        (0235) 
                                        (0236) .ENDSECTION
                                        (0237) 
                                        (0238) .SECTION
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) ;  FUNCTION NAME: SPIM_1_bReadRxData
                                        (0241) ;
                                        (0242) ;  DESCRIPTION:
                                        (0243) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0244) ;     sure data is valid.
                                        (0245) ;
                                        (0246) ;-----------------------------------------------------------------------------
                                        (0247) ;
                                        (0248) ;  ARGUMENTS:  none
                                        (0249) ;
                                        (0250) ;  RETURNS:
                                        (0251) ;     bRxData - returned in A.
                                        (0252) ;
                                        (0253) ;  SIDE EFFECTS: 
                                        (0254) ;    The A and X registers may be modified by this or future implementations
                                        (0255) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0256) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0257) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0258) ;    functions.
                                        (0259) ;
                                        (0260) ;  THEORY of OPERATION or PROCEDURE:
                                        (0261) ;
                                        (0262)  SPIM_1_bReadRxData:
                                        (0263) _SPIM_1_bReadRxData:
                                        (0264)  bSPIM_1_ReadRxData:
                                        (0265) _bSPIM_1_ReadRxData:
                                        (0266)    RAM_PROLOGUE RAM_USE_CLASS_1
0496: 5D 2A    MOV   A,REG[0x2A]        (0267)    mov A, REG[SPIM_1_RX_BUFFER_REG]
                                        (0268)    RAM_EPILOGUE RAM_USE_CLASS_1   
0498: 7F       RET                      (0269)    ret
                                        (0270) 
                                        (0271) 
                                        (0272) .ENDSECTION
                                        (0273) 
                                        (0274) .SECTION
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  FUNCTION NAME: SPIM_1_ReadStatus
                                        (0277) ;
                                        (0278) ;  DESCRIPTION:
                                        (0279) ;     Reads the SPIM Status bits in the Control/Status register.
                                        (0280) ;
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;
                                        (0283) ;  ARGUMENTS:  none
                                        (0284) ;
                                        (0285) ;  RETURNS:
                                        (0286) ;     BYTE  bStatus - transmit status data.  Use the defined bit masks.
                                        (0287) ;        Returned in Accumulator.
                                        (0288) ;
                                        (0289) ;  SIDE EFFECTS: 
                                        (0290) ;    The A and X registers may be modified by this or future implementations
                                        (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0294) ;    functions.
                                        (0295) ;
                                        (0296) ;  THEORY of OPERATION or PROCEDURE:
                                        (0297) ;     Read the status and control register.
                                        (0298) ;
                                        (0299)  SPIM_1_bReadStatus:
                                        (0300) _SPIM_1_bReadStatus:
                                        (0301)  bSPIM_1_ReadStatus:
                                        (0302) _bSPIM_1_ReadStatus:
                                        (0303)    RAM_PROLOGUE RAM_USE_CLASS_1
0499: 5D 2B    MOV   A,REG[0x2B]        (0304)    mov A,  REG[SPIM_1_CONTROL_REG]
                                        (0305)    RAM_EPILOGUE RAM_USE_CLASS_1   
049B: 7F       RET                      (0306)    ret
                                        (0307) 
                                        (0308) .ENDSECTION
                                        (0309) 
                                        (0310) ; End of File SPIM_1.asm
FILE: lib\sleeptimer_1int.asm           (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   SleepTimer_1INT.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "SleepTimer_1.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "m8c.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export  _SleepTimer_1_ISR
                                        (0021) 
                                        (0022) 
                                        (0023) export  SleepTimer_1_fTick
                                        (0024) export _SleepTimer_1_fTick
                                        (0025) export  SleepTimer_1_bTimerValue
                                        (0026) export _SleepTimer_1_bTimerValue
                                        (0027) export  SleepTimer_1_bCountDown
                                        (0028) export _SleepTimer_1_bCountDown
                                        (0029) export  SleepTimer_1_TickCount
                                        (0030) export _SleepTimer_1_TickCount
                                        (0031) 
                                        (0032) ;-----------------------------------------------
                                        (0033) ; Variable Allocation
                                        (0034) ;-----------------------------------------------
                                        (0035) AREA InterruptRAM (RAM, REL, CON)
                                        (0036) 
                                        (0037)  SleepTimer_1_fTick:
                                        (0038) _SleepTimer_1_fTick:        BLK  1
                                        (0039) 
                                        (0040)  SleepTimer_1_bTimerValue:
                                        (0041) _SleepTimer_1_bTimerValue:  BLK  1
                                        (0042) 
                                        (0043)  SleepTimer_1_bCountDown:
                                        (0044) _SleepTimer_1_bCountDown:   BLK  1
                                        (0045) 
                                        (0046)  SleepTimer_1_TickCount:
                                        (0047) _SleepTimer_1_TickCount:    BLK  SleepTimer_1_TICK_CNTR_SIZE
                                        (0048) 
                                        (0049) 
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _SleepTimer_1_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;      interrupt handler for instance SleepTimer_1.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _SleepTimer_1_ISR:
                                        (0090) 
049C: 2E 18 01 OR    [0x18],0x1         (0091)    or   [SleepTimer_1_fTick],0x01           ; Set tick flag
                                        (0092)  
                                        (0093)                                                 ; Decrement CountDown (Sync counter)
049F: 47 1A FF TST   [0x1A],0xFF        (0094)    tst  [SleepTimer_1_bCountDown],0xFF
04A2: A0 03    JZ    0x04A6             (0095)    jz   .DoTimer
04A4: 7A 1A    DEC   [0x1A]             (0096)    dec  [SleepTimer_1_bCountDown]
                                        (0097) 
                                        (0098) .DoTimer:                                       ; Decrement TimerValue, if required
04A6: 47 19 FF TST   [0x19],0xFF        (0099)    tst  [SleepTimer_1_bTimerValue],0xFF
04A9: A0 03    JZ    0x04AD             (0100)    jz   .IncBigCounter
04AB: 7A 19    DEC   [0x19]             (0101)    dec  [SleepTimer_1_bTimerValue]
                                        (0102) 
                                        (0103) .IncBigCounter:                                 ; Increment big tick counter
                                        (0104) IF (SleepTimer_1_TICK_CNTR_SIZE & 0x04)
                                        (0105)    inc  [SleepTimer_1_TickCount+3]
                                        (0106)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0107) 
                                        (0108)    inc  [SleepTimer_1_TickCount+2]
                                        (0109)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0110) ENDIF
                                        (0111) 
                                        (0112) IF (SleepTimer_1_TICK_CNTR_SIZE & (0x04|0x02))
04AD: 76 1C    INC   [0x1C]             (0113)    inc  [SleepTimer_1_TickCount+1]
04AF: D0 03    JNC   0x04B3             (0114)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0115) ENDIF
                                        (0116) 
04B1: 76 1B    INC   [0x1B]             (0117)    inc  [SleepTimer_1_TickCount+0]
                                        (0118) 
                                        (0119) SleepTimer_1_SLEEP_ISR_END:
                                        (0120) 
                                        (0121)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0122)    ;---------------------------------------------------
                                        (0123)    ; Insert your custom assembly code below this banner
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ;   NOTE: interrupt service routines must preserve
                                        (0126)    ;   the values of the A and X CPU registers.
                                        (0127)    
                                        (0128)    ;---------------------------------------------------
                                        (0129)    ; Insert your custom assembly code above this banner
                                        (0130)    ;---------------------------------------------------
                                        (0131)    
                                        (0132)    ;---------------------------------------------------
                                        (0133)    ; Insert a lcall to a C function below this banner
                                        (0134)    ; and un-comment the lines between these banners
                                        (0135)    ;---------------------------------------------------
                                        (0136)    
                                        (0137)    ;PRESERVE_CPU_CONTEXT
                                        (0138)    ;ljmp _Sleep_Timer_Interrupt
                                        (0139)    ;RESTORE_CPU_CONTEXT
                                        (0140)    
                                        (0141)    ;---------------------------------------------------
                                        (0142)    ; Insert a lcall to a C function above this banner
                                        (0143)    ; and un-comment the lines between these banners
                                        (0144)    ;---------------------------------------------------
                                        (0145)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0146) 
04B3: 7E       RETI                     (0147)    reti
                                        (0148) 
                                        (0149) ; end of file SleepTimer_1INT.asm
                                        (0150) 
FILE: lib\sleeptimer_1.asm              (0001) ;;*****************************************************************************
04B4: 43 E0 40 OR    REG[0xE0],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  Filename:   SleepTimer_1.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer User Module software implementation file for the
                                        (0008) ;;                22/24/27/29xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "SleepTimer_1.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name reference for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  SleepTimer_1_EnableInt
                                        (0041) export _SleepTimer_1_EnableInt
                                        (0042) export  SleepTimer_1_DisableInt
                                        (0043) export _SleepTimer_1_DisableInt
                                        (0044) 
                                        (0045) export  SleepTimer_1_Start
                                        (0046) export _SleepTimer_1_Start
                                        (0047) export  SleepTimer_1_Stop
                                        (0048) export _SleepTimer_1_Stop
                                        (0049) 
                                        (0050) export  SleepTimer_1_TickWait
                                        (0051) export _SleepTimer_1_TickWait
                                        (0052) 
                                        (0053) export  SleepTimer_1_SyncWait
                                        (0054) export _SleepTimer_1_SyncWait
                                        (0055) 
                                        (0056) export  SleepTimer_1_SetInterval
                                        (0057) export _SleepTimer_1_SetInterval
                                        (0058) 	
                                        (0059) export  SleepTimer_1_bGetTickCntr
                                        (0060) export _SleepTimer_1_bGetTickCntr
                                        (0061) 
                                        (0062) export  SleepTimer_1_SetTimer
                                        (0063) export _SleepTimer_1_SetTimer
                                        (0064) 
                                        (0065) export  SleepTimer_1_bGetTimer
                                        (0066) export _SleepTimer_1_bGetTimer
                                        (0067) 
                                        (0068) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0069) export  SleepTimer_1_iGetTickCntr
                                        (0070) export _SleepTimer_1_iGetTickCntr
                                        (0071) ENDIF
                                        (0072) 
                                        (0073) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0074) export  SleepTimer_1_lGetTickCntr
                                        (0075) export _SleepTimer_1_lGetTickCntr
                                        (0076) ENDIF
                                        (0077) 
                                        (0078) 
                                        (0079) area text (ROM,REL)
                                        (0080) 
                                        (0081) ;-----------------------------------------------
                                        (0082) ;  EQUATES
                                        (0083) ;-----------------------------------------------
                                        (0084) 
                                        (0085) ; Counter LSB Offset if 4 byte tick counter
                                        (0086) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0087) ST_LSB_OFFSET:   equ  3
                                        (0088) ENDIF
                                        (0089) 
                                        (0090) ; Counter LSB Offset if 2 byte tick counter
                                        (0091) IF(SleepTimer_1_TICK_CNTR_SIZE & 2)
                                        (0092) ST_LSB_OFFSET:   equ  1
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ; Counter LSB Offset if 1 byte tick counter
                                        (0096) IF(SleepTimer_1_TICK_CNTR_SIZE & 1)
                                        (0097) ST_LSB_OFFSET:   equ  0
                                        (0098) ENDIF
                                        (0099) 
                                        (0100) 
                                        (0101) area UserModules (ROM, REL, CON)
                                        (0102) 
                                        (0103) ;=============================================================================
                                        (0104) ;=============================================================================
                                        (0105) ;
                                        (0106) ;     Low-Level Commands
                                        (0107) ;
                                        (0108) ;=============================================================================
                                        (0109) ;=============================================================================
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: SleepTimer_1_EnableInt
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Enables SleepTimer interrupts.
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;
                                        (0119) ;  ARGUMENTS:
                                        (0120) ;     none.
                                        (0121) ;
                                        (0122) ;  RETURNS:
                                        (0123) ;     none.
                                        (0124) ;
                                        (0125) ;  SIDE EFFECTS:
                                        (0126) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0127) ;
                                        (0128) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0129) ;
                                        (0130)  SleepTimer_1_EnableInt:
                                        (0131) _SleepTimer_1_EnableInt:
                                        (0132)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0133)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0134)    RAM_EPILOGUE RAM_USE_CLASS_1
04B7: 7F       RET                      (0135)    ret
                                        (0136) .ENDSECTION
                                        (0137) 
                                        (0138)     
                                        (0139) .SECTION
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;  FUNCTION NAME: SleepTimer_1_DisableInt
                                        (0142) ;
                                        (0143) ;  DESCRIPTION:
                                        (0144) ;     Disables the sleep timer. 
                                        (0145) ;
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     none.
                                        (0150) ;
                                        (0151) ;  RETURNS:
                                        (0152) ;     none.
                                        (0153) ;
                                        (0154) ;  SIDE EFFECTS:
                                        (0155) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0156) ;
                                        (0157) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0158) ;
                                        (0159)  SleepTimer_1_DisableInt:
                                        (0160) _SleepTimer_1_DisableInt:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0163)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0164)    ret
                                        (0165) .ENDSECTION
                                        (0166) 
                                        (0167) 
                                        (0168) .SECTION
                                        (0169) ;-----------------------------------------------------------------------------
                                        (0170) ;  FUNCTION NAME: SleepTimer_1_Start()
                                        (0171) ;
                                        (0172) ;  DESCRIPTION:
                                        (0173) ;     Clears all the variables.  
                                        (0174) ;-----------------------------------------------------------------------------
                                        (0175) ;
                                        (0176) ;  ARGUMENTS:
                                        (0177) ;      none
                                        (0178) ;
                                        (0179) ;  RETURNS:
                                        (0180) ;     none.
                                        (0181) ;
                                        (0182) ;  SIDE EFFECTS;    
                                        (0183) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0184) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0185) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0186) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0187) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0188) ;          
                                        (0189) ;    Page Pointer Registers Modified: 
                                        (0190) ;          CUR_PP
                                        (0191) ;
                                        (0192) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0193) ;
                                        (0194)  SleepTimer_1_Start:
                                        (0195) _SleepTimer_1_Start:
                                        (0196)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0197)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04B8: 50 00    MOV   A,0x0              (0198)    mov  A,0
04BA: 53 18    MOV   [0x18],A           (0199)    mov  [SleepTimer_1_fTick],A
04BC: 53 19    MOV   [0x19],A           (0200)    mov  [SleepTimer_1_bTimerValue],A
04BE: 53 1A    MOV   [0x1A],A           (0201)    mov  [SleepTimer_1_bCountDown],A
04C0: 53 1C    MOV   [0x1C],A           (0202)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET],A        ; Clear TickCount[0:7]
                                        (0203) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
04C2: 53 1B    MOV   [0x1B],A           (0204)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET - 1],A    ; Clear TickCount[8:15]
                                        (0205) ENDIF
                                        (0206) 
                                        (0207) 
                                        (0208) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0209)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 2],A    ; Clear TickCount[16:31]
                                        (0210)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 3],A    
                                        (0211) ENDIF
                                        (0212) 
                                        (0213) 
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_4
04C4: 7F       RET                      (0215)    ret
                                        (0216) .ENDSECTION
                                        (0217) 
                                        (0218) 
                                        (0219) .SECTION
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;  FUNCTION NAME: SleepTimer_1_Stop
                                        (0222) ;
                                        (0223) ;  DESCRIPTION:
                                        (0224) ;   This function does nothing at this time.  It is only here as a place 
                                        (0225) ;   holder.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;
                                        (0228) ;  ARGUMENTS:
                                        (0229) ;     none.
                                        (0230) ;
                                        (0231) ;  RETURNS:
                                        (0232) ;     none.
                                        (0233) ;
                                        (0234) ;  SIDE EFFECTS:
                                        (0235) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0238) ;
                                        (0239)  SleepTimer_1_Stop:
                                        (0240) _SleepTimer_1_Stop:
                                        (0241)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0242)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0243)    ret
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: SleepTimer_1_SetInterval
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Sets sleep timer interval
                                        (0252) ;
                                        (0253) ;-----------------------------------------------------------------------------
                                        (0254) ;
                                        (0255) ;  ARGUMENTS:
                                        (0256) ;     A <= Timer setting
                                        (0257) ;
                                        (0258) ;  RETURNS:
                                        (0259) ;     none.
                                        (0260) ;
                                        (0261) ;  SIDE EFFECTS:
                                        (0262) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0263) ;
                                        (0264) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0265) ;
                                        (0266)  SleepTimer_1_SetInterval:
                                        (0267) _SleepTimer_1_SetInterval:
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0269)    and  A,SleepTimer_1_CLOCK_MASK               ; Mask off invalid data
                                        (0270)    mov  X, SP
                                        (0271)    push A
                                        (0272)    M8C_SetBank1
                                        (0273)    mov  A, reg[OSC_CR0]                  ; Get current timer value
                                        (0274)    and  A,~SleepTimer_1_CLOCK_MASK   ; Zero out old timer value
                                        (0275)    or   A, [X]                           ; Set new timer values
                                        (0276)    mov  reg[OSC_CR0],A                   ; Write it
                                        (0277)    M8C_SetBank0
                                        (0278)    pop  A
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0280)    ret
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) 
                                        (0284) .SECTION
                                        (0285) ;-----------------------------------------------------------------------------
                                        (0286) ;  FUNCTION NAME: SleepTimer_1_TickWait(BYTE bTicks)
                                        (0287) ;
                                        (0288) ;  DESCRIPTION:
                                        (0289) ;     Wait X Ticks and return
                                        (0290) ;
                                        (0291) ;-----------------------------------------------------------------------------
                                        (0292) ;
                                        (0293) ;  ARGUMENTS:
                                        (0294) ;     A <= Count down time
                                        (0295) ;
                                        (0296) ;  RETURNS:
                                        (0297) ;     none.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS;    
                                        (0300) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0301) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0302) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0303) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0304) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0305) ;          
                                        (0306) ;    Page Pointer Registers Modified: 
                                        (0307) ;          CUR_PP
                                        (0308) ;
                                        (0309) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0310) ;
                                        (0311)  SleepTimer_1_TickWait:
                                        (0312) _SleepTimer_1_TickWait:
                                        (0313)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0314)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04C5: 55 18 00 MOV   [0x18],0x0         (0315)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
                                        (0316) 
                                        (0317) .WaitTick:
04C8: 47 18 FF TST   [0x18],0xFF        (0318)    tst   [SleepTimer_1_fTick],0xFF          ; Check for tick 
04CB: AF FC    JZ    0x04C8             (0319)    jz    .WaitTick
04CD: 55 18 00 MOV   [0x18],0x0         (0320)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
04D0: 78       DEC   A                  (0321)    dec   A                                      ; Dec the timer variable
04D1: BF F6    JNZ   0x04C8             (0322)    jnz   .WaitTick                              ; Loop until we count down to zero
                                        (0323) 
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
04D3: 7F       RET                      (0325)    ret
04D4: 41 E0 BF AND   REG[0xE0],0xBF     
                                        (0326) .ENDSECTION
                                        (0327) 
                                        (0328) 
                                        (0329) .SECTION
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: SleepTimer_1_SyncWait(BYTE bCounts, BYTE fMode)
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:
                                        (0334) ;     This function resets the SyncWait timer.  If fMode = 0, the timer
                                        (0335) ;     is set to the new value then exits the function immediatly.  If fMode
                                        (0336) ;     is set to 1, the firmware waits for the timer to expire before the
                                        (0337) ;     timer is reset and and exits.
                                        (0338) ;
                                        (0339) ;-----------------------------------------------------------------------------
                                        (0340) ;
                                        (0341) ;  ARGUMENTS:
                                        (0342) ;     A <= tCounts to wait
                                        (0343) ;     X <= fMode    fMode = 0  Just reload the value, do not wait
                                        (0344) ;                   fMode = 1  Wait for last value to count down to zero
                                        (0345) ;                              then reload.
                                        (0346) ;
                                        (0347) ;  RETURNS:
                                        (0348) ;     none.
                                        (0349) ;
                                        (0350) ;  SIDE EFFECTS;    
                                        (0351) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0352) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0353) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0354) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0355) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0356) ;          
                                        (0357) ;    Page Pointer Registers Modified: 
                                        (0358) ;          CUR_PP
                                        (0359) ;
                                        (0360) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0361) ;
                                        (0362)  SleepTimer_1_SyncWait:
                                        (0363) _SleepTimer_1_SyncWait:
                                        (0364)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0365)    RAM_SETPAGE_CUR >SleepTimer_1_bCountDown
                                        (0366)    swap  A,X
                                        (0367)    AND   A,SleepTimer_1_FORCE_RELOAD
                                        (0368)    jnz   .ReloadIt
                                        (0369) 
                                        (0370) .WaitLoop:
                                        (0371)    tst   [SleepTimer_1_bCountDown],0xFF
                                        (0372)    jnz   .WaitLoop
                                        (0373) 
                                        (0374) 
                                        (0375) .ReloadIt:
                                        (0376)    swap  A,X
                                        (0377)    mov   [SleepTimer_1_bCountDown],A 
                                        (0378) 
                                        (0379)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0380)    ret
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) 
                                        (0384) 
                                        (0385) .SECTION
                                        (0386) ;-----------------------------------------------------------------------------
                                        (0387) ;  FUNCTION NAME: SleepTimer_1_bGetTickCntr
                                        (0388) ;
                                        (0389) ;  DESCRIPTION:
                                        (0390) ;     Returns the LSB of the tick Counter
                                        (0391) ;
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;
                                        (0394) ;  ARGUMENTS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  RETURNS:
                                        (0398) ;     LSB of lTickCount
                                        (0399) ;
                                        (0400) ;  SIDE EFFECTS;    
                                        (0401) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0402) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0403) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0404) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0405) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0406) ;          
                                        (0407) ;    Page Pointer Registers Modified: 
                                        (0408) ;          CUR_PP
                                        (0409) ;
                                        (0410) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0411) ;
                                        (0412)  SleepTimer_1_bGetTickCntr:
                                        (0413) _SleepTimer_1_bGetTickCntr:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0415)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0416)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]
                                        (0417)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0418)    ret
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) .SECTION
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;  FUNCTION NAME: SleepTimer_1_SetTimer
                                        (0424) ;
                                        (0425) ;  DESCRIPTION:
                                        (0426) ;     Set timer with parameter in A
                                        (0427) ;
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;
                                        (0430) ;  ARGUMENTS:
                                        (0431) ;     A => Value used to set Timer value
                                        (0432) ;
                                        (0433) ;  RETURNS:
                                        (0434) ;     None
                                        (0435) ;
                                        (0436) ;  SIDE EFFECTS;    
                                        (0437) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0438) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0439) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0440) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0441) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0442) ;          
                                        (0443) ;    Page Pointer Registers Modified: 
                                        (0444) ;          CUR_PP
                                        (0445) ;
                                        (0446) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0447) ;
                                        (0448)  SleepTimer_1_SetTimer:
                                        (0449) _SleepTimer_1_SetTimer:
                                        (0450)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0451)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0452)    mov   [SleepTimer_1_bTimerValue],A
                                        (0453)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0454)    ret
                                        (0455) .ENDSECTION
                                        (0456) 
                                        (0457) .SECTION
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: SleepTimer_1_bGetTimer
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:
                                        (0462) ;     Returns timer value in A
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;     None
                                        (0468) ;
                                        (0469) ;  RETURNS:
                                        (0470) ;     Return timer value in A
                                        (0471) ;
                                        (0472) ;  SIDE EFFECTS;    
                                        (0473) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0474) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0475) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0476) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0477) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0478) ;          
                                        (0479) ;    Page Pointer Registers Modified: 
                                        (0480) ;          CUR_PP
                                        (0481) ;
                                        (0482) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0483) ;
                                        (0484)  SleepTimer_1_bGetTimer:
                                        (0485) _SleepTimer_1_bGetTimer:
                                        (0486)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0487)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0488)    mov   A,[SleepTimer_1_bTimerValue]
                                        (0489)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0490)    ret
                                        (0491) .ENDSECTION
                                        (0492) 
                                        (0493) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0494) .SECTION
                                        (0495) ;-----------------------------------------------------------------------------
                                        (0496) ;  FUNCTION NAME: SleepTimer_1_iGetTickCntr
                                        (0497) ;
                                        (0498) ;  DESCRIPTION:
                                        (0499) ;     Returns the least significant 16 bits.
                                        (0500) ;
                                        (0501) ;-----------------------------------------------------------------------------
                                        (0502) ;
                                        (0503) ;  ARGUMENTS:
                                        (0504) ;     none
                                        (0505) ;
                                        (0506) ;  RETURNS:
                                        (0507) ;     (int)TickCount in A and X  
                                        (0508) ;     X  <= MSB
                                        (0509) ;     A  <= LSB
                                        (0510) ;
                                        (0511) ;  SIDE EFFECTS;    
                                        (0512) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0513) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0514) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0515) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0516) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0517) ;          
                                        (0518) ;    Page Pointer Registers Modified: 
                                        (0519) ;          CUR_PP
                                        (0520) ;
                                        (0521) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0522) ;
                                        (0523)  SleepTimer_1_iGetTickCntr:
                                        (0524) _SleepTimer_1_iGetTickCntr:
                                        (0525)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0526)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0527)    ; Disable interrupt here
                                        (0528)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
04D7: 51 1C    MOV   A,[0x1C]           (0529)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]    ; Place LSB in A
04D9: 58 1B    MOV   X,[0x1B]           (0530)    mov   X,[SleepTimer_1_TickCount + ST_LSB_OFFSET - 1]    ; Place MSB in X
04DB: 43 E0 40 OR    REG[0xE0],0x40     
                                        (0531)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0532)    RAM_EPILOGUE RAM_USE_CLASS_4
04DE: 7F       RET                      (0533)    ret
                                        (0534) .ENDSECTION
                                        (0535) ENDIF
                                        (0536) 
                                        (0537) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0538) .SECTION
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ;  FUNCTION NAME: SleepTimer_1_lGetTickCntr
                                        (0541) ;
                                        (0542) ;  DESCRIPTION:
                                        (0543) ;     Returns a pointer to TickCount
                                        (0544) ;
                                        (0545) ;-----------------------------------------------------------------------------
                                        (0546) ;
                                        (0547) ;  ARGUMENTS:
                                        (0548) ;     [A:X] => Pointer to 32 bit tick counter (X=LSB, A=MSB)
                                        (0549) ;
                                        (0550) ;  RETURNS:
                                        (0551) ;     Pointer to lTickCount
                                        (0552) ;
                                        (0553) ;  SIDE EFFECTS;    
                                        (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0555) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0556) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0557) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0558) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0559) ;          
                                        (0560) ;    Page Pointer Registers Modified: 
                                        (0561) ;          CUR_PP
                                        (0562) ;
                                        (0563) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0564) ;
                                        (0565)  SleepTimer_1_lGetTickCntr:
                                        (0566) _SleepTimer_1_lGetTickCntr:
                                        (0567)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0568)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0569)    ; Disable interrupt here
                                        (0570)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0571)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0572)    RAM_SETPAGE_IDX A
                                        (0573)    push  A
                                        (0574)    mov   A,[SleepTimer_1_TickCount + 0]
                                        (0575)    mov   [X + 0],A
                                        (0576)    mov   A,[SleepTimer_1_TickCount + 1]
                                        (0577)    mov   [X + 1],A
                                        (0578)    mov   A,[SleepTimer_1_TickCount + 2]
                                        (0579)    mov   [X + 2],A
                                        (0580)    mov   A,[SleepTimer_1_TickCount + 3]
                                        (0581)    mov   [X + 3],A
                                        (0582)    pop   A
                                        (0583)    
                                        (0584)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0585)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0587)    ret
                                        (0588) .ENDSECTION
                                        (0589) ENDIF
                                        (0590) 
                                        (0591) 
                                        (0592) 
                                        (0593) 
                                        (0594) ; End of File SleepTimer_1.asm
FILE: lib\rst.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   RST.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "RST.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _RST_Start
                                        (0027) export  RST_Start
                                        (0028) 
                                        (0029) export _RST_Stop
                                        (0030) export  RST_Stop
                                        (0031) 
                                        (0032) export _RST_On
                                        (0033) export  RST_On
                                        (0034) 
                                        (0035) export _RST_Off
                                        (0036) export  RST_Off
                                        (0037) 
                                        (0038) export _RST_Switch
                                        (0039) export  RST_Switch
                                        (0040) 
                                        (0041) export _RST_Invert
                                        (0042) export  RST_Invert
                                        (0043) 
                                        (0044) export _RST_GetState
                                        (0045) export  RST_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: RST_Start(void)
                                        (0054) ;  FUNCTION NAME: RST_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: RST_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _RST_On:
                                        (0079)  RST_On:
04DF: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
04E1: 80 03    JMP   _RST_Switch        (0081)    jmp  RST_Switch 
                                        (0082) 
                                        (0083) _RST_Start:
                                        (0084)  RST_Start:
                                        (0085) _RST_Stop:
                                        (0086)  RST_Stop:
                                        (0087) _RST_Off:
                                        (0088)  RST_Off:
04E3: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _RST_Switch:
                                        (0092)  RST_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
04E5: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
04E7: A0 06    JZ    0x04EE             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
04E9: 2E 1D 10 OR    [0x1D],0x10        (0102)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0105) ENDIF
04EC: 80 04    JMP   0x04F1             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
04EE: 26 1D EF AND   [0x1D],0xEF        (0110)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
04F1: 51 1D    MOV   A,[0x1D]           (0116)    mov  A,[Port_0_Data_SHADE]
04F3: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[RST_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
04F5: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: RST_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _RST_Invert:
                                        (0144)  RST_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],RST_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[RST_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: RST_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _RST_GetState:
                                        (0177)  RST_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,RST_PinMask                 ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\pwm16_1int.asm                (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:26:51
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM16_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
04F6: 7D 1C 7E LJMP  _PWM16_1_CMP_ISR   (0081)    ljmp _PWM16_1_CMP_ISR
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
04F9: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWM16_1INT.asm
FILE: lib\pwm16_1.asm                   (0001) ;;*****************************************************************************
04FA: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:26:51
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM16_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM16_1_EnableInt
                                        (0030) export _PWM16_1_EnableInt
                                        (0031) export  PWM16_1_DisableInt
                                        (0032) export _PWM16_1_DisableInt
                                        (0033) export  PWM16_1_Start
                                        (0034) export _PWM16_1_Start
                                        (0035) export  PWM16_1_Stop
                                        (0036) export _PWM16_1_Stop
                                        (0037) export  PWM16_1_WritePeriod
                                        (0038) export _PWM16_1_WritePeriod
                                        (0039) export  PWM16_1_WritePulseWidth
                                        (0040) export _PWM16_1_WritePulseWidth
                                        (0041) export  PWM16_1_wReadPulseWidth
                                        (0042) export _PWM16_1_wReadPulseWidth
                                        (0043) export  PWM16_1_wReadCounter
                                        (0044) export _PWM16_1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0049) export _wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0050) export  wPWM16_1_ReadCounter       ; deprecated
                                        (0051) export _wPWM16_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA dsm_reciver_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM16_1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM16_1_EnableInt:
                                        (0091) _PWM16_1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM16_1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
04FD: 7F       RET                      (0095)    ret
04FE: 43 23 01 OR    REG[0x23],0x1      
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM16_1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM16_1_DisableInt:
                                        (0119) _PWM16_1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM16_1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0123)    ret
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM16_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM16_1_Start:
                                        (0148) _PWM16_1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM16_1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0501: 7F       RET                      (0152)    ret
0502: 41 23 FE AND   REG[0x23],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM16_1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM16_1_Stop:
                                        (0176) _PWM16_1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM16_1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0505: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM16_1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM16_1_WritePeriod:
                                        (0206) _PWM16_1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0506: 60 21    MOV   REG[0x21],A        (0208)    mov   reg[PWM16_1_PERIOD_LSB_REG], A
0508: 5B       MOV   A,X                (0209)    mov   A, X
0509: 60 25    MOV   REG[0x25],A        (0210)    mov   reg[PWM16_1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
050B: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: PWM16_1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  PWM16_1_WritePulseWidth:
                                        (0235) _PWM16_1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
050C: 60 22    MOV   REG[0x22],A        (0237)    mov   reg[PWM16_1_COMPARE_LSB_REG], A
050E: 5B       MOV   A,X                (0238)    mov   A, X
050F: 60 26    MOV   REG[0x26],A        (0239)    mov   reg[PWM16_1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0511: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: PWM16_1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  PWM16_1_wReadPulseWidth:
                                        (0264) _PWM16_1_wReadPulseWidth:
                                        (0265)  wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0266) _wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0268)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]
                                        (0269)    mov   X, A
                                        (0270)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: PWM16_1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  PWM16_1_wReadCounter:
                                        (0299) _PWM16_1_wReadCounter:
                                        (0300)  wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0301) _wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0309)    mov   X, SP                                      ; X <-  stack frame pointer
                                        (0310)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Save the Compare register on the stack
                                        (0311)    push  A                                          ;
                                        (0312)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ;
                                        (0313)    push  A                                          ;  -stack frame now 2 bytes-
                                        (0314)    PWM16_1_Stop_M                                ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
                                        (0316)    mov   A, reg[PWM16_1_INPUT_LSB_REG]           ; save the LSB clock input setting
                                        (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
                                        (0319)    mov   reg[PWM16_1_INPUT_LSB_REG], INPUT_REG_NULL
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
                                        (0321)    mov   A, reg[PWM16_1_COUNTER_MSB_REG]         ; DR2 <- DR0 (in the MSB block)
                                        (0322)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Stash the Count MSB on the stack
                                        (0323)    push  A                                          ;  -stack frame is now 4 bytes
                                        (0324)    mov   A, reg[PWM16_1_COUNTER_LSB_REG]         ; DR2 <- DR0 (in the LSB block)
                                        (0325)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ; Stash the Count LSB on the stack
                                        (0326)    push  A                                          ;   -stack frame is now 5 bytes-
                                        (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
                                        (0328)    mov   reg[PWM16_1_COMPARE_MSB_REG], A         ;
                                        (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
                                        (0330)    mov   reg[PWM16_1_COMPARE_LSB_REG], A         ;
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
                                        (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
                                        (0333)    mov   reg[PWM16_1_INPUT_LSB_REG], A           ;    and restore it
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    PWM16_1_Start_M                               ; Now re-enable the PWM function
                                        (0336)    pop   A                                          ; Setup the return value
                                        (0337)    pop   X                                          ;
                                        (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File PWM16_1.asm
FILE: lib\led_1_7.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_7.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_7.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_7_Start
                                        (0027) export  LED_1_7_Start
                                        (0028) 
                                        (0029) export _LED_1_7_Stop
                                        (0030) export  LED_1_7_Stop
                                        (0031) 
                                        (0032) export _LED_1_7_On
                                        (0033) export  LED_1_7_On
                                        (0034) 
                                        (0035) export _LED_1_7_Off
                                        (0036) export  LED_1_7_Off
                                        (0037) 
                                        (0038) export _LED_1_7_Switch
                                        (0039) export  LED_1_7_Switch
                                        (0040) 
                                        (0041) export _LED_1_7_Invert
                                        (0042) export  LED_1_7_Invert
                                        (0043) 
                                        (0044) export _LED_1_7_GetState
                                        (0045) export  LED_1_7_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_7_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_7_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_7_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_7_On:
                                        (0079)  LED_1_7_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_7_Switch 
                                        (0082) 
                                        (0083) _LED_1_7_Start:
                                        (0084)  LED_1_7_Start:
                                        (0085) _LED_1_7_Stop:
                                        (0086)  LED_1_7_Stop:
                                        (0087) _LED_1_7_Off:
                                        (0088)  LED_1_7_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_7_Switch:
                                        (0092)  LED_1_7_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0512: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0514: A0 06    JZ    0x051B             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0516: 2E 1E 80 OR    [0x1E],0x80        (0102)    or   [Port_1_Data_SHADE],LED_1_7_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_7_PinMask
                                        (0105) ENDIF
0519: 80 04    JMP   0x051E             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
051B: 26 1E 7F AND   [0x1E],0x7F        (0110)    and  [Port_1_Data_SHADE],~LED_1_7_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_7_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
051E: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0520: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_7_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0522: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_7_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_7_Invert:
                                        (0144)  LED_1_7_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_7_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_7_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_7_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_7_GetState:
                                        (0177)  LED_1_7_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_7_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1_6.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_6.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_6.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_6_Start
                                        (0027) export  LED_1_6_Start
                                        (0028) 
                                        (0029) export _LED_1_6_Stop
                                        (0030) export  LED_1_6_Stop
                                        (0031) 
                                        (0032) export _LED_1_6_On
                                        (0033) export  LED_1_6_On
                                        (0034) 
                                        (0035) export _LED_1_6_Off
                                        (0036) export  LED_1_6_Off
                                        (0037) 
                                        (0038) export _LED_1_6_Switch
                                        (0039) export  LED_1_6_Switch
                                        (0040) 
                                        (0041) export _LED_1_6_Invert
                                        (0042) export  LED_1_6_Invert
                                        (0043) 
                                        (0044) export _LED_1_6_GetState
                                        (0045) export  LED_1_6_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_6_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_6_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_6_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_6_On:
                                        (0079)  LED_1_6_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_6_Switch 
                                        (0082) 
                                        (0083) _LED_1_6_Start:
                                        (0084)  LED_1_6_Start:
                                        (0085) _LED_1_6_Stop:
                                        (0086)  LED_1_6_Stop:
                                        (0087) _LED_1_6_Off:
                                        (0088)  LED_1_6_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_6_Switch:
                                        (0092)  LED_1_6_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0523: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0525: A0 06    JZ    0x052C             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0527: 2E 1E 40 OR    [0x1E],0x40        (0102)    or   [Port_1_Data_SHADE],LED_1_6_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_6_PinMask
                                        (0105) ENDIF
052A: 80 04    JMP   0x052F             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
052C: 26 1E BF AND   [0x1E],0xBF        (0110)    and  [Port_1_Data_SHADE],~LED_1_6_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_6_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
052F: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0531: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_6_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0533: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_6_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_6_Invert:
                                        (0144)  LED_1_6_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_6_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_6_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_6_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_6_GetState:
                                        (0177)  LED_1_6_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_6_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1_5.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_5.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_5.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_5_Start
                                        (0027) export  LED_1_5_Start
                                        (0028) 
                                        (0029) export _LED_1_5_Stop
                                        (0030) export  LED_1_5_Stop
                                        (0031) 
                                        (0032) export _LED_1_5_On
                                        (0033) export  LED_1_5_On
                                        (0034) 
                                        (0035) export _LED_1_5_Off
                                        (0036) export  LED_1_5_Off
                                        (0037) 
                                        (0038) export _LED_1_5_Switch
                                        (0039) export  LED_1_5_Switch
                                        (0040) 
                                        (0041) export _LED_1_5_Invert
                                        (0042) export  LED_1_5_Invert
                                        (0043) 
                                        (0044) export _LED_1_5_GetState
                                        (0045) export  LED_1_5_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_5_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_5_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_5_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_5_On:
                                        (0079)  LED_1_5_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_5_Switch 
                                        (0082) 
                                        (0083) _LED_1_5_Start:
                                        (0084)  LED_1_5_Start:
                                        (0085) _LED_1_5_Stop:
                                        (0086)  LED_1_5_Stop:
                                        (0087) _LED_1_5_Off:
                                        (0088)  LED_1_5_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_5_Switch:
                                        (0092)  LED_1_5_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0534: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0536: A0 06    JZ    0x053D             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0538: 2E 1E 20 OR    [0x1E],0x20        (0102)    or   [Port_1_Data_SHADE],LED_1_5_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_5_PinMask
                                        (0105) ENDIF
053B: 80 04    JMP   0x0540             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
053D: 26 1E DF AND   [0x1E],0xDF        (0110)    and  [Port_1_Data_SHADE],~LED_1_5_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_5_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0540: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0542: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_5_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0544: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_5_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_5_Invert:
                                        (0144)  LED_1_5_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_5_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_5_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_5_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_5_GetState:
                                        (0177)  LED_1_5_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_5_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1_4.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_4.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_4.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_4_Start
                                        (0027) export  LED_1_4_Start
                                        (0028) 
                                        (0029) export _LED_1_4_Stop
                                        (0030) export  LED_1_4_Stop
                                        (0031) 
                                        (0032) export _LED_1_4_On
                                        (0033) export  LED_1_4_On
                                        (0034) 
                                        (0035) export _LED_1_4_Off
                                        (0036) export  LED_1_4_Off
                                        (0037) 
                                        (0038) export _LED_1_4_Switch
                                        (0039) export  LED_1_4_Switch
                                        (0040) 
                                        (0041) export _LED_1_4_Invert
                                        (0042) export  LED_1_4_Invert
                                        (0043) 
                                        (0044) export _LED_1_4_GetState
                                        (0045) export  LED_1_4_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_4_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_4_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_4_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_4_On:
                                        (0079)  LED_1_4_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_4_Switch 
                                        (0082) 
                                        (0083) _LED_1_4_Start:
                                        (0084)  LED_1_4_Start:
                                        (0085) _LED_1_4_Stop:
                                        (0086)  LED_1_4_Stop:
                                        (0087) _LED_1_4_Off:
                                        (0088)  LED_1_4_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_4_Switch:
                                        (0092)  LED_1_4_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0545: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0547: A0 06    JZ    0x054E             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
0549: 2E 1E 10 OR    [0x1E],0x10        (0102)    or   [Port_1_Data_SHADE],LED_1_4_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_4_PinMask
                                        (0105) ENDIF
054C: 80 04    JMP   0x0551             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
054E: 26 1E EF AND   [0x1E],0xEF        (0110)    and  [Port_1_Data_SHADE],~LED_1_4_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_4_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0551: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0553: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_4_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0555: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_4_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_4_Invert:
                                        (0144)  LED_1_4_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_4_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_4_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_4_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_4_GetState:
                                        (0177)  LED_1_4_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_4_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1_1.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_1.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_1_Start
                                        (0027) export  LED_1_1_Start
                                        (0028) 
                                        (0029) export _LED_1_1_Stop
                                        (0030) export  LED_1_1_Stop
                                        (0031) 
                                        (0032) export _LED_1_1_On
                                        (0033) export  LED_1_1_On
                                        (0034) 
                                        (0035) export _LED_1_1_Off
                                        (0036) export  LED_1_1_Off
                                        (0037) 
                                        (0038) export _LED_1_1_Switch
                                        (0039) export  LED_1_1_Switch
                                        (0040) 
                                        (0041) export _LED_1_1_Invert
                                        (0042) export  LED_1_1_Invert
                                        (0043) 
                                        (0044) export _LED_1_1_GetState
                                        (0045) export  LED_1_1_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_1_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_1_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_1_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_1_On:
                                        (0079)  LED_1_1_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_1_Switch 
                                        (0082) 
                                        (0083) _LED_1_1_Start:
                                        (0084)  LED_1_1_Start:
                                        (0085) _LED_1_1_Stop:
                                        (0086)  LED_1_1_Stop:
                                        (0087) _LED_1_1_Off:
                                        (0088)  LED_1_1_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_1_Switch:
                                        (0092)  LED_1_1_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0556: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0558: A0 06    JZ    0x055F             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
055A: 2E 1E 02 OR    [0x1E],0x2         (0102)    or   [Port_1_Data_SHADE],LED_1_1_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_1_PinMask
                                        (0105) ENDIF
055D: 80 04    JMP   0x0562             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
055F: 26 1E FD AND   [0x1E],0xFD        (0110)    and  [Port_1_Data_SHADE],~LED_1_1_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_1_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0562: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0564: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_1_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0566: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_1_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_1_Invert:
                                        (0144)  LED_1_1_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_1_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_1_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_1_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_1_GetState:
                                        (0177)  LED_1_1_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_1_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1_0.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1_0.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1_0.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_0_Start
                                        (0027) export  LED_1_0_Start
                                        (0028) 
                                        (0029) export _LED_1_0_Stop
                                        (0030) export  LED_1_0_Stop
                                        (0031) 
                                        (0032) export _LED_1_0_On
                                        (0033) export  LED_1_0_On
                                        (0034) 
                                        (0035) export _LED_1_0_Off
                                        (0036) export  LED_1_0_Off
                                        (0037) 
                                        (0038) export _LED_1_0_Switch
                                        (0039) export  LED_1_0_Switch
                                        (0040) 
                                        (0041) export _LED_1_0_Invert
                                        (0042) export  LED_1_0_Invert
                                        (0043) 
                                        (0044) export _LED_1_0_GetState
                                        (0045) export  LED_1_0_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_0_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_0_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_0_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_0_On:
                                        (0079)  LED_1_0_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_0_Switch 
                                        (0082) 
                                        (0083) _LED_1_0_Start:
                                        (0084)  LED_1_0_Start:
                                        (0085) _LED_1_0_Stop:
                                        (0086)  LED_1_0_Stop:
                                        (0087) _LED_1_0_Off:
                                        (0088)  LED_1_0_Off:
                                        (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_0_Switch:
                                        (0092)  LED_1_0_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
0567: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0569: A0 06    JZ    0x0570             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
056B: 2E 1E 01 OR    [0x1E],0x1         (0102)    or   [Port_1_Data_SHADE],LED_1_0_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_0_PinMask
                                        (0105) ENDIF
056E: 80 04    JMP   0x0573             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
0570: 26 1E FE AND   [0x1E],0xFE        (0110)    and  [Port_1_Data_SHADE],~LED_1_0_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_0_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0573: 51 1E    MOV   A,[0x1E]           (0116)    mov  A,[Port_1_Data_SHADE]
0575: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_0_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0577: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_0_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_0_Invert:
                                        (0144)  LED_1_0_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_1_Data_SHADE],LED_1_0_PinMask
                                        (0150)    mov  A,[Port_1_Data_SHADE]
                                        (0151)    mov  reg[LED_1_0_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_0_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_0_GetState:
                                        (0177)  LED_1_0_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_0_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_Start
                                        (0027) export  LED_1_Start
                                        (0028) 
                                        (0029) export _LED_1_Stop
                                        (0030) export  LED_1_Stop
                                        (0031) 
                                        (0032) export _LED_1_On
                                        (0033) export  LED_1_On
                                        (0034) 
                                        (0035) export _LED_1_Off
                                        (0036) export  LED_1_Off
                                        (0037) 
                                        (0038) export _LED_1_Switch
                                        (0039) export  LED_1_Switch
                                        (0040) 
                                        (0041) export _LED_1_Invert
                                        (0042) export  LED_1_Invert
                                        (0043) 
                                        (0044) export _LED_1_GetState
                                        (0045) export  LED_1_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_On:
                                        (0079)  LED_1_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_Switch 
                                        (0082) 
                                        (0083) _LED_1_Start:
                                        (0084)  LED_1_Start:
                                        (0085) _LED_1_Stop:
                                        (0086)  LED_1_Stop:
                                        (0087) _LED_1_Off:
                                        (0088)  LED_1_Off:
0578: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_Switch:
                                        (0092)  LED_1_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0096) 
057A: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
057C: A0 06    JZ    0x0583             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(0)                                            ; Active High Digit Drive
                                        (0102)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
057E: 26 1F FE AND   [0x1F],0xFE        (0104)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0105) ENDIF
0581: 80 04    JMP   0x0586             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(0)                      ; Active High Digit Drive
                                        (0110)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
0583: 2E 1F 01 OR    [0x1F],0x1         (0112)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0586: 51 1F    MOV   A,[0x1F]           (0116)    mov  A,[Port_3_Data_SHADE]
0588: 60 0C    MOV   REG[0xC],A         (0117)    mov  reg[LED_1_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
058A: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_Invert:
                                        (0144)  LED_1_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_3_Data_SHADE],LED_1_PinMask
                                        (0150)    mov  A,[Port_3_Data_SHADE]
                                        (0151)    mov  reg[LED_1_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_GetState:
                                        (0177)  LED_1_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_3_Data_SHADE]         ; Get shade value
                                        (0183) IF(0)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_PinMask               ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\e2prom_1.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   E2PROM_1.asm
                                        (0004) ;;  Version: 1.7, Updated on 2015/3/4 at 22:26:11
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: EEPROM emulation User Module implementation file.
                                        (0008) ;;
                                        (0009) ;;     Routines in this file perform E2PROM_1 User Module Read and
                                        (0010) ;;     Write operations.
                                        (0011) ;;
                                        (0012) ;;     They provide a layer of abstraction on top of the E2PROMLIB.asm routines
                                        (0013) ;;     to allow instancing of the EEPROM devices.  Together the E2PROM and
                                        (0014) ;;     E2PROMLIB algorithms emulate a byte-wise EEPROM device on a block oriented
                                        (0015) ;;     flash architecture.
                                        (0016) ;;
                                        (0017) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0018) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0019) ;;        This means it is the caller's responsibility to preserve any values
                                        (0020) ;;        in the X and A registers that are still needed after the API functions
                                        (0021) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0022) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0023) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0024) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0025) ;;-----------------------------------------------------------------------------
                                        (0026) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0027) ;;*****************************************************************************
                                        (0028) ;;*****************************************************************************
                                        (0029) 
                                        (0030) ;Preset CPU_EQUATE for CY8C25/26xxx identification
                                        (0031) CPU_F:   equ   0
                                        (0032) 
                                        (0033) include "m8c.inc"
                                        (0034) include "E2PROM_1.inc"
                                        (0035) include "memory.inc"
                                        (0036) 
                                        (0037) ;-------------------------------------------------------------------
                                        (0038) ;  Declare the functions global for both assembler and C compiler.
                                        (0039) ;
                                        (0040) ;  Note that there are two names for each API. First name is
                                        (0041) ;  assembler reference. Name with underscore is name refence for
                                        (0042) ;  C compiler.  Calling function in C source code does not require
                                        (0043) ;  the underscore.
                                        (0044) ;-------------------------------------------------------------------
                                        (0045) 
                                        (0046) ;-----------------------------------------------
                                        (0047) ;  Global Symbols
                                        (0048) ;-----------------------------------------------
                                        (0049) 
                                        (0050) export   E2PROM_1_Start
                                        (0051) export  _E2PROM_1_Start
                                        (0052) export   E2PROM_1_Stop
                                        (0053) export  _E2PROM_1_Stop
                                        (0054) export   E2PROM_1_bE2Write
                                        (0055) export  _E2PROM_1_bE2Write
                                        (0056) export   E2PROM_1_E2Read
                                        (0057) export  _E2PROM_1_E2Read
                                        (0058) 
                                        (0059) export   E2PROM_1_RESERVED
                                        (0060) 
                                        (0061) ;-----------------------------------------------------------------
                                        (0062) ;  Allocate the E2PROM_1 EEPROM device in Flash memory
                                        (0063) ;     This will allow the linker to perform memory collision
                                        (0064) ;     checking and the EEPROM device will be displayed in the
                                        (0065) ;     map file.
                                        (0066) ;     Note that this memory region can also be accessed from "C".
                                        (0067) ;-----------------------------------------------------------------
                                        (0068) AREA  E2PROM_1_AREA   (ROM,ABS,CON)
                                        (0069)    ORG   E2PROM_1_START_ADDR
                                        (0070) 
                                        (0071) _E2PROM_1_RESERVED::
                                        (0072)  E2PROM_1_RESERVED::     blkb     40h
                                        (0073) 
                                        (0074) 
                                        (0075) AREA  UserModules (ROM,REL)
                                        (0076) 
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: E2PROM_1_Start
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Start routine for the E2PROM_1 user module.  This routine is
                                        (0082) ;     a place holder for conformance and consistency.
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS:
                                        (0086) ;     None
                                        (0087) ;
                                        (0088) ;  RETURNS:
                                        (0089) ;     None
                                        (0090) ;
                                        (0091) ;  SIDE EFFECTS: 
                                        (0092) ;    The A and X registers may be modified by this or future implementations
                                        (0093) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0094) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0095) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0096) ;    functions.
                                        (0097) ;
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)  E2PROM_1_Start:
                                        (0101) _E2PROM_1_Start:
                                        (0102)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
058B: 7F       RET                      (0104)    ret
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) 
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: E2PROM_1_Stop
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Stop routine for the E2PROM_1 user module.  This routine is
                                        (0114) ;     a place holder for conformance and consistency.
                                        (0115) ;
                                        (0116) ;-----------------------------------------------------------------------------
                                        (0117) ;
                                        (0118) ;  ARGUMENTS:
                                        (0119) ;     None
                                        (0120) ;
                                        (0121) ;  RETURNS:
                                        (0122) ;     None
                                        (0123) ;
                                        (0124) ;  SIDE EFFECTS: 
                                        (0125) ;    The A and X registers may be modified by this or future implementations
                                        (0126) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0127) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0128) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0129) ;    functions.
                                        (0130) ;
                                        (0131) .SECTION
                                        (0132) 
                                        (0133)  E2PROM_1_Stop:
                                        (0134) _E2PROM_1_Stop:
                                        (0135)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0136)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0137)    ret
                                        (0138) 
                                        (0139) .ENDSECTION
                                        (0140) 
                                        (0141) 
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;  FUNCTION NAME: E2PROM_1_E2Write
                                        (0144) ;
                                        (0145) ;  DESCRIPTION:
                                        (0146) ;     Writes the specified E2PROM data at the wAddr and wByteCount from RAM into
                                        (0147) ;     Flash into the defined E2PROM instance.
                                        (0148) ;
                                        (0149) ;     Prototype in C is:
                                        (0150) ;
                                        (0151) ;        #pragma  fastcall16 E2Write
                                        (0152) ;        void E2PROM_1_bE2Write( WORD wAddr, BYTE * pbData, WORD wByteCount,
                                        (0153) ;                                        CHAR cTemperature );
                                        (0154) ;
                                        (0155) ;     Easiest method to call from assembly is as follows:
                                        (0156) ;           push  X                    ; push X only if X needs to be perserved
                                        (0157) ;           mov   X, SP
                                        (0158) ;           push  <cTemperature>
                                        (0159) ;           push  <wByteCount>
                                        (0160) ;           push  <wByteCount+1>
                                        (0161) ;           push  <pbDataDest>                  
                                        (0162) ;           push  <pbDataDest+1>
                                        (0163) ;           push  <wAddr>
                                        (0164) ;           push  <wAddr+1>
                                        (0165) ;           call  E2PROM_1_bE2Write
                                        (0166) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0167) ;           pop   X                    ; restore X only if it was saved above
                                        (0168) ;
                                        (0169) ;           where <> refers to any addressing mode or number of instructions to
                                        (0170) ;              place the referenced data on the stack frame.
                                        (0171) ;
                                        (0172) ;     Other method is to create a stack frame using the defined equates and
                                        (0173) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0174) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0175) ;     that the index page tracks the stack page or is set to the same page
                                        (0176) ;     as the stack page.
                                        (0177) ;
                                        (0178) ;-----------------------------------------------------------------------------
                                        (0179) ;
                                        (0180) ;  ARGUMENTS:
                                        (0181) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to write data
                                        (0182) ;     pbData:        BYTE * - pointer to the RAM buffer of data to write
                                        (0183) ;     wByteCount:    WORD   - number of bytes to write into E2PROM
                                        (0184) ;     cTemperature:  CHAR   - temperature in degrees celsius
                                        (0185) ;
                                        (0186) ;  RETURNS:    E2PROM_1_NOERROR, E2PROM_1_FAILURE, or
                                        (0187) ;              E2PROM_1_STACKOVERFLOW
                                        (0188) ;
                                        (0189) ;  SIDE EFFECTS: 
                                        (0190) ;    If a partial block is to be saved to flash, then a 64 byte buffer
                                        (0191) ;    is temporary allocated.
                                        (0192) ;
                                        (0193) ;    The A and X registers may be modified by this or future implementations
                                        (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0197) ;    functions.
                                        (0198) ;          
                                        (0199) ;    Currently only the page pointer registers listed below are modified:
                                        (0200) ;       CUR_PP 
                                        (0201) ;       IDX_PP
                                        (0202) ;       MVW_PP
                                        (0203) ;                
                                        (0204) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0205) ;------------------------------------------------------------------------------
                                        (0206) .SECTION
                                        (0207) 
                                        (0208)  E2PROM_1_bE2Write::
                                        (0209) _E2PROM_1_bE2Write::
                                        (0210) 
                                        (0211) ;  RAM_PROLOGUE RAM_PROXY_CLASS_4 RAM_USE_CLASS_2  -->  implemented in E2PROMLIB  
                                        (0212) ;  Save the Flag register to perserve the native paging mode
                                        (0213) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
058C: 5D F7    MOV   A,REG[0xF7]        (0214)    mov   A, reg[CPU_F]                            
058E: 08       PUSH  A                  (0215)    push  A
                                        (0216) ENDIF
058F: 50 00    MOV   A,0x0              (0217)    mov   A, >E2PROM_1_START_BLOCK          ; push the FirstBlockID - MSB
0591: 08       PUSH  A                  (0218)    push  A
0592: 50 7F    MOV   A,0x7F             (0219)    mov   A, <E2PROM_1_START_BLOCK          ; push the FirstBlockID - LSB
0594: 08       PUSH  A                  (0220)    push  A
0595: 7D 05 BA LJMP  bE2Write|CS_PIN_Invert|_bE2Write|CS_PIN_GetState(0221)    ljmp  bE2Write                                  ; jmp to E2PROMLIB 
                                        (0222) 
                                        (0223) 
                                        (0224) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0225) ;      mode and flag status.
                                        (0226) 
                                        (0227) .ENDSECTION
                                        (0228) 
                                        (0229) 
                                        (0230) ;-----------------------------------------------------------------------------
                                        (0231) ;  FUNCTION NAME: E2PROM_1_E2Read
                                        (0232) ;
                                        (0233) ;  DESCRIPTION:
                                        (0234) ;     Reads the specified E2PROM data at offset=wAddr for wByteCount bytes  and
                                        (0235) ;     places the data read into the RAM buffer pbDataDest.
                                        (0236) ;
                                        (0237) ;     Prototype in C is:
                                        (0238) ;
                                        (0239) ;        #pragma  fastcall16 E2Read
                                        (0240) ;        void E2PROM_1_E2Read( WORD wAddr, BYTE * pbDataDest, WORD wByteCount );
                                        (0241) ;
                                        (0242) ;     Easiest method to call from assembly is as follows:
                                        (0243) ;           push  X                             ; only if X needs to be preserved
                                        (0244) ;           mov   X, SP
                                        (0245) ;           push  <wByteCount>
                                        (0246) ;           push  <wByteCount+1>
                                        (0247) ;           push  <pbDataDest
                                        (0248) ;           push  <pbDataDest+1>
                                        (0249) ;           push  <wAddr>
                                        (0250) ;           push  <wAddr+1>
                                        (0251) ;           call  E2PROM_1_E2Read
                                        (0252) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0253) ;           pop   X                             ; restore only if X needs to be preserved
                                        (0254) ;
                                        (0255) ;           where <> refers to any addressing mode or number of instructions to
                                        (0256) ;              place the referenced data on the stack frame.
                                        (0257) ;
                                        (0258) ;     Other method is to create a stack frame using the defined equates and
                                        (0259) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0260) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0261) ;     that the index page tracks the stack page or is set to the same page
                                        (0262) ;     as the stack page.
                                        (0263) ;
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;
                                        (0266) ;  ARGUMENTS:
                                        (0267) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to read data
                                        (0268) ;     pbDataDest:    BYTE * - pointer to the RAM buffer to place read data
                                        (0269) ;     wByteCount:    WORD   - number of bytes to read from E2PROM
                                        (0270) ;
                                        (0271) ;  RETURNS:       none
                                        (0272) ;
                                        (0273) ;  SIDE EFFECTS:
                                        (0274) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED 
                                        (0275) ;    AS MAY THE PAGE POINTER REGISTERS! 
                                        (0276) ;    
                                        (0277) ;    In the large memory model currently only the page
                                        (0278) ;    pointer registers listed below are modified.  This does
                                        (0279) ;    not guarantee that in future implementations of this
                                        (0280) ;    function other page pointer registers will not be
                                        (0281) ;    modified.
                                        (0282) ;    
                                        (0283) ;    Page Pointer Registers Modified:
                                        (0284) ;          CUR_PP
                                        (0285) ;          MVW_PP 
                                        (0286) ;
                                        (0287) ;-----------------------------------------------------------------------------
                                        (0288) .SECTION
                                        (0289) 
                                        (0290)  E2PROM_1_E2Read::
                                        (0291) _E2PROM_1_E2Read::
                                        (0292) ;  RAM_PROLOGUE RAM_PROXY_CLASS_NULL RAM_USE_CLASS_4  -->  implemented in E2PROMLIB  
                                        (0293) ;  Save the Flag register to perserve the native paging mode
                                        (0294) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
0598: 5D F7    MOV   A,REG[0xF7]        (0295)    mov   A, reg[CPU_F]                            
059A: 08       PUSH  A                  (0296)    push  A
                                        (0297) ENDIF
                                        (0298) 
                                        (0299) ;  Load the Block ID into X and A
059B: 50 00    MOV   A,0x0              (0300)    mov   A, >E2PROM_1_START_BLOCK       
059D: 5C       MOV   X,A                (0301)    mov   X, A
059E: 50 7F    MOV   A,0x7F             (0302)    mov   A, <E2PROM_1_START_BLOCK
05A0: 7D 07 50 LJMP  _E2Read            (0303)    ljmp  E2Read
                                        (0304) 
                                        (0305) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0306) ;      mode and flag status.
                                        (0307) 
                                        (0308) 
                                        (0309) .ENDSECTION
                                        (0310) 
                                        (0311) ; End of File
FILE: lib\cs_pin.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CS_PIN.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CS_PIN.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CS_PIN_Start
                                        (0027) export  CS_PIN_Start
                                        (0028) 
                                        (0029) export _CS_PIN_Stop
                                        (0030) export  CS_PIN_Stop
                                        (0031) 
                                        (0032) export _CS_PIN_On
                                        (0033) export  CS_PIN_On
                                        (0034) 
                                        (0035) export _CS_PIN_Off
                                        (0036) export  CS_PIN_Off
                                        (0037) 
                                        (0038) export _CS_PIN_Switch
                                        (0039) export  CS_PIN_Switch
                                        (0040) 
                                        (0041) export _CS_PIN_Invert
                                        (0042) export  CS_PIN_Invert
                                        (0043) 
                                        (0044) export _CS_PIN_GetState
                                        (0045) export  CS_PIN_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CS_PIN_Start(void)
                                        (0054) ;  FUNCTION NAME: CS_PIN_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CS_PIN_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CS_PIN_On:
                                        (0079)  CS_PIN_On:
05A3: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
05A5: 80 03    JMP   _CS_PIN_Switch     (0081)    jmp  CS_PIN_Switch 
                                        (0082) 
                                        (0083) _CS_PIN_Start:
                                        (0084)  CS_PIN_Start:
                                        (0085) _CS_PIN_Stop:
                                        (0086)  CS_PIN_Stop:
                                        (0087) _CS_PIN_Off:
                                        (0088)  CS_PIN_Off:
05A7: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CS_PIN_Switch:
                                        (0092)  CS_PIN_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
05A9: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
05AB: A0 06    JZ    0x05B2             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
05AD: 2E 1D 80 OR    [0x1D],0x80        (0102)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0105) ENDIF
05B0: 80 04    JMP   0x05B5             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
05B2: 26 1D 7F AND   [0x1D],0x7F        (0110)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
05B5: 51 1D    MOV   A,[0x1D]           (0116)    mov  A,[Port_0_Data_SHADE]
05B7: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[CS_PIN_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
05B9: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CS_PIN_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CS_PIN_Invert:
                                        (0144)  CS_PIN_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[CS_PIN_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CS_PIN_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CS_PIN_GetState:
                                        (0177)  CS_PIN_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CS_PIN_PinMask              ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
bE2Write|CS_PIN_Invert|_bE2Write|CS_PIN_GetState:
    05BA: 62 D0 00 MOV   REG[0xD0],0x0
    05BD: 4F       MOV   X,SP
    05BE: 4B       SWAP  A,X
    05BF: 39 EA    CMP   A,0xEA
    05C1: C0 06    JC    0x05C8
    05C3: 50 FE    MOV   A,0xFE
    05C5: 38 FE    ADD   SP,0xFE
    05C7: 7E       RETI  
    05C8: 4F       MOV   X,SP
    05C9: 79       DEC   X
    05CA: 79       DEC   X
    05CB: 38 09    ADD   SP,0x9
    05CD: 56 08 00 MOV   [X+8],0x0
    05D0: 52 FB    MOV   A,[X-5]
    05D2: 08       PUSH  A
    05D3: 52 FC    MOV   A,[X-4]
    05D5: 08       PUSH  A
    05D6: 69 FB    ASR   [X-5]
    05D8: 6F FC    RRC   [X-4]
    05DA: 69 FB    ASR   [X-5]
    05DC: 6F FC    RRC   [X-4]
    05DE: 69 FB    ASR   [X-5]
    05E0: 6F FC    RRC   [X-4]
    05E2: 69 FB    ASR   [X-5]
    05E4: 6F FC    RRC   [X-4]
    05E6: 69 FB    ASR   [X-5]
    05E8: 6F FC    RRC   [X-4]
    05EA: 69 FB    ASR   [X-5]
    05EC: 6F FC    RRC   [X-4]
    05EE: 52 FC    MOV   A,[X-4]
    05F0: 05 01    ADD   [X+1],A
    05F2: 52 FB    MOV   A,[X-5]
    05F4: 0D 00    ADC   [X+0],A
    05F6: 18       POP   A
    05F7: 54 FC    MOV   [X-4],A
    05F9: 18       POP   A
    05FA: 54 FB    MOV   [X-5],A
    05FC: 52 FA    MOV   A,[X-6]
    05FE: 54 03    MOV   [X+3],A
    0600: 52 F9    MOV   A,[X-7]
    0602: 54 02    MOV   [X+2],A
    0604: 52 F6    MOV   A,[X-10]
    0606: 54 04    MOV   [X+4],A
    0608: 52 FC    MOV   A,[X-4]
    060A: 21 3F    AND   A,0x3F
    060C: 54 09    MOV   [X+9],A
    060E: 50 40    MOV   A,0x40
    0610: 13 09    SUB   A,[X+9]
    0612: 54 0A    MOV   [X+10],A
    0614: 52 F7    MOV   A,[X-9]
    0616: B0 09    JNZ   0x0620
    0618: 52 F8    MOV   A,[X-8]
    061A: 3B 0A    CMP   A,[X+10]
    061C: D0 03    JNC   0x0620
    061E: 54 0A    MOV   [X+10],A
    0620: 3D 0A 40 CMP   [X+10],0x40
    0623: B0 1C    JNZ   0x0640
    0625: 56 08 FF MOV   [X+8],0xFF
    0628: 10       PUSH  X
    0629: 5B       MOV   A,X
    062A: 01 01    ADD   A,0x1
    062C: 5C       MOV   X,A
    062D: 5D D1    MOV   A,REG[0xD1]
    062F: 70 3F    AND   F,0x3F
    0631: 71 C0    OR    F,0xC0
    0633: 7C 07 B6 LCALL _bFlashWriteBlock
    0636: 20       POP   X
    0637: 39 00    CMP   A,0x0
    0639: A0 4D    JZ    0x0687
    063B: 56 08 00 MOV   [X+8],0x0
    063E: 80 1D    JMP   0x065C
    0640: 52 03    MOV   A,[X+3]
    0642: 54 FA    MOV   [X-6],A
    0644: 52 02    MOV   A,[X+2]
    0646: 54 F9    MOV   [X-7],A
    0648: 90 46    CALL  0x0690
    064A: 52 08    MOV   A,[X+8]
    064C: 39 FF    CMP   A,0xFF
    064E: A0 38    JZ    0x0687
    0650: 39 FE    CMP   A,0xFE
    0652: A0 34    JZ    0x0687
    0654: 52 FA    MOV   A,[X-6]
    0656: 54 03    MOV   [X+3],A
    0658: 52 F9    MOV   A,[X-7]
    065A: 54 02    MOV   [X+2],A
    065C: 52 F8    MOV   A,[X-8]
    065E: 13 0A    SUB   A,[X+10]
    0660: 54 F8    MOV   [X-8],A
    0662: D0 03    JNC   0x0666
    0664: 7B F7    DEC   [X-9]
    0666: 52 F8    MOV   A,[X-8]
    0668: 2B F7    OR    A,[X-9]
    066A: A0 1C    JZ    0x0687
    066C: 77 01    INC   [X+1]
    066E: 0F 00 00 ADC   [X+0],0x0
    0671: 52 03    MOV   A,[X+3]
    0673: 03 0A    ADD   A,[X+10]
    0675: 54 03    MOV   [X+3],A
    0677: D0 03    JNC   0x067B
    0679: 77 02    INC   [X+2]
    067B: 52 FC    MOV   A,[X-4]
    067D: 03 0A    ADD   A,[X+10]
    067F: 54 FC    MOV   [X-4],A
    0681: DF 86    JNC   0x0608
    0683: 77 FB    INC   [X-5]
    0685: 8F 82    JMP   0x0608
    0687: 52 08    MOV   A,[X+8]
    0689: 38 F5    ADD   SP,0xF5
    068B: 70 3F    AND   F,0x3F
    068D: 71 C0    OR    F,0xC0
    068F: 7E       RETI  
    0690: 5B       MOV   A,X
    0691: 4F       MOV   X,SP
    0692: 4B       SWAP  A,X
    0693: 39 A0    CMP   A,0xA0
    0695: C0 05    JC    0x069B
    0697: 56 08 FE MOV   [X+8],0xFE
    069A: 7F       RET   
    069B: 38 44    ADD   SP,0x44
    069D: 52 09    MOV   A,[X+9]
    069F: 03 0A    ADD   A,[X+10]
    06A1: 54 0D    MOV   [X+13],A
    06A3: 52 09    MOV   A,[X+9]
    06A5: A0 22    JZ    0x06C8
    06A7: 10       PUSH  X
    06A8: 50 00    MOV   A,0x0
    06AA: 08       PUSH  A
    06AB: 52 09    MOV   A,[X+9]
    06AD: 08       PUSH  A
    06AE: 5D D1    MOV   A,REG[0xD1]
    06B0: 08       PUSH  A
    06B1: 5B       MOV   A,X
    06B2: 01 0E    ADD   A,0xE
    06B4: 08       PUSH  A
    06B5: 50 00    MOV   A,0x0
    06B7: 08       PUSH  A
    06B8: 08       PUSH  A
    06B9: 52 00    MOV   A,[X+0]
    06BB: 08       PUSH  A
    06BC: 52 01    MOV   A,[X+1]
    06BE: 20       POP   X
    06BF: 70 3F    AND   F,0x3F
    06C1: 71 C0    OR    F,0xC0
    06C3: 90 84    CALL  0x0749
    06C5: 38 FA    ADD   SP,0xFA
    06C7: 20       POP   X
    06C8: 3D 0D 40 CMP   [X+13],0x40
    06CB: D0 28    JNC   0x06F4
    06CD: 10       PUSH  X
    06CE: 50 00    MOV   A,0x0
    06D0: 08       PUSH  A
    06D1: 50 40    MOV   A,0x40
    06D3: 13 0D    SUB   A,[X+13]
    06D5: 08       PUSH  A
    06D6: 5D D1    MOV   A,REG[0xD1]
    06D8: 08       PUSH  A
    06D9: 5B       MOV   A,X
    06DA: 01 0E    ADD   A,0xE
    06DC: 0B 0D    ADC   A,[X+13]
    06DE: 08       PUSH  A
    06DF: 50 00    MOV   A,0x0
    06E1: 08       PUSH  A
    06E2: 52 0D    MOV   A,[X+13]
    06E4: 08       PUSH  A
    06E5: 52 00    MOV   A,[X+0]
    06E7: 08       PUSH  A
    06E8: 52 01    MOV   A,[X+1]
    06EA: 20       POP   X
    06EB: 70 3F    AND   F,0x3F
    06ED: 71 C0    OR    F,0xC0
    06EF: 90 58    CALL  0x0749
    06F1: 38 FA    ADD   SP,0xFA
    06F3: 20       POP   X
    06F4: 5B       MOV   A,X
    06F5: 03 09    ADD   A,[X+9]
    06F7: 01 0E    ADD   A,0xE
    06F9: 53 FC    MOV   [_ramareas_end+107],A
    06FB: 5D D1    MOV   A,REG[0xD1]
    06FD: 60 D5    MOV   REG[0xD5],A
    06FF: 52 03    MOV   A,[X+3]
    0701: 53 FA    MOV   [_ramareas_end+105],A
    0703: 52 02    MOV   A,[X+2]
    0705: 60 D4    MOV   REG[0xD4],A
    0707: 52 0D    MOV   A,[X+13]
    0709: 13 09    SUB   A,[X+9]
    070B: 53 FF    MOV   [_ramareas_end+110],A
    070D: 3E FA    MVI   A,[_ramareas_end+105]
    070F: 3F FC    MVI   [_ramareas_end+107],A
    0711: 51 FA    MOV   A,[_ramareas_end+105]
    0713: B0 06    JNZ   0x071A
    0715: 5D D4    MOV   A,REG[0xD4]
    0717: 74       INC   A
    0718: 60 D4    MOV   REG[0xD4],A
    071A: 7A FF    DEC   [_ramareas_end+110]
    071C: BF F0    JNZ   0x070D
    071E: 52 03    MOV   A,[X+3]
    0720: 08       PUSH  A
    0721: 5B       MOV   A,X
    0722: 01 0E    ADD   A,0xE
    0724: 54 03    MOV   [X+3],A
    0726: 5D D1    MOV   A,REG[0xD1]
    0728: 54 02    MOV   [X+2],A
    072A: 56 08 FF MOV   [X+8],0xFF
    072D: 10       PUSH  X
    072E: 5B       MOV   A,X
    072F: 01 01    ADD   A,0x1
    0731: 5C       MOV   X,A
    0732: 5D D1    MOV   A,REG[0xD1]
    0734: 70 3F    AND   F,0x3F
    0736: 71 C0    OR    F,0xC0
    0738: 7C 07 B6 LCALL _bFlashWriteBlock
    073B: 20       POP   X
    073C: 39 00    CMP   A,0x0
    073E: A0 04    JZ    0x0743
    0740: 56 08 00 MOV   [X+8],0x0
    0743: 18       POP   A
    0744: 54 03    MOV   [X+3],A
    0746: 38 BC    ADD   SP,0xBC
    0748: 7F       RET   
    0749: 53 F8    MOV   [_ramareas_end+103],A
    074B: 5D F7    MOV   A,REG[0xF7]
    074D: 08       PUSH  A
    074E: 51 F8    MOV   A,[_ramareas_end+103]
_E2Read:
    0750: 08       PUSH  A
    0751: 10       PUSH  X
    0752: 62 D0 00 MOV   REG[0xD0],0x0
    0755: 20       POP   X
    0756: 18       POP   A
    0757: 5A F8    MOV   [_ramareas_end+103],X
    0759: 64       ASL   A
    075A: 6B F8    RLC   [_ramareas_end+103]
    075C: 64       ASL   A
    075D: 6B F8    RLC   [_ramareas_end+103]
    075F: 64       ASL   A
    0760: 6B F8    RLC   [_ramareas_end+103]
    0762: 64       ASL   A
    0763: 6B F8    RLC   [_ramareas_end+103]
    0765: 64       ASL   A
    0766: 6B F8    RLC   [_ramareas_end+103]
    0768: 64       ASL   A
    0769: 6B F8    RLC   [_ramareas_end+103]
    076B: 21 C0    AND   A,0xC0
    076D: 53 F9    MOV   [_ramareas_end+104],A
    076F: 4F       MOV   X,SP
    0770: 52 F7    MOV   A,[X-9]
    0772: 2B F8    OR    A,[X-8]
    0774: A0 3B    JZ    0x07B0
    0776: 52 F7    MOV   A,[X-9]
    0778: 53 FE    MOV   [_ramareas_end+109],A
    077A: 52 F8    MOV   A,[X-8]
    077C: 53 FF    MOV   [_ramareas_end+110],A
    077E: 76 FE    INC   [_ramareas_end+109]
    0780: 52 FA    MOV   A,[X-6]
    0782: 53 FD    MOV   [_ramareas_end+108],A
    0784: 52 F9    MOV   A,[X-7]
    0786: 60 D5    MOV   REG[0xD5],A
    0788: 51 F9    MOV   A,[_ramareas_end+104]
    078A: 05 FC    ADD   [X-4],A
    078C: 51 F8    MOV   A,[_ramareas_end+103]
    078E: 0D FB    ADC   [X-5],A
    0790: 52 FB    MOV   A,[X-5]
    0792: 59 FC    MOV   X,[X-4]
    0794: 08       PUSH  A
    0795: 28       ROMX  
    0796: 3F FD    MVI   [_ramareas_end+108],A
    0798: 18       POP   A
    0799: 75       INC   X
    079A: B0 02    JNZ   0x079D
    079C: 74       INC   A
    079D: 08       PUSH  A
    079E: 51 FD    MOV   A,[_ramareas_end+108]
    07A0: B0 06    JNZ   0x07A7
    07A2: 5D D5    MOV   A,REG[0xD5]
    07A4: 74       INC   A
    07A5: 60 D5    MOV   REG[0xD5],A
    07A7: 18       POP   A
    07A8: 7A FF    DEC   [_ramareas_end+110]
    07AA: BF E9    JNZ   0x0794
    07AC: 7A FE    DEC   [_ramareas_end+109]
    07AE: BF E5    JNZ   0x0794
    07B0: 70 3F    AND   F,0x3F
    07B2: 71 C0    OR    F,0xC0
    07B4: 7E       RETI  
    07B5: 30       HALT  
_bFlashWriteBlock:
    07B6: 62 D0 00 MOV   REG[0xD0],0x0
    07B9: 53 F8    MOV   [_ramareas_end+103],A
    07BB: 5D F7    MOV   A,REG[0xF7]
    07BD: 08       PUSH  A
    07BE: 21 C0    AND   A,0xC0
    07C0: B0 07    JNZ   0x07C8
    07C2: 56 01 00 MOV   [X+1],0x0
    07C5: 55 F8 00 MOV   [_ramareas_end+103],0x0
    07C8: 51 F8    MOV   A,[_ramareas_end+103]
    07CA: 70 3F    AND   F,0x3F
    07CC: 71 80    OR    F,0x80
    07CE: 60 D3    MOV   REG[0xD3],A
    07D0: 55 FD 01 MOV   [_ramareas_end+108],0x1
    07D3: 3C FD 01 CMP   [_ramareas_end+108],0x1
    07D6: B0 E2    JNZ   0x08B9
    07D8: 7C 00 F2 LCALL 0x00F2
    07DB: 21 06    AND   A,0x6
    07DD: A0 19    JZ    0x07F7
    07DF: 71 10    OR    F,0x10
    07E1: 5D E0    MOV   A,REG[0xE0]
    07E3: 08       PUSH  A
    07E4: 21 F8    AND   A,0xF8
    07E6: 49 FE 10 TST   REG[0xFE],0x10
    07E9: A0 05    JZ    0x07EF
    07EB: 29 02    OR    A,0x2
    07ED: 80 03    JMP   0x07F1
    07EF: 29 00    OR    A,0x0
    07F1: 60 E0    MOV   REG[0xE0],A
    07F3: 70 EF    AND   F,0xEF
    07F5: 80 17    JMP   0x080D
    07F7: 71 10    OR    F,0x10
    07F9: 5D E0    MOV   A,REG[0xE0]
    07FB: 08       PUSH  A
    07FC: 21 F8    AND   A,0xF8
    07FE: 49 FE 10 TST   REG[0xFE],0x10
    0801: A0 05    JZ    0x0807
    0803: 29 03    OR    A,0x3
    0805: 80 03    JMP   0x0809
    0807: 29 02    OR    A,0x2
    0809: 60 E0    MOV   REG[0xE0],A
    080B: 70 EF    AND   F,0xEF
    080D: 62 E3 00 MOV   REG[0xE3],0x0
    0810: 65 FD    ASL   [_ramareas_end+108]
    0812: 3C FD 02 CMP   [_ramareas_end+108],0x2
    0815: B0 A3    JNZ   0x08B9
    0817: 90 B0    CALL  0x08C9
    0819: 39 00    CMP   A,0x0
    081B: A0 09    JZ    0x0825
    081D: 55 FF 00 MOV   [_ramareas_end+110],0x0
    0820: 55 FD 10 MOV   [_ramareas_end+108],0x10
    0823: 80 80    JMP   0x08A4
    0825: 65 FD    ASL   [_ramareas_end+108]
    0827: 71 10    OR    F,0x10
    0829: 49 E4 08 TST   REG[0xE4],0x8
    082C: A0 05    JZ    0x0832
    082E: 70 EF    AND   F,0xEF
    0830: 80 2E    JMP   0x085F
    0832: 70 EF    AND   F,0xEF
    0834: 62 E3 00 MOV   REG[0xE3],0x0
    0837: 52 00    MOV   A,[X+0]
    0839: 53 FA    MOV   [_ramareas_end+105],A
    083B: 52 04    MOV   A,[X+4]
    083D: 53 FC    MOV   [_ramareas_end+107],A
    083F: 55 FE 56 MOV   [_ramareas_end+109],0x56
    0842: 51 FD    MOV   A,[_ramareas_end+108]
    0844: 39 04    CMP   A,0x4
    0846: B0 72    JNZ   0x08B9
    0848: 08       PUSH  A
    0849: 10       PUSH  X
_FlashBlockLocal1:
    084A: 4F       MOV   X,SP
    084B: 5B       MOV   A,X
    084C: 01 03    ADD   A,0x3
    084E: 53 F9    MOV   [_ramareas_end+104],A
    0850: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    0853: 50 03    MOV   A,0x3
    0855: 00       SWI   
    0856: 20       POP   X
    0857: 18       POP   A
    0858: 53 FD    MOV   [_ramareas_end+108],A
    085A: 3C F8 00 CMP   [_ramareas_end+103],0x0
    085D: A0 09    JZ    0x0867
    085F: 55 FF 00 MOV   [_ramareas_end+110],0x0
    0862: 55 FD 10 MOV   [_ramareas_end+108],0x10
    0865: 80 3E    JMP   0x08A4
    0867: 62 E3 00 MOV   REG[0xE3],0x0
    086A: 65 FD    ASL   [_ramareas_end+108]
    086C: 52 00    MOV   A,[X+0]
    086E: 53 FA    MOV   [_ramareas_end+105],A
    0870: 52 02    MOV   A,[X+2]
    0872: 53 FB    MOV   [_ramareas_end+106],A
    0874: 52 01    MOV   A,[X+1]
    0876: 60 D4    MOV   REG[0xD4],A
    0878: 52 05    MOV   A,[X+5]
    087A: 53 FC    MOV   [_ramareas_end+107],A
    087C: 55 FE 56 MOV   [_ramareas_end+109],0x56
    087F: 51 FD    MOV   A,[_ramareas_end+108]
    0881: 39 08    CMP   A,0x8
    0883: B0 35    JNZ   0x08B9
    0885: 08       PUSH  A
    0886: 10       PUSH  X
_FlashBlockLocal2:
    0887: 4F       MOV   X,SP
    0888: 5B       MOV   A,X
    0889: 01 03    ADD   A,0x3
    088B: 53 F9    MOV   [_ramareas_end+104],A
    088D: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    0890: 50 02    MOV   A,0x2
    0892: 00       SWI   
    0893: 20       POP   X
    0894: 18       POP   A
    0895: 53 FD    MOV   [_ramareas_end+108],A
    0897: 55 FF 01 MOV   [_ramareas_end+110],0x1
    089A: 3C F8 00 CMP   [_ramareas_end+103],0x0
    089D: A0 04    JZ    0x08A2
    089F: 55 FF 00 MOV   [_ramareas_end+110],0x0
    08A2: 65 FD    ASL   [_ramareas_end+108]
    08A4: 3C FD 10 CMP   [_ramareas_end+108],0x10
    08A7: B0 11    JNZ   0x08B9
    08A9: 18       POP   A
    08AA: 71 10    OR    F,0x10
    08AC: 60 E0    MOV   REG[0xE0],A
    08AE: 70 EF    AND   F,0xEF
    08B0: 65 FD    ASL   [_ramareas_end+108]
    08B2: 51 FF    MOV   A,[_ramareas_end+110]
    08B4: 3C FD 20 CMP   [_ramareas_end+108],0x20
    08B7: A0 04    JZ    0x08BC
    08B9: 30       HALT  
    08BA: 8F FE    JMP   0x08B9
    08BC: 62 D0 00 MOV   REG[0xD0],0x0
    08BF: 62 D5 00 MOV   REG[0xD5],0x0
    08C2: 62 D4 00 MOV   REG[0xD4],0x0
    08C5: 7E       RETI  
    08C6: 30       HALT  
    08C7: 30       HALT  
    08C8: 30       HALT  
    08C9: 55 FA 03 MOV   [_ramareas_end+105],0x3
    08CC: 62 D5 00 MOV   REG[0xD5],0x0
    08CF: 51 FD    MOV   A,[_ramareas_end+108]
    08D1: 39 02    CMP   A,0x2
    08D3: BF E5    JNZ   0x08B9
    08D5: 08       PUSH  A
    08D6: 10       PUSH  X
_FlashBlockLocal3:
    08D7: 4F       MOV   X,SP
    08D8: 5B       MOV   A,X
    08D9: 01 03    ADD   A,0x3
    08DB: 53 F9    MOV   [_ramareas_end+104],A
    08DD: 55 F8 3A MOV   [_ramareas_end+103],0x3A
    08E0: 50 06    MOV   A,0x6
    08E2: 00       SWI   
    08E3: 20       POP   X
    08E4: 3C FF 01 CMP   [_ramareas_end+110],0x1
    08E7: B0 80    JNZ   0x0968
    08E9: 10       PUSH  X
    08EA: 5D D3    MOV   A,REG[0xD3]
    08EC: 08       PUSH  A
    08ED: 52 03    MOV   A,[X+3]
    08EF: 08       PUSH  A
    08F0: 62 D3 00 MOV   REG[0xD3],0x0
    08F3: 21 80    AND   A,0x80
    08F5: B0 05    JNZ   0x08FB
    08F7: 57 FB    MOV   X,0xFB
    08F9: 80 07    JMP   0x0901
    08FB: 57 F8    MOV   X,0xF8
    08FD: 18       POP   A
    08FE: 73       CPL   A
    08FF: 74       INC   A
    0900: 08       PUSH  A
    0901: 18       POP   A
    0902: 10       PUSH  X
    0903: 08       PUSH  A
    0904: 52 00    MOV   A,[X+0]
    0906: 20       POP   X
    0907: 90 69    CALL  0x0972
    0909: 64       ASL   A
    090A: 5B       MOV   A,X
    090B: 6A       RLC   A
    090C: 20       POP   X
    090D: 08       PUSH  A
    090E: 5B       MOV   A,X
    090F: 39 F8    CMP   A,0xF8
    0911: A0 05    JZ    0x0917
    0913: 18       POP   A
    0914: 73       CPL   A
    0915: 74       INC   A
    0916: 08       PUSH  A
    0917: 18       POP   A
    0918: 03 01    ADD   A,[X+1]
    091A: 53 FE    MOV   [_ramareas_end+109],A
    091C: 52 02    MOV   A,[X+2]
    091E: 10       PUSH  X
    091F: 5C       MOV   X,A
    0920: 51 FE    MOV   A,[_ramareas_end+109]
    0922: 90 4E    CALL  0x0972
    0924: 4B       SWAP  A,X
    0925: 53 FF    MOV   [_ramareas_end+110],A
    0927: 5B       MOV   A,X
    0928: 20       POP   X
    0929: 64       ASL   A
    092A: 6B FF    RLC   [_ramareas_end+110]
    092C: 64       ASL   A
    092D: 6B FF    RLC   [_ramareas_end+110]
    092F: 51 FF    MOV   A,[_ramareas_end+110]
    0931: 5C       MOV   X,A
    0932: 18       POP   A
    0933: 60 D3    MOV   REG[0xD3],A
    0935: 5B       MOV   A,X
    0936: 20       POP   X
    0937: 54 05    MOV   [X+5],A
    0939: 51 FE    MOV   A,[_ramareas_end+109]
    093B: 54 04    MOV   [X+4],A
    093D: 7C 00 F2 LCALL 0x00F2
    0940: 21 06    AND   A,0x6
    0942: A0 07    JZ    0x094A
    0944: 69 04    ASR   [X+4]
    0946: 69 05    ASR   [X+5]
    0948: 80 0D    JMP   0x0956
    094A: 49 FE 10 TST   REG[0xFE],0x10
    094D: A0 10    JZ    0x095E
    094F: 7C 00 F2 LCALL 0x00F2
    0952: 21 04    AND   A,0x4
    0954: B0 09    JNZ   0x095E
    0956: 69 05    ASR   [X+5]
    0958: 77 05    INC   [X+5]
    095A: 69 04    ASR   [X+4]
    095C: 77 04    INC   [X+4]
    095E: 18       POP   A
    095F: 39 02    CMP   A,0x2
    0961: BF 57    JNZ   0x08B9
    0963: 53 FD    MOV   [_ramareas_end+108],A
    0965: 50 00    MOV   A,0x0
    0967: 7F       RET   
    0968: 18       POP   A
    0969: 39 02    CMP   A,0x2
    096B: BF 4D    JNZ   0x08B9
    096D: 53 FD    MOV   [_ramareas_end+108],A
    096F: 50 01    MOV   A,0x1
    0971: 7F       RET   
    0972: 71 40    OR    F,0x40
    0974: 08       PUSH  A
    0975: 5B       MOV   A,X
    0976: 4F       MOV   X,SP
    0977: 79       DEC   X
    0978: 08       PUSH  A
    0979: 50 00    MOV   A,0x0
    097B: 08       PUSH  A
    097C: 08       PUSH  A
    097D: 52 00    MOV   A,[X+0]
    097F: A0 1C    JZ    0x099C
    0981: 52 01    MOV   A,[X+1]
    0983: A0 18    JZ    0x099C
    0985: 50 08    MOV   A,0x8
    0987: 70 FB    AND   F,0xFB
    0989: 6F 00    RRC   [X+0]
    098B: D0 09    JNC   0x0995
    098D: 08       PUSH  A
    098E: 52 01    MOV   A,[X+1]
    0990: 70 FB    AND   F,0xFB
    0992: 05 02    ADD   [X+2],A
    0994: 18       POP   A
    0995: 6F 02    RRC   [X+2]
    0997: 6F 03    RRC   [X+3]
    0999: 78       DEC   A
    099A: BF EC    JNZ   0x0987
    099C: 52 02    MOV   A,[X+2]
    099E: 08       PUSH  A
    099F: 52 03    MOV   A,[X+3]
    09A1: 20       POP   X
    09A2: 38 FC    ADD   SP,0xFC
    09A4: 70 BF    AND   F,0xBF
    09A6: 7F       RET   
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\config.c
(0001) #include "config.h"
(0002) 
(0003) extern CHAR  E2PROM_1_bE2Write(WORD wAddr, BYTE * pbData, WORD wByteCount, CHAR cTemperature);
(0004) extern void  E2PROM_1_E2Read(WORD wAddr, BYTE * pbDataDest, WORD wByteCount);
(0005) 
(0006) RAM_D mem;
(0007) #define buf mem.buf
(0008) 
(0009) 
(0010) void SaveConfig(void *Data,BYTE Cnt)
(0011) {
__UserModules_end|_FlashReadBlock|__text_start|_SaveConfig|_SaveConfig:
  n                    --> X+0
  Cnt                  --> X-6
  Data                 --> X-5
    09A7: 10       PUSH  X
    09A8: 4F       MOV   X,SP
    09A9: 38 01    ADD   SP,0x1
(0012) BYTE n;	
(0013) #ifndef DEBUG
(0014) E2PROM_1_E2Read(0,buf,32);
    09AB: 10       PUSH  X
    09AC: 50 00    MOV   A,0x0
    09AE: 08       PUSH  A
    09AF: 50 20    MOV   A,0x20
    09B1: 08       PUSH  A
    09B2: 50 00    MOV   A,0x0
    09B4: 08       PUSH  A
    09B5: 50 20    MOV   A,0x20
    09B7: 08       PUSH  A
    09B8: 50 00    MOV   A,0x0
    09BA: 08       PUSH  A
    09BB: 08       PUSH  A
    09BC: 7C 05 98 LCALL _E2PROM_1_E2Read
    09BF: 38 FA    ADD   SP,0xFA
    09C1: 20       POP   X
(0015) #endif
(0016) buf[0]=CONFIG_ID;
    09C2: 55 20 21 MOV   [mem],0x21
(0017) for (n=0;n<Cnt;n++)
    09C5: 56 00 00 MOV   [X+0],0x0
    09C8: 80 19    JMP   0x09E2
(0018) 	buf[n+1]=((BYTE *)Data)[n];
    09CA: 52 00    MOV   A,[X+0]
    09CC: 53 16    MOV   [__r1],A
    09CE: 52 FC    MOV   A,[X-4]
    09D0: 04 16    ADD   [__r1],A
    09D2: 3E 16    MVI   A,[__r1]
    09D4: 53 17    MOV   [__r0],A
    09D6: 52 00    MOV   A,[X+0]
    09D8: 01 21    ADD   A,0x21
    09DA: 53 14    MOV   [__r3],A
    09DC: 51 17    MOV   A,[__r0]
    09DE: 3F 14    MVI   [__r3],A
    09E0: 77 00    INC   [X+0]
    09E2: 52 00    MOV   A,[X+0]
    09E4: 3B FA    CMP   A,[X-6]
    09E6: CF E3    JC    0x09CA
(0019) #ifndef DEBUG
(0020) E2PROM_1_bE2Write(0,buf,64,25);
    09E8: 10       PUSH  X
    09E9: 50 19    MOV   A,0x19
    09EB: 08       PUSH  A
    09EC: 50 00    MOV   A,0x0
    09EE: 08       PUSH  A
    09EF: 50 40    MOV   A,0x40
    09F1: 08       PUSH  A
    09F2: 50 00    MOV   A,0x0
    09F4: 08       PUSH  A
    09F5: 50 20    MOV   A,0x20
    09F7: 08       PUSH  A
    09F8: 50 00    MOV   A,0x0
    09FA: 08       PUSH  A
    09FB: 08       PUSH  A
    09FC: 7C 05 8C LCALL _E2PROM_1_Stop|_E2PROM_1_bE2Write|E2PROM_1_bE2Write
    09FF: 38 F9    ADD   SP,0xF9
    0A01: 20       POP   X
    0A02: 38 FF    ADD   SP,0xFF
    0A04: 20       POP   X
    0A05: 7F       RET   
(0021) #endif
(0022) }
(0023) 
(0024) BOOL ReadConfig(void *Data,BYTE Cnt)
(0025) {
_ReadConfig:
  n                    --> X+0
  Cnt                  --> X-6
  Data                 --> X-5
    0A06: 10       PUSH  X
    0A07: 4F       MOV   X,SP
    0A08: 38 01    ADD   SP,0x1
(0026) BYTE n;	
(0027) #ifndef DEBUG
(0028) E2PROM_1_E2Read(0,buf,32);
    0A0A: 10       PUSH  X
    0A0B: 50 00    MOV   A,0x0
    0A0D: 08       PUSH  A
    0A0E: 50 20    MOV   A,0x20
    0A10: 08       PUSH  A
    0A11: 50 00    MOV   A,0x0
    0A13: 08       PUSH  A
    0A14: 50 20    MOV   A,0x20
    0A16: 08       PUSH  A
    0A17: 50 00    MOV   A,0x0
    0A19: 08       PUSH  A
    0A1A: 08       PUSH  A
    0A1B: 7C 05 98 LCALL _E2PROM_1_E2Read
    0A1E: 38 FA    ADD   SP,0xFA
    0A20: 20       POP   X
(0029) #endif
(0030) if(buf[0]!=CONFIG_ID)
    0A21: 3C 20 21 CMP   [mem],0x21
    0A24: A0 05    JZ    0x0A2A
(0031) 	{
(0032) 		return FALSE;
    0A26: 50 00    MOV   A,0x0
    0A28: 80 26    JMP   0x0A4F
(0033) 	}
(0034) else
(0035) 	{
(0036) 	for (n=0;n<Cnt;n++)
    0A2A: 56 00 00 MOV   [X+0],0x0
    0A2D: 80 19    JMP   0x0A47
(0037) 		((BYTE *)Data)[n]=buf[n+1];
    0A2F: 52 00    MOV   A,[X+0]
    0A31: 01 21    ADD   A,0x21
    0A33: 53 16    MOV   [__r1],A
    0A35: 3E 16    MVI   A,[__r1]
    0A37: 53 17    MOV   [__r0],A
    0A39: 52 00    MOV   A,[X+0]
    0A3B: 53 14    MOV   [__r3],A
    0A3D: 52 FC    MOV   A,[X-4]
    0A3F: 04 14    ADD   [__r3],A
    0A41: 51 17    MOV   A,[__r0]
    0A43: 3F 14    MVI   [__r3],A
    0A45: 77 00    INC   [X+0]
    0A47: 52 00    MOV   A,[X+0]
    0A49: 3B FA    CMP   A,[X-6]
    0A4B: CF E3    JC    0x0A2F
(0038) 	}
(0039) return TRUE;
    0A4D: 50 01    MOV   A,0x1
(0040) }
(0041) 
(0042) 
(0043) 
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\cyrf6936.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "CYRF6936.h"
(0003) #include "delay.h"
(0004) #include "timer.h"
(0005) 
(0006) volatile BOOL CY_irq;
(0007) 
(0008) //called on a GPIO interrupt
(0009) #pragma interrupt_handler GPIO_ISR
(0010) void GPIO_ISR(void )
(0011) {
_GPIO_ISR:
    0A53: 08       PUSH  A
    0A54: 51 17    MOV   A,[__r0]
    0A56: 08       PUSH  A
(0012) 	if (PRT0DR&CY_IRQPin_MASK) //Check if  pin went high
    0A57: 5D 00    MOV   A,REG[0x0]
    0A59: 53 17    MOV   [__r0],A
    0A5B: 47 17 40 TST   [__r0],0x40
    0A5E: A0 04    JZ    0x0A63
(0013) 	{
(0014) 		CY_irq=TRUE;
    0A60: 55 40 01 MOV   [CY_irq],0x1
(0015) 	}
    0A63: 18       POP   A
    0A64: 53 17    MOV   [__r0],A
    0A66: 18       POP   A
    0A67: 7E       RETI  
(0016) }
(0017) 
(0018) 
(0019) //initialize cyrf chip
(0020) void CYRF_Init(void )
(0021) {
(0022) 	RST_Start();
_CYRF_Init:
    0A68: 10       PUSH  X
    0A69: 7C 04 E3 LCALL RST_Stop|_RST_Start|RST_Start|_RST_Off|RST_Off|_RST_Stop
(0023) 	CS_PIN_Start();
    0A6C: 7C 05 A7 LCALL _CS_PIN_Start|_CS_PIN_Off|CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop|CS_PIN_Stop
(0024) 	SPIM_1_Start(SPIM_1_SPIM_MODE_0 | SPIM_1_SPIM_MSB_FIRST);
    0A6F: 50 00    MOV   A,0x0
    0A71: 7C 04 8E LCALL bTimer8_1_CaptureCounter|SPIM_1_Start|_bTimer8_1_ReadCompareValue|_Timer8_1_bReadCompareValue|_bTimer8_1_ReadCounter|bTimer8_1_ReadTimerSaveCV|_Timer8_1_bReadTimer|bTimer8_1_ReadCounter|_SPIM_1_EnableInt|_bTimer8_1_ReadTimer|_SPIM_1_Start|...
(0025) 	//manua inline
(0026) 	//CYRF_Reset();
(0027) 	//reset cyrf chip
(0028) 	//void CYRF_Reset(void)
(0029) 	{
(0030) 	    RS_HI();
    0A74: 7C 04 DF LCALL _RST_On
(0031) 		CS_HI();
    0A77: 7C 05 A3 LCALL _CS_PIN_On
    0A7A: 20       POP   X
(0032) 	    Timer_Wait_ms(2);
    0A7B: 50 02    MOV   A,0x2
    0A7D: 08       PUSH  A
    0A7E: 7C 1D 43 LCALL _Timer_Wait_ms
    0A81: 38 FF    ADD   SP,0xFF
(0033) 	    RS_LO();
    0A83: 10       PUSH  X
    0A84: 7C 04 E3 LCALL RST_Stop|_RST_Start|RST_Start|_RST_Off|RST_Off|_RST_Stop
    0A87: 20       POP   X
(0034) 	    Timer_Wait_ms(10);
    0A88: 50 0A    MOV   A,0xA
    0A8A: 08       PUSH  A
    0A8B: 7C 1D 43 LCALL _Timer_Wait_ms
(0035) 	}
(0036)     CYRF_WriteRegister(CYRF_XACT_CFG, (CYRF_ACK_TO_12x));
    0A8E: 50 02    MOV   A,0x2
    0A90: 08       PUSH  A
    0A91: 50 0F    MOV   A,0xF
    0A93: 08       PUSH  A
    0A94: 90 10    CALL  _CYRF_WriteRegister
    0A96: 38 FD    ADD   SP,0xFD
(0037)     Delay50uTimes(100);
    0A98: 10       PUSH  X
    0A99: 50 64    MOV   A,0x64
    0A9B: 7C 0C 82 LCALL _Delay50uTimes
    0A9E: 20       POP   X
(0038) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); 
    0A9F: 43 E0 20 OR    REG[0xE0],0x20
(0039) 	CY_irq=FALSE;
    0AA2: 55 40 00 MOV   [CY_irq],0x0
    0AA5: 7F       RET   
(0040) }
(0041) 
(0042) 
(0043) //write a singel register
(0044) void CYRF_WriteRegister(BYTE reg, BYTE val)
(0045) {
_CYRF_WriteRegister:
  val                  --> X-5
  reg                  --> X-4
    0AA6: 10       PUSH  X
    0AA7: 4F       MOV   X,SP
(0046) CYRF_WriteRegisterMultiD(reg,&val,1);
    0AA8: 50 01    MOV   A,0x1
    0AAA: 08       PUSH  A
    0AAB: 5A 16    MOV   [__r1],X
    0AAD: 16 16 05 SUB   [__r1],0x5
    0AB0: 51 17    MOV   A,[__r0]
    0AB2: 08       PUSH  A
    0AB3: 51 16    MOV   A,[__r1]
    0AB5: 08       PUSH  A
    0AB6: 52 FC    MOV   A,[X-4]
    0AB8: 08       PUSH  A
    0AB9: 90 69    CALL  _CYRF_WriteRegisterMultiD
    0ABB: 38 FC    ADD   SP,0xFC
    0ABD: 20       POP   X
    0ABE: 7F       RET   
(0047) }
(0048) 
(0049) 
(0050) //write a single register cnt times
(0051) void CYRF_WriteRegisterMulti(BYTE reg,BYTE const data[] , BYTE cnt)
(0052) {
_CYRF_WriteRegisterMulti:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0ABF: 10       PUSH  X
    0AC0: 4F       MOV   X,SP
    0AC1: 38 01    ADD   SP,0x1
(0053) 	BYTE n;
(0054)     CS_LO();
    0AC3: 10       PUSH  X
    0AC4: 7C 05 A7 LCALL _CS_PIN_Start|_CS_PIN_Off|CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop|CS_PIN_Stop
    0AC7: 20       POP   X
(0055) 	//wait for buffer empty
(0056) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0AC8: 10       PUSH  X
    0AC9: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0ACC: 20       POP   X
    0ACD: 53 17    MOV   [__r0],A
    0ACF: 47 17 10 TST   [__r0],0x10
    0AD2: AF F5    JZ    0x0AC8
(0057) 	//write address
(0058) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0AD4: 52 FC    MOV   A,[X-4]
    0AD6: 29 80    OR    A,0x80
    0AD8: 10       PUSH  X
    0AD9: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0ADC: 20       POP   X
(0059)     for(n = 0; n < cnt; n++)
    0ADD: 56 00 00 MOV   [X+0],0x0
    0AE0: 80 28    JMP   0x0B09
(0060)     {
(0061) 		//wait for buffer empty
(0062) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0AE2: 10       PUSH  X
    0AE3: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0AE6: 20       POP   X
    0AE7: 53 17    MOV   [__r0],A
    0AE9: 47 17 10 TST   [__r0],0x10
    0AEC: AF F5    JZ    0x0AE2
(0063) 	    //write data
(0064) 		SPIM_1_SendTxData(data[n]);
    0AEE: 52 00    MOV   A,[X+0]
    0AF0: 53 16    MOV   [__r1],A
    0AF2: 55 17 00 MOV   [__r0],0x0
    0AF5: 52 FB    MOV   A,[X-5]
    0AF7: 04 16    ADD   [__r1],A
    0AF9: 52 FA    MOV   A,[X-6]
    0AFB: 0C 17    ADC   [__r0],A
    0AFD: 51 17    MOV   A,[__r0]
    0AFF: 10       PUSH  X
    0B00: 58 16    MOV   X,[__r1]
    0B02: 28       ROMX  
    0B03: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0B06: 20       POP   X
(0065)     }
    0B07: 77 00    INC   [X+0]
    0B09: 52 00    MOV   A,[X+0]
    0B0B: 3B F9    CMP   A,[X-7]
    0B0D: CF D4    JC    0x0AE2
(0066) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0B0F: 10       PUSH  X
    0B10: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B13: 20       POP   X
    0B14: 53 17    MOV   [__r0],A
    0B16: 47 17 20 TST   [__r0],0x20
    0B19: AF F5    JZ    0x0B0F
(0067) 	CS_HI();
    0B1B: 10       PUSH  X
    0B1C: 7C 05 A3 LCALL _CS_PIN_On
    0B1F: 20       POP   X
    0B20: 38 FF    ADD   SP,0xFF
    0B22: 20       POP   X
    0B23: 7F       RET   
(0068) }
(0069) void CYRF_WriteRegisterMultiD(BYTE reg, BYTE data[], BYTE cnt)
(0070) {
_CYRF_WriteRegisterMultiD:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B24: 10       PUSH  X
    0B25: 4F       MOV   X,SP
    0B26: 38 01    ADD   SP,0x1
(0071) 	BYTE n;
(0072)     CS_LO();
    0B28: 10       PUSH  X
    0B29: 7C 05 A7 LCALL _CS_PIN_Start|_CS_PIN_Off|CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop|CS_PIN_Stop
    0B2C: 20       POP   X
(0073) 	//wait for buffer empty
(0074) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B2D: 10       PUSH  X
    0B2E: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B31: 20       POP   X
    0B32: 53 17    MOV   [__r0],A
    0B34: 47 17 10 TST   [__r0],0x10
    0B37: AF F5    JZ    0x0B2D
(0075) 	//write address
(0076) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0B39: 52 FC    MOV   A,[X-4]
    0B3B: 29 80    OR    A,0x80
    0B3D: 10       PUSH  X
    0B3E: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0B41: 20       POP   X
(0077)     for(n = 0; n < cnt; n++)
    0B42: 56 00 00 MOV   [X+0],0x0
    0B45: 80 1E    JMP   0x0B64
(0078)     {
(0079) 		//wait for buffer empty
(0080) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B47: 10       PUSH  X
    0B48: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B4B: 20       POP   X
    0B4C: 53 17    MOV   [__r0],A
    0B4E: 47 17 10 TST   [__r0],0x10
    0B51: AF F5    JZ    0x0B47
(0081) 	    //write data
(0082) 		SPIM_1_SendTxData(data[n]);
    0B53: 52 00    MOV   A,[X+0]
    0B55: 53 16    MOV   [__r1],A
    0B57: 52 FB    MOV   A,[X-5]
    0B59: 04 16    ADD   [__r1],A
    0B5B: 3E 16    MVI   A,[__r1]
    0B5D: 10       PUSH  X
    0B5E: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0B61: 20       POP   X
(0083)     }
    0B62: 77 00    INC   [X+0]
    0B64: 52 00    MOV   A,[X+0]
    0B66: 3B F9    CMP   A,[X-7]
    0B68: CF DE    JC    0x0B47
(0084) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0B6A: 10       PUSH  X
    0B6B: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B6E: 20       POP   X
    0B6F: 53 17    MOV   [__r0],A
    0B71: 47 17 20 TST   [__r0],0x20
    0B74: AF F5    JZ    0x0B6A
(0085) 	CS_HI();
    0B76: 10       PUSH  X
    0B77: 7C 05 A3 LCALL _CS_PIN_On
    0B7A: 20       POP   X
    0B7B: 38 FF    ADD   SP,0xFF
    0B7D: 20       POP   X
    0B7E: 7F       RET   
(0086) }
(0087) 
(0088) 
(0089) void CYRF_WriteRegisterInc(BYTE reg,BYTE  data[] , BYTE cnt)
(0090) {
_CYRF_WriteRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B7F: 10       PUSH  X
    0B80: 4F       MOV   X,SP
(0091) CYRF_WriteRegisterMultiD(CYRF_INCR_BIT| reg,data,cnt);
    0B81: 52 F9    MOV   A,[X-7]
    0B83: 08       PUSH  A
    0B84: 52 FA    MOV   A,[X-6]
    0B86: 08       PUSH  A
    0B87: 52 FB    MOV   A,[X-5]
    0B89: 08       PUSH  A
    0B8A: 52 FC    MOV   A,[X-4]
    0B8C: 29 40    OR    A,0x40
    0B8E: 08       PUSH  A
    0B8F: 9F 93    CALL  _CYRF_WriteRegisterMultiD
    0B91: 38 FC    ADD   SP,0xFC
    0B93: 20       POP   X
    0B94: 7F       RET   
(0092) }
(0093) 
(0094) //read a singele register 
(0095) BYTE CYRF_ReadRegister(BYTE reg)
(0096) {
_CYRF_ReadRegister:
  data                 --> X+0
  reg                  --> X-4
    0B95: 10       PUSH  X
    0B96: 4F       MOV   X,SP
    0B97: 38 01    ADD   SP,0x1
(0097) BYTE data;
(0098) 	CYRF_ReadRegisterMulti(reg,&data,1);
    0B99: 50 01    MOV   A,0x1
    0B9B: 08       PUSH  A
    0B9C: 51 17    MOV   A,[__r0]
    0B9E: 08       PUSH  A
    0B9F: 10       PUSH  X
    0BA0: 52 FC    MOV   A,[X-4]
    0BA2: 08       PUSH  A
    0BA3: 90 08    CALL  _CYRF_ReadRegisterMulti
    0BA5: 38 FC    ADD   SP,0xFC
(0099) 	return data;
    0BA7: 52 00    MOV   A,[X+0]
    0BA9: 38 FF    ADD   SP,0xFF
    0BAB: 20       POP   X
    0BAC: 7F       RET   
(0100) }
(0101) 
(0102) //read a singel register cnt times
(0103) void CYRF_ReadRegisterMulti(BYTE reg, BYTE data[], BYTE cnt)
(0104) {
_CYRF_ReadRegisterMulti:
  n                    --> X+1
  status               --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0BAD: 10       PUSH  X
    0BAE: 4F       MOV   X,SP
    0BAF: 38 02    ADD   SP,0x2
(0105) 	BYTE n;
(0106) 	BYTE status;
(0107)     CS_LO();
    0BB1: 10       PUSH  X
    0BB2: 7C 05 A7 LCALL _CS_PIN_Start|_CS_PIN_Off|CS_PIN_Off|CS_PIN_Start|_CS_PIN_Stop|CS_PIN_Stop
    0BB5: 20       POP   X
(0108) 	//wait for buffer empty
(0109) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BB6: 10       PUSH  X
    0BB7: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BBA: 20       POP   X
    0BBB: 53 17    MOV   [__r0],A
    0BBD: 47 17 10 TST   [__r0],0x10
    0BC0: AF F5    JZ    0x0BB6
(0110) 	//write address
(0111) 	SPIM_1_SendTxData(reg);
    0BC2: 10       PUSH  X
    0BC3: 52 FC    MOV   A,[X-4]
    0BC5: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0BC8: 20       POP   X
(0112) 	//wait for buffer empty
(0113) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BC9: 10       PUSH  X
    0BCA: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BCD: 20       POP   X
    0BCE: 21 10    AND   A,0x10
    0BD0: 54 00    MOV   [X+0],A
    0BD2: 39 00    CMP   A,0x0
    0BD4: AF F4    JZ    0x0BC9
(0114)     //dummy write
(0115) 	SPIM_1_SendTxData(0x00);
    0BD6: 10       PUSH  X
    0BD7: 50 00    MOV   A,0x0
    0BD9: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0BDC: 20       POP   X
(0116) 	//wait for gabage byte read
(0117) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0BDD: 10       PUSH  X
    0BDE: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BE1: 20       POP   X
    0BE2: 21 08    AND   A,0x8
    0BE4: 54 00    MOV   [X+0],A
    0BE6: 39 00    CMP   A,0x0
    0BE8: AF F4    JZ    0x0BDD
(0118) 	SPIM_1_bReadRxData();
    0BEA: 10       PUSH  X
    0BEB: 7C 04 96 LCALL SPIM_1_bReadRxData|bSPIM_1_ReadRxData|_bSPIM_1_ReadRxData|_SPIM_1_bReadRxData
    0BEE: 20       POP   X
(0119) 	
(0120)     
(0121)     for(n=0;(n<cnt);)
    0BEF: 56 01 00 MOV   [X+1],0x0
    0BF2: 80 2E    JMP   0x0C21
(0122) 	{
(0123) 		//if buffer empty
(0124) 		status=SPIM_1_bReadStatus();
    0BF4: 10       PUSH  X
    0BF5: 7C 04 99 LCALL _bSPIM_1_ReadStatus|_SPIM_1_bReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BF8: 20       POP   X
    0BF9: 54 00    MOV   [X+0],A
(0125) 		if(  (status & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BFB: 48 00 10 TST   [X+0],0x10
    0BFE: A0 01    JZ    0x0C00
(0126) 			{
(0127) 		    //dummy write
(0128) 			SPIM_1_SendTxData(0x00);
    0C00: 10       PUSH  X
    0C01: 50 00    MOV   A,0x0
    0C03: 7C 04 93 LCALL _SPIM_1_SendTxData|_SPIM_1_Stop
    0C06: 20       POP   X
(0129) 			}
(0130) 		//if data		
(0131) 		if(  (status & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0C07: 48 00 08 TST   [X+0],0x8
    0C0A: A0 01    JZ    0x0C0C
(0132) 		{
(0133) 			data[n]=SPIM_1_bReadRxData();
    0C0C: 10       PUSH  X
    0C0D: 7C 04 96 LCALL SPIM_1_bReadRxData|bSPIM_1_ReadRxData|_bSPIM_1_ReadRxData|_SPIM_1_bReadRxData
    0C10: 20       POP   X
    0C11: 53 17    MOV   [__r0],A
    0C13: 52 01    MOV   A,[X+1]
    0C15: 53 14    MOV   [__r3],A
    0C17: 52 FB    MOV   A,[X-5]
    0C19: 04 14    ADD   [__r3],A
    0C1B: 51 17    MOV   A,[__r0]
    0C1D: 3F 14    MVI   [__r3],A
(0134) 			n++;
    0C1F: 77 01    INC   [X+1]
(0135) 		}
(0136)     };
    0C21: 52 01    MOV   A,[X+1]
    0C23: 3B F9    CMP   A,[X-7]
    0C25: CF CE    JC    0x0BF4
(0137) 	CS_HI();
    0C27: 10       PUSH  X
    0C28: 7C 05 A3 LCALL _CS_PIN_On
    0C2B: 20       POP   X
    0C2C: 38 FE    ADD   SP,0xFE
    0C2E: 20       POP   X
    0C2F: 7F       RET   
(0138) }
(0139) void CYRF_ReadRegisterInc(BYTE reg, BYTE data[], BYTE cnt)
(0140) {
_CYRF_ReadRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0C30: 10       PUSH  X
    0C31: 4F       MOV   X,SP
(0141) 	CYRF_ReadRegisterMulti(reg|CYRF_INCR_BIT,data,cnt);
    0C32: 52 F9    MOV   A,[X-7]
    0C34: 08       PUSH  A
    0C35: 52 FA    MOV   A,[X-6]
    0C37: 08       PUSH  A
    0C38: 52 FB    MOV   A,[X-5]
    0C3A: 08       PUSH  A
    0C3B: 52 FC    MOV   A,[X-4]
    0C3D: 29 40    OR    A,0x40
    0C3F: 08       PUSH  A
    0C40: 9F 6B    CALL  _CYRF_ReadRegisterMulti
    0C42: 38 FC    ADD   SP,0xFC
    0C44: 20       POP   X
    0C45: 7F       RET   
(0142) }
(0143) 
(0144) 
(0145) //get Mfg ID
(0146) void CYRF_GetMfgData(BYTE data[])
(0147) {
_CYRF_GetMfgData:
  data                 --> X-5
    0C46: 10       PUSH  X
    0C47: 4F       MOV   X,SP
(0148)     /* Fuses power on */
(0149)     CYRF_WriteRegister(CYRF_MFG_ID, 0xFF);
    0C48: 50 FF    MOV   A,0xFF
    0C4A: 08       PUSH  A
    0C4B: 50 25    MOV   A,0x25
    0C4D: 08       PUSH  A
    0C4E: 9E 56    CALL  _CYRF_WriteRegister
    0C50: 38 FE    ADD   SP,0xFE
(0150) 
(0151)     CYRF_ReadRegisterMulti(CYRF_MFG_ID, data, 6);
    0C52: 50 06    MOV   A,0x6
    0C54: 08       PUSH  A
    0C55: 52 FB    MOV   A,[X-5]
    0C57: 08       PUSH  A
    0C58: 52 FC    MOV   A,[X-4]
    0C5A: 08       PUSH  A
    0C5B: 50 25    MOV   A,0x25
    0C5D: 08       PUSH  A
    0C5E: 9F 4D    CALL  _CYRF_ReadRegisterMulti
(0152) 
(0153)     /* Fuses power off */
(0154)     CYRF_WriteRegister(CYRF_MFG_ID, 0x00); 
    0C60: 50 00    MOV   A,0x0
    0C62: 08       PUSH  A
    0C63: 50 25    MOV   A,0x25
    0C65: 08       PUSH  A
    0C66: 9E 3E    CALL  _CYRF_WriteRegister
    0C68: 38 FA    ADD   SP,0xFA
    0C6A: 20       POP   X
    0C6B: 7F       RET   
(0155) }
(0156) 
(0157) void CYRF_SetCRCSeed(WORD crc)
(0158) {
_CYRF_SetCRCSeed:
  crc                  --> X-5
    0C6C: 10       PUSH  X
    0C6D: 4F       MOV   X,SP
(0159)     CYRF_WriteRegister(CYRF_CRC_SEED_LSB,crc & 0xff);
    0C6E: 52 FC    MOV   A,[X-4]
    0C70: 08       PUSH  A
    0C71: 50 15    MOV   A,0x15
    0C73: 08       PUSH  A
    0C74: 9E 30    CALL  _CYRF_WriteRegister
(0160)     CYRF_WriteRegister(CYRF_CRC_SEED_MSB,crc >> 8);
    0C76: 52 FB    MOV   A,[X-5]
    0C78: 08       PUSH  A
    0C79: 50 16    MOV   A,0x16
    0C7B: 08       PUSH  A
    0C7C: 9E 28    CALL  _CYRF_WriteRegister
    0C7E: 38 FC    ADD   SP,0xFC
    0C80: 20       POP   X
    0C81: 7F       RET   
FILE: .\delay.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: delay.asm
                                        (0004) ;;
                                        (0005) ;;  DESCRIPTION: Delay functions implementation file
                                        (0006) ;;
                                        (0007) ;;-----------------------------------------------------------------------------
                                        (0008) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                        (0009) ;;*****************************************************************************
                                        (0010) ;;*****************************************************************************
                                        (0011) 
                                        (0012) ;-----------------------------------------------------------------------------
                                        (0013) ;  Include Files
                                        (0014) ;-----------------------------------------------------------------------------
                                        (0015) include "m8c.inc"
                                        (0016) include "memory.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------------------------------------
                                        (0021) export  Delay50uTimes
                                        (0022) export _Delay50uTimes
                                        (0023) 
                                        (0024) export  Delay50u
                                        (0025) export _Delay50u
                                        (0026) 
                                        (0027) area text(rom)
                                        (0028) 
                                        (0029) 
                                        (0030) .SECTION
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ;  FUNCTION NAME: Delay50uTimes
                                        (0033) ;
                                        (0034) ;  DESCRIPTION:
                                        (0035) ;     Delay increments of 50uSeconds
                                        (0036) ;
                                        (0037) ;-----------------------------------------------------------------------------
                                        (0038) ;
                                        (0039) ;  ARGUMENTS:
                                        (0040) ;     A contains the delay multiplier
                                        (0041) ;
                                        (0042) ;  RETURNS:
                                        (0043) ;
                                        (0044) ;  SIDE EFFECTS:
                                        (0045) ;    The A and X registers may be modified by this or future implementations
                                        (0046) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0047) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0048) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0049) ;    functions.
                                        (0050) ;
                                        (0051) ;
                                        (0052) 
                                        (0053)  Delay50uTimes:
                                        (0054) _Delay50uTimes:
                                        (0055)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0056) 
0C82: 90 0C    CALL  _Delay50u          (0057)     call  Delay50u
0C84: 78       DEC   A                  (0058) 	dec A
0C85: BF FC    JNZ   _Delay50uTimes     (0059)     jnz   Delay50uTimes
                                        (0060) 
                                        (0061) 	
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_1
0C87: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) .ENDSECTION
                                        (0066) 
                                        (0067) ;-----------------------------------------------------------------------------
                                        (0068) ;  FUNCTION NAME: Delay50u
                                        (0069) ;
                                        (0070) ;  DESCRIPTION:
                                        (0071) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                        (0072) ;     Slower clock frequencies the delay will be;
                                        (0073) ;           1.5
                                        (0074) ;        -------------- * 50uSec
                                        (0075) ;        clock_freq(MHz)
                                        (0076) ;
                                        (0077) ;
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;
                                        (0080) ;  ARGUMENTS: none
                                        (0081) ;
                                        (0082) ;  RETURNS: none
                                        (0083) ;
                                        (0084) ;  SIDE EFFECTS:
                                        (0085) ;    The A and X registers may be modified by this or future implementations
                                        (0086) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0088) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0089) ;    functions.
                                        (0090) ;
                                        (0091) ;  THEORY of OPERATION or PROCEDURE:
                                        (0092) ;
                                        (0093) .LITERAL
                                        (0094)  Delay50u_Table::
                                        (0095)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                        (0096) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                        (0097) .ENDLITERAL
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)   Delay50u:
                                        (0101)  _Delay50u:                      ; [11]  Call
                                        (0102)     RAM_PROLOGUE RAM_USE_CLASS_1
0C90: 08       PUSH  A                  (0103)     push  A
0C91: 71 10    OR    F,0x10             
                                        (0104)     M8C_SetBank1                       ; [4]
0C93: 5D E0    MOV   A,REG[0xE0]        (0105)     mov   A, reg[OSC_CR0]              ; [6] Get delay value
0C95: 70 EF    AND   F,0xEF             
                                        (0106)     M8C_SetBank0                       ; [4]
0C97: 21 07    AND   A,0x7              (0107)     and   A,07h                        ; [4] Mask off only the clock bits
0C99: 39 05    CMP   A,0x5              (0108)     cmp   A,05h
0C9B: D0 06    JNC   0x0CA2             (0109)     jnc   Delay50u_End
0C9D: FF E9    INDEX Delay50u_Table     (0110)     index Delay50u_Table               ; [13] Get delay value
                                        (0111) Delay50u_Loop:                         ;
0C9F: 78       DEC   A                  (0112)     dec   A                            ; [4]
0CA0: BF FE    JNZ   0x0C9F             (0113)     jnz   Delay50u_Loop                ; [5]
                                        (0114) Delay50u_End:
0CA2: 18       POP   A                  (0115)     pop   A
                                        (0116)     RAM_EPILOGUE RAM_USE_CLASS_1
0CA3: 7F       RET                      (0117)     ret
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\dsm.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "m8c.h"
(0003) #include "dsm.h"
(0004) #include "timer.h"
(0005) #include "ppm.h"
(0006) 
(0007) //#define DEBUG
(0008) 
(0009) //share memory with flash buffer
(0010) extern RAM_D mem;
(0011) #define tx_buf mem.b.buf0
(0012) //BYTE tx_buf[16];	//transmit buffer
(0013) #define rx_buf mem.b.buf1
(0014) //BYTE rx_buf[16];	//recive buffer
(0015) //BYTE rx_data[16]; //recived data
(0016) #define rx_data mem.rx_d 
(0017) 
(0018) 
(0019) //global data
(0020) BYTE channels[DSM_CH_CNT]; 	//list of channels
(0021) BYTE chidx;			//current channel index	
(0022) BOOL Ch_A;			//true for channel A false for channel B
(0023) BYTE sop_col;		
(0024) BYTE data_col;		
(0025) BYTE State;		
(0026) BYTE num_channels;	//number fo transmit channels
(0027) config_s config;
(0028) WORD DSM_Perriode;		//cycle time - 4000
(0029) BYTE lost_cnt;
(0030) BOOL New_RCV_Data;
(0031) volatile BOOL new_data;
(0032) volatile BOOL Rcv_Timeout;
(0033) 
(0034) //prototypes
(0035) void DSM_initialize_bind_ack(void);
(0036) void calc_dsmx_channel(void);
(0037) void DSM_StartBindAck(void);
(0038) void DSM_StartRcv(void);
(0039) void Bind_TimeOut_cb(void);
(0040) void Process_BindRcvIrq(void);
(0041) void ProcessNewData(void );
(0042) BYTE DSM_DeterminBitCount(void);
(0043) BOOL DSM_process_Data(void);
(0044) 
(0045) volatile WORD ppm_Data[PPM_PULSE_COUNT];	//the pulse len value for the chanales
(0046) 
(0047) 
(0048) static const BYTE pn_bind[] = {0x98, 0x88, 0x1B, 0xE4, 0x30, 0x79, 0x03, 0x84}; //used for sending bind response
(0049) 
(0050) static const BYTE pncodes[5][9][8] = {
(0051)     /* Note these are in order transmitted (LSB 1st) */
(0052) { /* Row 0 */
(0053)   /* Col 0 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8},
(0054)   /* Col 1 */ {0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6},
(0055)   /* Col 2 */ {0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9},
(0056)   /* Col 3 */ {0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4},
(0057)   /* Col 4 */ {0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0},
(0058)   /* Col 5 */ {0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8},
(0059)   /* Col 6 */ {0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D},
(0060)   /* Col 7 */ {0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1},
(0061)   /* Col 8 */ {0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86}
(0062) },
(0063) { /* Row 1 */
(0064)   /* Col 0 */ {0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3},
(0065)   /* Col 1 */ {0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9},
(0066)   /* Col 2 */ {0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82},
(0067)   /* Col 3 */ {0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB},
(0068)   /* Col 4 */ {0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7},
(0069)   /* Col 5 */ {0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95},
(0070)   /* Col 6 */ {0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4},
(0071)   /* Col 7 */ {0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF},
(0072)   /* Col 8 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97}
(0073) },
(0074) { /* Row 2 */
(0075)   /* Col 0 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97},
(0076)   /* Col 1 */ {0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA},
(0077)   /* Col 2 */ {0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE},
(0078)   /* Col 3 */ {0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD},
(0079)   /* Col 4 */ {0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD},
(0080)   /* Col 5 */ {0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9},
(0081)   /* Col 6 */ {0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3},
(0082)   /* Col 7 */ {0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0},
(0083)   /* Col 8 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E}
(0084) },
(0085) { /* Row 3 */
(0086)   /* Col 0 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E},
(0087)   /* Col 1 */ {0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7},
(0088)   /* Col 2 */ {0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1},
(0089)   /* Col 3 */ {0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4},
(0090)   /* Col 4 */ {0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6},
(0091)   /* Col 5 */ {0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80},
(0092)   /* Col 6 */ {0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88},
(0093)   /* Col 7 */ {0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88},
(0094)   /* Col 8 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93}
(0095) },
(0096) { /* Row 4 */
(0097)   /* Col 0 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93},
(0098)   /* Col 1 */ {0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C},
(0099)   /* Col 2 */ {0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA},
(0100)   /* Col 3 */ {0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC},
(0101)   /* Col 4 */ {0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84},
(0102)   /* Col 5 */ {0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7},
(0103)   /* Col 6 */ {0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0},
(0104)   /* Col 7 */ {0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1},
(0105)   /* Col 8 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8}
(0106) },};
(0107) 
(0108) 
(0109) static const BYTE init_vals[][2] = {
(0110) //	{CYRF_MODE_OVERRIDE, 0x01},
(0111)     {CYRF_CLK_EN, CLK_EN_RXF},  //0x02
(0112)     {CYRF_AUTO_CAL_TIME, 0x3c}, //see cyrf manual
(0113)     {CYRF_AUTO_CAL_OFFSET, 0x14}, //see cyrf manual
(0114) 	{CYRF_IO_CFG,IO_CFG_IRQ_POL}, //0x40 IRQ active High 
(0115)     {CYRF_RX_CFG, RX_LNA|FAST_TURN_EN}, //0x48 Fast Turn Mode Enable, Low Noise Amplifier ON
(0116)     {CYRF_TX_OFFSET_LSB, 0x55},//see cyrf manual
(0117)     {CYRF_TX_OFFSET_MSB, 0x05},//see cyrf manual
(0118)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END}, //0x24 Force  Idle Mode
(0119)     {CYRF_DATA64_THOLD, 0x0a},//see cyrf manual
(0120)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)}, //0x04 Transaction End State Idle Mode
(0121) 	{CYRF_ANALOG_CTRL, ALL_SLOW}, //0x01 all slow
(0122)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)| CYRF_FRC_END}, //0x24 Force IDLE
(0123) 	{CYRF_RX_ABORT, 0x00}, //Clear RX abort
(0124)     {CYRF_DATA64_THOLD, 0x0a}, //set pn correlation threshold
(0125)     {CYRF_FRAMING_CFG, SOP_LEN|0xa}, //set sop len and threshold
(0126)     {CYRF_RX_ABORT, 0x0f}, //Clear RX abort?
(0127) };
(0128) 
(0129) 
(0130) static const BYTE rcv_vals[][2] = {
(0131)     {CYRF_TX_CFG,TX_DM(TX_DM_8DR)|DSM_BIND_POWER}, //0xD DDR Mode  32 chip codes
(0132) 	{CYRF_FRAMING_CFG,LEN_EN|SOP_LEN|SOP_EN|0xE},  //0xEE SOP Enable SOP code length is 64 chips Packet Length Enable  SOP Correlator Threshold=0xE
(0133)     {CYRF_TX_OVERRIDE, 0x00},
(0134)     {CYRF_RX_OVERRIDE, 0x00},
(0135) };
(0136) 
(0137) static const BYTE preamble[]={0x04,0x33,0x33};
(0138) static  BYTE tx_cmd[]={0xA,TXE_IRQEN|TXC_IRQEN|TX_GO|TX_CLR}; //0xC3
(0139) 
(0140) void SetChannel(void)
(0141) {
_SetChannel:
  CRCSeed              --> X+2
  pn_row               --> X+1
  channel              --> X+0
    0CA4: 10       PUSH  X
    0CA5: 4F       MOV   X,SP
    0CA6: 38 08    ADD   SP,0x8
(0142) 	BYTE channel=channels[chidx];
    0CA8: 5F 16 4D MOV   [__r1],[chidx]
    0CAB: 06 16 4E ADD   [__r1],0x4E
    0CAE: 3E 16    MVI   A,[__r1]
    0CB0: 54 00    MOV   [X+0],A
(0143) 	BYTE pn_row = DSM_Is_DSMX ? (channel - 2)%5 : channel%5;
    0CB2: 3C 77 00 CMP   [config+4],0x0
    0CB5: A0 27    JZ    0x0CDD
    0CB7: 52 00    MOV   A,[X+0]
    0CB9: 53 16    MOV   [__r1],A
    0CBB: 55 17 00 MOV   [__r0],0x0
    0CBE: 16 16 02 SUB   [__r1],0x2
    0CC1: 1E 17 00 SBB   [__r0],0x0
    0CC4: 50 00    MOV   A,0x0
    0CC6: 08       PUSH  A
    0CC7: 50 05    MOV   A,0x5
    0CC9: 08       PUSH  A
    0CCA: 51 17    MOV   A,[__r0]
    0CCC: 08       PUSH  A
    0CCD: 51 16    MOV   A,[__r1]
    0CCF: 08       PUSH  A
    0CD0: 7C 1D FB LCALL 0x1DFB
    0CD3: 38 FE    ADD   SP,0xFE
    0CD5: 18       POP   A
    0CD6: 54 05    MOV   [X+5],A
    0CD8: 18       POP   A
    0CD9: 54 04    MOV   [X+4],A
    0CDB: 80 1C    JMP   0x0CF8
    0CDD: 52 00    MOV   A,[X+0]
    0CDF: 53 16    MOV   [__r1],A
    0CE1: 50 00    MOV   A,0x0
    0CE3: 08       PUSH  A
    0CE4: 50 05    MOV   A,0x5
    0CE6: 08       PUSH  A
    0CE7: 50 00    MOV   A,0x0
    0CE9: 08       PUSH  A
    0CEA: 51 16    MOV   A,[__r1]
    0CEC: 08       PUSH  A
    0CED: 7C 1D FB LCALL 0x1DFB
    0CF0: 38 FE    ADD   SP,0xFE
    0CF2: 18       POP   A
    0CF3: 54 05    MOV   [X+5],A
    0CF5: 18       POP   A
    0CF6: 54 04    MOV   [X+4],A
    0CF8: 52 05    MOV   A,[X+5]
    0CFA: 54 01    MOV   [X+1],A
(0144) 	WORD CRCSeed=Ch_A?~((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]):((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]);
    0CFC: 3C 4C 00 CMP   [Ch_A],0x0
    0CFF: A0 18    JZ    0x0D18
    0D01: 7C 1F 84 LCALL 0x1F84
    0D04: 53 16    MOV   [__r1],A
    0D06: 51 15    MOV   A,[__r2]
    0D08: 0A 17    ADC   A,[__r0]
    0D0A: 53 17    MOV   [__r0],A
    0D0C: 51 16    MOV   A,[__r1]
    0D0E: 73       CPL   A
    0D0F: 54 07    MOV   [X+7],A
    0D11: 51 17    MOV   A,[__r0]
    0D13: 73       CPL   A
    0D14: 54 06    MOV   [X+6],A
    0D16: 80 0C    JMP   0x0D23
    0D18: 7C 1F 84 LCALL 0x1F84
    0D1B: 54 07    MOV   [X+7],A
    0D1D: 51 15    MOV   A,[__r2]
    0D1F: 0A 17    ADC   A,[__r0]
    0D21: 54 06    MOV   [X+6],A
    0D23: 52 07    MOV   A,[X+7]
    0D25: 54 03    MOV   [X+3],A
    0D27: 52 06    MOV   A,[X+6]
    0D29: 54 02    MOV   [X+2],A
(0145) 	CYRF_SetRFChannel(channel);
    0D2B: 52 00    MOV   A,[X+0]
    0D2D: 08       PUSH  A
    0D2E: 50 00    MOV   A,0x0
    0D30: 08       PUSH  A
    0D31: 7C 0A A6 LCALL _CYRF_WriteRegister
(0146) 	CYRF_SetCRCSeed(CRCSeed);
    0D34: 52 02    MOV   A,[X+2]
    0D36: 08       PUSH  A
    0D37: 52 03    MOV   A,[X+3]
    0D39: 08       PUSH  A
    0D3A: 7C 0C 6C LCALL _CYRF_SetCRCSeed
    0D3D: 38 FC    ADD   SP,0xFC
(0147)     CYRF_SetSOPCode(pncodes[pn_row][sop_col]);
    0D3F: 50 08    MOV   A,0x8
    0D41: 08       PUSH  A
    0D42: 52 01    MOV   A,[X+1]
    0D44: 53 16    MOV   [__r1],A
    0D46: 50 00    MOV   A,0x0
    0D48: 08       PUSH  A
    0D49: 51 16    MOV   A,[__r1]
    0D4B: 08       PUSH  A
    0D4C: 50 00    MOV   A,0x0
    0D4E: 08       PUSH  A
    0D4F: 50 48    MOV   A,0x48
    0D51: 08       PUSH  A
    0D52: 7C 1E FE LCALL 0x1EFE
    0D55: 38 FC    ADD   SP,0xFC
    0D57: 5F 16 0B MOV   [__r1],[__rX]
    0D5A: 5F 17 0A MOV   [__r0],[__rY]
    0D5D: 06 16 78 ADD   [__r1],0x78
    0D60: 0E 17 01 ADC   [__r0],0x1
    0D63: 5F 14 4B MOV   [__r3],[sop_col]
    0D66: 55 15 00 MOV   [__r2],0x0
    0D69: 65 14    ASL   [__r3]
    0D6B: 6B 15    RLC   [__r2]
    0D6D: 65 14    ASL   [__r3]
    0D6F: 6B 15    RLC   [__r2]
    0D71: 65 14    ASL   [__r3]
    0D73: 6B 15    RLC   [__r2]
    0D75: 51 14    MOV   A,[__r3]
    0D77: 02 16    ADD   A,[__r1]
    0D79: 53 16    MOV   [__r1],A
    0D7B: 51 15    MOV   A,[__r2]
    0D7D: 0A 17    ADC   A,[__r0]
    0D7F: 08       PUSH  A
    0D80: 51 16    MOV   A,[__r1]
    0D82: 08       PUSH  A
    0D83: 50 22    MOV   A,0x22
    0D85: 08       PUSH  A
    0D86: 7C 0A BF LCALL _CYRF_WriteRegisterMulti
    0D89: 38 FC    ADD   SP,0xFC
(0148)     CYRF_SetDataCode(pncodes[pn_row][data_col], 16);
    0D8B: 50 10    MOV   A,0x10
    0D8D: 08       PUSH  A
    0D8E: 52 01    MOV   A,[X+1]
    0D90: 53 16    MOV   [__r1],A
    0D92: 50 00    MOV   A,0x0
    0D94: 08       PUSH  A
    0D95: 51 16    MOV   A,[__r1]
    0D97: 08       PUSH  A
    0D98: 50 00    MOV   A,0x0
    0D9A: 08       PUSH  A
    0D9B: 50 48    MOV   A,0x48
    0D9D: 08       PUSH  A
    0D9E: 7C 1E FE LCALL 0x1EFE
    0DA1: 38 FC    ADD   SP,0xFC
    0DA3: 5F 16 0B MOV   [__r1],[__rX]
    0DA6: 5F 17 0A MOV   [__r0],[__rY]
    0DA9: 06 16 78 ADD   [__r1],0x78
    0DAC: 0E 17 01 ADC   [__r0],0x1
    0DAF: 5F 14 4A MOV   [__r3],[data_col]
    0DB2: 55 15 00 MOV   [__r2],0x0
    0DB5: 65 14    ASL   [__r3]
    0DB7: 6B 15    RLC   [__r2]
    0DB9: 65 14    ASL   [__r3]
    0DBB: 6B 15    RLC   [__r2]
    0DBD: 65 14    ASL   [__r3]
    0DBF: 6B 15    RLC   [__r2]
    0DC1: 51 14    MOV   A,[__r3]
    0DC3: 02 16    ADD   A,[__r1]
    0DC5: 53 16    MOV   [__r1],A
    0DC7: 51 15    MOV   A,[__r2]
    0DC9: 0A 17    ADC   A,[__r0]
    0DCB: 08       PUSH  A
    0DCC: 51 16    MOV   A,[__r1]
    0DCE: 08       PUSH  A
    0DCF: 50 23    MOV   A,0x23
    0DD1: 08       PUSH  A
    0DD2: 7C 0A BF LCALL _CYRF_WriteRegisterMulti
    0DD5: 38 FC    ADD   SP,0xFC
    0DD7: 38 F8    ADD   SP,0xF8
    0DD9: 20       POP   X
    0DDA: 7F       RET   
(0149) }
(0150) 
(0151) //calculate and set channel CRC , SOP and data code 
(0152) void SetCH_INC(void)
(0153) {
_SetCH_INC:
    0DDB: 10       PUSH  X
    0DDC: 4F       MOV   X,SP
    0DDD: 38 04    ADD   SP,0x4
(0154) 	Ch_A=!Ch_A;	
    0DDF: 3C 4C 00 CMP   [Ch_A],0x0
    0DE2: B0 09    JNZ   0x0DEC
    0DE4: 56 01 01 MOV   [X+1],0x1
    0DE7: 56 00 00 MOV   [X+0],0x0
    0DEA: 80 07    JMP   0x0DF2
    0DEC: 56 01 00 MOV   [X+1],0x0
    0DEF: 56 00 00 MOV   [X+0],0x0
    0DF2: 52 01    MOV   A,[X+1]
    0DF4: 53 4C    MOV   [Ch_A],A
(0155) #ifdef DEBUG
(0156) 	LED_1_6_Switch(Ch_A?1:0);
(0157) #endif
(0158)     if(DSM_Is_DSMX)
    0DF6: 3C 77 00 CMP   [config+4],0x0
    0DF9: A0 17    JZ    0x0E11
(0159)         chidx = (chidx + 1) % 23;
    0DFB: 51 4D    MOV   A,[chidx]
    0DFD: 01 01    ADD   A,0x1
    0DFF: 53 17    MOV   [__r0],A
    0E01: 50 17    MOV   A,0x17
    0E03: 08       PUSH  A
    0E04: 51 17    MOV   A,[__r0]
    0E06: 08       PUSH  A
    0E07: 7C 1E 50 LCALL 0x1E50
    0E0A: 38 FF    ADD   SP,0xFF
    0E0C: 18       POP   A
    0E0D: 53 4D    MOV   [chidx],A
    0E0F: 80 18    JMP   0x0E28
(0160)     else
(0161)         chidx = Ch_A?0:1;
    0E11: 3C 4C 00 CMP   [Ch_A],0x0
    0E14: A0 09    JZ    0x0E1E
    0E16: 56 03 00 MOV   [X+3],0x0
    0E19: 56 02 00 MOV   [X+2],0x0
    0E1C: 80 07    JMP   0x0E24
    0E1E: 56 03 01 MOV   [X+3],0x1
    0E21: 56 02 00 MOV   [X+2],0x0
    0E24: 52 03    MOV   A,[X+3]
    0E26: 53 4D    MOV   [chidx],A
(0162) 	SetChannel();
    0E28: 9E 7A    CALL  _SetChannel
    0E2A: 38 FC    ADD   SP,0xFC
    0E2C: 20       POP   X
    0E2D: 7F       RET   
(0163) }
(0164) 
(0165) //load the given config into cyfr6936
(0166) void DSM_Load_Config(const BYTE vals[][2],BYTE cnt)
(0167) {
_DSM_Load_Config:
  n                    --> X+0
  cnt                  --> X-6
  vals                 --> X-5
    0E2E: 10       PUSH  X
    0E2F: 4F       MOV   X,SP
    0E30: 38 01    ADD   SP,0x1
(0168) BYTE n;
(0169) 
(0170) for(n=0;n<cnt;n++)
    0E32: 56 00 00 MOV   [X+0],0x0
    0E35: 80 2B    JMP   0x0E61
(0171) 	{
(0172) 	CYRF_WriteRegister(vals[n][0],vals[n][1]);
    0E37: 7C 1F 6C LCALL <created procedures>
    0E3A: 52 FC    MOV   A,[X-4]
    0E3C: 04 16    ADD   [__r1],A
    0E3E: 52 FB    MOV   A,[X-5]
    0E40: 0C 17    ADC   [__r0],A
    0E42: 51 16    MOV   A,[__r1]
    0E44: 01 01    ADD   A,0x1
    0E46: 53 14    MOV   [__r3],A
    0E48: 51 17    MOV   A,[__r0]
    0E4A: 09 00    ADC   A,0x0
    0E4C: 10       PUSH  X
    0E4D: 58 14    MOV   X,[__r3]
    0E4F: 28       ROMX  
    0E50: 20       POP   X
    0E51: 08       PUSH  A
    0E52: 51 17    MOV   A,[__r0]
    0E54: 10       PUSH  X
    0E55: 58 16    MOV   X,[__r1]
    0E57: 28       ROMX  
    0E58: 20       POP   X
    0E59: 08       PUSH  A
    0E5A: 7C 0A A6 LCALL _CYRF_WriteRegister
    0E5D: 38 FE    ADD   SP,0xFE
(0173) 	}
    0E5F: 77 00    INC   [X+0]
    0E61: 52 00    MOV   A,[X+0]
    0E63: 3B FA    CMP   A,[X-6]
    0E65: CF D1    JC    0x0E37
    0E67: 38 FF    ADD   SP,0xFF
    0E69: 20       POP   X
    0E6A: 7F       RET   
(0174) }
(0175) 
(0176) 
(0177) //clear recive error and pending interupt flags
(0178) void DSM_ClearRxError(void)
(0179) {
_DSM_ClearRxError:
  i                    --> X+0
    0E6B: 10       PUSH  X
    0E6C: 4F       MOV   X,SP
    0E6D: 38 01    ADD   SP,0x1
(0180) 	BYTE i=100;
    0E6F: 56 00 64 MOV   [X+0],0x64
(0181) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    0E72: 50 07    MOV   A,0x7
    0E74: 08       PUSH  A
    0E75: 7C 0B 95 LCALL _CYRF_ReadRegister
(0182) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    0E78: 50 07    MOV   A,0x7
    0E7A: 08       PUSH  A
    0E7B: 7C 0B 95 LCALL _CYRF_ReadRegister
    0E7E: 38 FE    ADD   SP,0xFE
(0183) 	CYRF_WriteRegister(CYRF_RX_ABORT,ABORT_EN); //abort
    0E80: 50 20    MOV   A,0x20
    0E82: 08       PUSH  A
    0E83: 50 29    MOV   A,0x29
    0E85: 08       PUSH  A
    0E86: 7C 0A A6 LCALL _CYRF_WriteRegister
(0184) 	//force end state
(0185) 	CYRF_WriteRegister(CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END);
    0E89: 50 24    MOV   A,0x24
    0E8B: 08       PUSH  A
    0E8C: 50 0F    MOV   A,0xF
    0E8E: 08       PUSH  A
    0E8F: 7C 0A A6 LCALL _CYRF_WriteRegister
    0E92: 38 FC    ADD   SP,0xFC
    0E94: 80 0A    JMP   0x0E9F
(0186)     while (! (CYRF_ReadRegister(CYRF_XACT_CFG) & CYRF_XACT_END_STATE(CYRF_MODE_IDLE))) 
(0187) 	{
(0188)         if(!--i)
    0E96: 17 00 01 SUB   [X+0],0x1
    0E99: 52 00    MOV   A,[X+0]
    0E9B: B0 03    JNZ   0x0E9F
(0189)             break;
    0E9D: 80 10    JMP   0x0EAE
(0190) 	}
    0E9F: 50 0F    MOV   A,0xF
    0EA1: 08       PUSH  A
    0EA2: 7C 0B 95 LCALL _CYRF_ReadRegister
    0EA5: 38 FF    ADD   SP,0xFF
    0EA7: 53 17    MOV   [__r0],A
    0EA9: 47 17 04 TST   [__r0],0x4
    0EAC: AF E9    JZ    0x0E96
(0191) 	//clear abort
(0192) 	CYRF_WriteRegister(CYRF_RX_ABORT,0);
    0EAE: 50 00    MOV   A,0x0
    0EB0: 08       PUSH  A
    0EB1: 50 29    MOV   A,0x29
    0EB3: 08       PUSH  A
    0EB4: 7C 0A A6 LCALL _CYRF_WriteRegister
    0EB7: 38 FE    ADD   SP,0xFE
    0EB9: 38 FF    ADD   SP,0xFF
    0EBB: 20       POP   X
    0EBC: 7F       RET   
(0193) }
(0194) void SYNC_AB_TimeOut_cb(void)
(0195) {
(0196) 	DSM_ClearRxError();
_SYNC_AB_TimeOut_cb:
    0EBD: 9F AC    CALL  _DSM_ClearRxError
(0197) #ifdef DEBUG
(0198) 	LED_1_5_Invert();
(0199) #endif
(0200) 	channels[chidx]++;
    0EBF: 5F 16 4D MOV   [__r1],[chidx]
    0EC2: 06 16 4E ADD   [__r1],0x4E
    0EC5: 3E 16    MVI   A,[__r1]
    0EC7: 7A 16    DEC   [__r1]
    0EC9: 01 01    ADD   A,0x1
    0ECB: 3F 16    MVI   [__r1],A
(0201) 	if(channels[chidx]>DSM_MAX_CH)
    0ECD: 5F 16 4D MOV   [__r1],[chidx]
    0ED0: 06 16 4E ADD   [__r1],0x4E
    0ED3: 3E 16    MVI   A,[__r1]
    0ED5: 53 17    MOV   [__r0],A
    0ED7: 50 4F    MOV   A,0x4F
    0ED9: 3A 17    CMP   A,[__r0]
    0EDB: D0 0B    JNC   0x0EE7
(0202) 		channels[chidx]=0;	
    0EDD: 5F 16 4D MOV   [__r1],[chidx]
    0EE0: 06 16 4E ADD   [__r1],0x4E
    0EE3: 50 00    MOV   A,0x0
    0EE5: 3F 16    MVI   [__r1],A
(0203) 	SetChannel();
    0EE7: 9D BB    CALL  _SetChannel
(0204) 	DSM_StartRcv();	
    0EE9: 96 F5    CALL  _DSM_StartRcv
    0EEB: 7F       RET   
(0205) }
(0206) 
(0207) static cnt=0;
(0208) void SYNC_X_TimeOut_cb(void)
(0209) {
(0210) 	if (cnt==0)
_SYNC_X_TimeOut_cb:
    0EEC: 3C 02 00 CMP   [dsm.c:cnt|value|cnt],0x0
    0EEF: B0 0C    JNZ   0x0EFC
    0EF1: 3C 03 00 CMP   [dsm.c:cnt|value|cnt+1],0x0
    0EF4: B0 07    JNZ   0x0EFC
(0211) 	{
(0212) 		DSM_ClearRxError();
    0EF6: 9F 73    CALL  _DSM_ClearRxError
(0213) 		SetCH_INC();
    0EF8: 9E E1    CALL  _SetCH_INC
(0214) 		DSM_StartRcv();	
    0EFA: 96 E4    CALL  _DSM_StartRcv
(0215) 	}
(0216) 	Rcv_Timeout=TRUE;
    0EFC: 55 89 01 MOV   [Rcv_Timeout],0x1
(0217) 	cnt=(cnt+1)%4;
    0EFF: 51 03    MOV   A,[dsm.c:cnt|value|cnt+1]
    0F01: 01 01    ADD   A,0x1
    0F03: 53 16    MOV   [__r1],A
    0F05: 51 02    MOV   A,[dsm.c:cnt|value|cnt]
    0F07: 09 00    ADC   A,0x0
    0F09: 53 17    MOV   [__r0],A
    0F0B: 50 00    MOV   A,0x0
    0F0D: 08       PUSH  A
    0F0E: 50 04    MOV   A,0x4
    0F10: 08       PUSH  A
    0F11: 51 17    MOV   A,[__r0]
    0F13: 08       PUSH  A
    0F14: 51 16    MOV   A,[__r1]
    0F16: 08       PUSH  A
    0F17: 7C 1D FB LCALL 0x1DFB
    0F1A: 38 FE    ADD   SP,0xFE
    0F1C: 18       POP   A
    0F1D: 53 03    MOV   [dsm.c:cnt|value|cnt+1],A
    0F1F: 18       POP   A
    0F20: 53 02    MOV   [dsm.c:cnt|value|cnt],A
    0F22: 7F       RET   
(0218) #ifdef DEBUG
(0219) 	LED_1_5_Invert();
(0220) #endif
(0221) }
(0222) 
(0223) void DSM_Set_SyncX_State(void )
(0224) {
(0225) 		State=DSM_STATE_SYNC_X;
_DSM_Set_SyncX_State:
    0F23: 55 8B 0A MOV   [State],0xA
(0226) #ifdef DEBUG
(0227) 		LED_1_7_Off();
(0228) #endif
(0229) 		lost_cnt=0;
    0F26: 55 48 00 MOV   [lost_cnt],0x0
(0230) 		Rcv_Timeout=FALSE;
    0F29: 55 89 00 MOV   [Rcv_Timeout],0x0
(0231) 		if (DSM_Is_DSMX)
    0F2C: 3C 77 00 CMP   [config+4],0x0
    0F2F: A0 0A    JZ    0x0F3A
(0232) 			Timer_SetPeriod(DSM_FULL_SEQUENCE_TIME);
    0F31: 10       PUSH  X
    0F32: 50 55    MOV   A,0x55
    0F34: 7C 04 8B LCALL _Timer8_1_WritePeriod
    0F37: 20       POP   X
    0F38: 80 08    JMP   0x0F41
(0233) 		else
(0234) 			Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);
    0F3A: 10       PUSH  X
    0F3B: 50 56    MOV   A,0x56
    0F3D: 7C 04 8B LCALL _Timer8_1_WritePeriod
    0F40: 20       POP   X
(0235) 		Timer_SetCallback(SYNC_X_TimeOut_cb);
    0F41: 50 03    MOV   A,0x3
    0F43: 08       PUSH  A
    0F44: 50 28    MOV   A,0x28
    0F46: 08       PUSH  A
    0F47: 7C 1D 64 LCALL _Timer_SetCallback
    0F4A: 38 FE    ADD   SP,0xFE
    0F4C: 7F       RET   
(0236) }
(0237) 
(0238) void Rcv_X_TimeOut_cb(void)
(0239) {
(0240) 	Timer_Stop();
_Rcv_X_TimeOut_cb:
    0F4D: 10       PUSH  X
    0F4E: 7C 04 87 LCALL _Timer8_1_Stop
    0F51: 20       POP   X
(0241) 	if(Ch_A)
    0F52: 3C 4C 00 CMP   [Ch_A],0x0
    0F55: A0 0A    JZ    0x0F60
(0242) 		{
(0243) 		Timer_SetPeriod(DSM_TIME_CHA_CHB);
    0F57: 10       PUSH  X
    0F58: 50 0F    MOV   A,0xF
    0F5A: 7C 04 8B LCALL _Timer8_1_WritePeriod
    0F5D: 20       POP   X
(0244) 		}
    0F5E: 80 0B    JMP   0x0F6A
(0245) 	else
(0246) 		{
(0247) 		Timer_SetPeriod(DSM_Perriode);
    0F60: 5F 17 8D MOV   [__r0],[DSM_Perriode+1]
    0F63: 10       PUSH  X
    0F64: 51 17    MOV   A,[__r0]
    0F66: 7C 04 8B LCALL _Timer8_1_WritePeriod
    0F69: 20       POP   X
(0248) 		}
(0249) 		
(0250) 	if(lost_cnt++>DSM_CH_CNT/2 && !Ch_A)
    0F6A: 5F 16 48 MOV   [__r1],[lost_cnt]
    0F6D: 55 17 00 MOV   [__r0],0x0
    0F70: 51 16    MOV   A,[__r1]
    0F72: 01 01    ADD   A,0x1
    0F74: 53 48    MOV   [lost_cnt],A
    0F76: 50 0B    MOV   A,0xB
    0F78: 12 16    SUB   A,[__r1]
    0F7A: 50 00    MOV   A,0x0
    0F7C: 31 80    XOR   A,0x80
    0F7E: 53 0B    MOV   [__rX],A
    0F80: 50 80    MOV   A,0x80
    0F82: 1A 0B    SBB   A,[__rX]
    0F84: D0 08    JNC   0x0F8D
    0F86: 3C 4C 00 CMP   [Ch_A],0x0
    0F89: B0 03    JNZ   0x0F8D
(0251) 		{
(0252) 		DSM_Set_SyncX_State();
    0F8B: 9F 96    CALL  _DSM_Set_SyncX_State
(0253) 		}
(0254) 	Timer_Start();
    0F8D: 10       PUSH  X
    0F8E: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    0F91: 20       POP   X
(0255) 	DSM_ClearRxError();
    0F92: 9E D7    CALL  _DSM_ClearRxError
(0256) 	SetCH_INC();
    0F94: 9E 45    CALL  _SetCH_INC
(0257) 	DSM_StartRcv();	
    0F96: 96 48    CALL  _DSM_StartRcv
(0258) 	New_RCV_Data=TRUE;
    0F98: 55 47 01 MOV   [New_RCV_Data],0x1
    0F9B: 7F       RET   
(0259) #ifdef DEBUG
(0260) 	LED_1_5_Invert();
(0261) #endif
(0262) }
(0263) 
(0264) void DSM_initialize_Recive(void)
(0265) {
_DSM_initialize_Recive:
    0F9C: 10       PUSH  X
    0F9D: 4F       MOV   X,SP
    0F9E: 38 02    ADD   SP,0x2
(0266) 	chidx=0;
    0FA0: 55 4D 00 MOV   [chidx],0x0
(0267) 	Ch_A=TRUE;
    0FA3: 55 4C 01 MOV   [Ch_A],0x1
(0268) 	Rcv_Timeout=FALSE;
    0FA6: 55 89 00 MOV   [Rcv_Timeout],0x0
(0269) 	New_RCV_Data=FALSE;
    0FA9: 55 47 00 MOV   [New_RCV_Data],0x0
(0270) 	lost_cnt=0;
    0FAC: 55 48 00 MOV   [lost_cnt],0x0
(0271) 	sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
    0FAF: 51 73    MOV   A,[config]
    0FB1: 02 74    ADD   A,[config+1]
    0FB3: 53 17    MOV   [__r0],A
    0FB5: 51 75    MOV   A,[config+2]
    0FB7: 04 17    ADD   [__r0],A
    0FB9: 06 17 02 ADD   [__r0],0x2
    0FBC: 51 17    MOV   A,[__r0]
    0FBE: 21 07    AND   A,0x7
    0FC0: 53 4B    MOV   [sop_col],A
(0272)     data_col = 7 - sop_col;
    0FC2: 50 07    MOV   A,0x7
    0FC4: 12 4B    SUB   A,[sop_col]
    0FC6: 53 4A    MOV   [data_col],A
(0273) 	DSM_Load_Config(rcv_vals,sizeof(rcv_vals)/(sizeof(BYTE)*2));
    0FC8: 50 04    MOV   A,0x4
    0FCA: 08       PUSH  A
    0FCB: 50 03    MOV   A,0x3
    0FCD: 08       PUSH  A
    0FCE: 50 00    MOV   A,0x0
    0FD0: 08       PUSH  A
    0FD1: 9E 5B    CALL  _DSM_Load_Config
    0FD3: 38 FD    ADD   SP,0xFD
(0274) 	if(DSM_Is_DSMX)
    0FD5: 3C 77 00 CMP   [config+4],0x0
    0FD8: A0 08    JZ    0x0FE1
(0275) 		{
(0276) 		calc_dsmx_channel();	
    0FDA: 92 74    CALL  _calc_dsmx_channel
(0277) 		State=DSM_STATE_SYNC_X;
    0FDC: 55 8B 0A MOV   [State],0xA
(0278) 		}
    0FDF: 80 0A    JMP   0x0FEA
(0279) 	else
(0280) 		{
(0281) 		channels[0]=channels[1]=1;	
    0FE1: 55 4F 01 MOV   [channels+1],0x1
    0FE4: 55 4E 01 MOV   [channels],0x1
(0282) 		State=DSM_STATE_SYNC_AB;
    0FE7: 55 8B 06 MOV   [State],0x6
(0283) 		}	
(0284) 	//set periode to be 11ms or 22ms	
(0285) 	DSM_Perriode=DSM_Is_11ms?DSM_TIME11MS:DSM_TIME22MS;
    0FEA: 3C 78 00 CMP   [config+5],0x0
    0FED: A0 09    JZ    0x0FF7
    0FEF: 56 01 1B MOV   [X+1],0x1B
    0FF2: 56 00 00 MOV   [X+0],0x0
    0FF5: 80 07    JMP   0x0FFD
    0FF7: 56 01 46 MOV   [X+1],0x46
    0FFA: 56 00 00 MOV   [X+0],0x0
    0FFD: 52 01    MOV   A,[X+1]
    0FFF: 53 8D    MOV   [DSM_Perriode+1],A
    1001: 52 00    MOV   A,[X+0]
    1003: 53 8C    MOV   [DSM_Perriode],A
(0286) 
(0287) 	//calculate channel CRC SOP and data code for first channel to transmitt
(0288) 	Timer_Stop();
    1005: 10       PUSH  X
    1006: 7C 04 87 LCALL _Timer8_1_Stop
    1009: 20       POP   X
(0289) 	if(DSM_Is_DSMX)
    100A: 3C 77 00 CMP   [config+4],0x0
    100D: A0 15    JZ    0x1023
(0290) 		{	
(0291) 			Timer_SetPeriod(DSM_FULL_SEQUENCE_TIME);
    100F: 10       PUSH  X
    1010: 50 55    MOV   A,0x55
    1012: 7C 04 8B LCALL _Timer8_1_WritePeriod
    1015: 20       POP   X
(0292) 			Timer_SetCallback(SYNC_X_TimeOut_cb);
    1016: 50 03    MOV   A,0x3
    1018: 08       PUSH  A
    1019: 50 28    MOV   A,0x28
    101B: 08       PUSH  A
    101C: 7C 1D 64 LCALL _Timer_SetCallback
    101F: 38 FE    ADD   SP,0xFE
(0293) 		}
    1021: 80 13    JMP   0x1035
(0294) 	else 
(0295) 		{
(0296) 			Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);
    1023: 10       PUSH  X
    1024: 50 56    MOV   A,0x56
    1026: 7C 04 8B LCALL _Timer8_1_WritePeriod
    1029: 20       POP   X
(0297) 			Timer_SetCallback(SYNC_AB_TimeOut_cb);
    102A: 50 03    MOV   A,0x3
    102C: 08       PUSH  A
    102D: 50 26    MOV   A,0x26
    102F: 08       PUSH  A
    1030: 7C 1D 64 LCALL _Timer_SetCallback
    1033: 38 FE    ADD   SP,0xFE
(0298) 		}
(0299) 	SetChannel();
    1035: 9C 6D    CALL  _SetChannel
(0300) 	Timer_Start();
    1037: 10       PUSH  X
    1038: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    103B: 20       POP   X
(0301) 	DSM_StartRcv();	
    103C: 95 A2    CALL  _DSM_StartRcv
    103E: 38 FE    ADD   SP,0xFE
    1040: 20       POP   X
    1041: 7F       RET   
(0302) }
(0303) 
(0304) void Process_Rvc_Irq(void)
(0305) {
_Process_Rvc_Irq:
  n                    --> X+0
    1042: 10       PUSH  X
    1043: 4F       MOV   X,SP
    1044: 38 01    ADD   SP,0x1
(0306) 	BYTE n;
(0307) 	if ((( DSM_Is_DSMX) && (rx_buf[0] !=  cyrfmfg_id[2] || rx_buf[1] !=  cyrfmfg_id[3]))
    1046: 3C 77 00 CMP   [config+4],0x0
    1049: A0 0D    JZ    0x1057
    104B: 51 30    MOV   A,[mem+16]
    104D: 3A 75    CMP   A,[config+2]
    104F: B0 22    JNZ   0x1072
    1051: 51 31    MOV   A,[mem+17]
    1053: 3A 76    CMP   A,[config+3]
    1055: B0 1C    JNZ   0x1072
    1057: 3C 77 00 CMP   [config+4],0x0
    105A: B0 19    JNZ   0x1074
    105C: 51 75    MOV   A,[config+2]
    105E: 73       CPL   A
    105F: 53 17    MOV   [__r0],A
    1061: 51 30    MOV   A,[mem+16]
    1063: 3A 17    CMP   A,[__r0]
    1065: B0 0C    JNZ   0x1072
    1067: 51 76    MOV   A,[config+3]
    1069: 73       CPL   A
    106A: 53 17    MOV   [__r0],A
    106C: 51 31    MOV   A,[mem+17]
    106E: 3A 17    CMP   A,[__r0]
    1070: A0 03    JZ    0x1074
(0308) 	  ||((!DSM_Is_DSMX) && (rx_buf[0] != ~cyrfmfg_id[2] || rx_buf[1] != ~cyrfmfg_id[3]))) 
(0309) 	{
(0310) 		goto Rvc_Error;
    1072: 80 77    JMP   0x10EA
(0311) 	}
(0312) #ifdef DEBUG
(0313) 	LED_1_4_Invert();
(0314) #endif
(0315) 	Timer_Stop();
    1074: 10       PUSH  X
    1075: 7C 04 87 LCALL _Timer8_1_Stop
    1078: 20       POP   X
(0316) 	if(Ch_A)
    1079: 3C 4C 00 CMP   [Ch_A],0x0
    107C: A0 0A    JZ    0x1087
(0317) 		{
(0318) 		Timer_SetPeriod(DSM_TIME_CHA_CHB+DSM_TIME_EXTRA);
    107E: 10       PUSH  X
    107F: 50 10    MOV   A,0x10
    1081: 7C 04 8B LCALL _Timer8_1_WritePeriod
    1084: 20       POP   X
(0319) 		}
    1085: 80 0A    JMP   0x1090
(0320) 	else
(0321) 		{
(0322) 		Timer_SetPeriod(DSM_Perriode+DSM_TIME_EXTRA);
    1087: 51 8D    MOV   A,[DSM_Perriode+1]
    1089: 01 01    ADD   A,0x1
    108B: 10       PUSH  X
    108C: 7C 04 8B LCALL _Timer8_1_WritePeriod
    108F: 20       POP   X
(0323) 		}
(0324) 
(0325) 	if (State==DSM_STATE_SYNC_AB)
    1090: 3C 8B 06 CMP   [State],0x6
    1093: B0 16    JNZ   0x10AA
(0326) 	{
(0327) 		if (chidx==1  && channels[0]!=channels[1])
    1095: 3C 4D 01 CMP   [chidx],0x1
    1098: B0 0A    JNZ   0x10A3
    109A: 51 4E    MOV   A,[channels]
    109C: 3A 4F    CMP   A,[channels+1]
    109E: A0 04    JZ    0x10A3
(0328) 		{
(0329) 			State =DSM_STATE_SYNC_X;
    10A0: 55 8B 0A MOV   [State],0xA
(0330) 		}
(0331) 	Timer_SetPeriod(DSM_SCAN_TIME+DSM_TIME_EXTRA);	
    10A3: 10       PUSH  X
    10A4: 50 56    MOV   A,0x56
    10A6: 7C 04 8B LCALL _Timer8_1_WritePeriod
    10A9: 20       POP   X
(0332) 	}
(0333) 
(0334) 	Timer_Start();
    10AA: 10       PUSH  X
    10AB: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    10AE: 20       POP   X
(0335) 
(0336) 	if (DSM_STATE_SYNC_X==State)
    10AF: 3C 8B 0A CMP   [State],0xA
    10B2: B0 0F    JNZ   0x10C2
(0337) 	{
(0338) 		State=DSM_STATE_LOCKED;
    10B4: 55 8B 0B MOV   [State],0xB
(0339) #ifdef DEBUG
(0340) 		LED_1_7_On(); 
(0341) #endif
(0342) 		Timer_SetCallback(Rcv_X_TimeOut_cb);
    10B7: 50 03    MOV   A,0x3
    10B9: 08       PUSH  A
    10BA: 50 24    MOV   A,0x24
    10BC: 08       PUSH  A
    10BD: 7C 1D 64 LCALL _Timer_SetCallback
    10C0: 38 FE    ADD   SP,0xFE
(0343) 	}
(0344) 
(0345) 	SetCH_INC();
    10C2: 9D 17    CALL  _SetCH_INC
(0346) 		
(0347) 	//process data
(0348) 	for (n=2;n<0x10;n++)
    10C4: 56 00 02 MOV   [X+0],0x2
    10C7: 80 17    JMP   0x10DF
(0349) 		rx_data[n]=rx_buf[n];
    10C9: 52 00    MOV   A,[X+0]
    10CB: 01 30    ADD   A,0x30
    10CD: 53 16    MOV   [__r1],A
    10CF: 3E 16    MVI   A,[__r1]
    10D1: 53 17    MOV   [__r0],A
    10D3: 52 00    MOV   A,[X+0]
    10D5: 01 20    ADD   A,0x20
    10D7: 53 14    MOV   [__r3],A
    10D9: 51 17    MOV   A,[__r0]
    10DB: 3F 14    MVI   [__r3],A
    10DD: 77 00    INC   [X+0]
    10DF: 3D 00 10 CMP   [X+0],0x10
    10E2: CF E6    JC    0x10C9
(0350) 	//rx_data[0]=DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01);
(0351) 	//rx_data[1]=0;
(0352) 	New_RCV_Data=TRUE;
    10E4: 55 47 01 MOV   [New_RCV_Data],0x1
(0353) 	lost_cnt=0;
    10E7: 55 48 00 MOV   [lost_cnt],0x0
(0354) 	
(0355) Rvc_Error:
(0356) 	DSM_StartRcv();
    10EA: 94 F4    CALL  _DSM_StartRcv
    10EC: 38 FF    ADD   SP,0xFF
    10EE: 20       POP   X
    10EF: 7F       RET   
(0357) }
(0358) 
(0359) 
(0360) 	
(0361) BOOL ProcessRxIrqStatus(void)
(0362) {
_ProcessRxIrqStatus:
  Est                  --> X+2
  rx_cnt               --> X+2
  Irq_Status           --> X+0
    10F0: 10       PUSH  X
    10F1: 4F       MOV   X,SP
    10F2: 38 03    ADD   SP,0x3
(0363) 		BYTE Irq_Status[2];
(0364) 		//read IRQ status
(0365) 		CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
    10F4: 50 02    MOV   A,0x2
    10F6: 08       PUSH  A
    10F7: 51 17    MOV   A,[__r0]
    10F9: 08       PUSH  A
    10FA: 10       PUSH  X
    10FB: 50 07    MOV   A,0x7
    10FD: 08       PUSH  A
    10FE: 7C 0B AD LCALL _CYRF_ReadRegisterMulti
    1101: 38 FC    ADD   SP,0xFC
(0366) 		Irq_Status[0]|=Irq_Status[1]&RXE_IRQ;
    1103: 52 01    MOV   A,[X+1]
    1105: 21 01    AND   A,0x1
    1107: 2D 00    OR    [X+0],A
(0367) 		if(Irq_Status[0]&RXC_IRQ)
    1109: 48 00 02 TST   [X+0],0x2
    110C: A0 23    JZ    0x1130
(0368) 		{
(0369) 			BYTE rx_cnt=CYRF_Rx_cnt();
    110E: 50 09    MOV   A,0x9
    1110: 08       PUSH  A
    1111: 7C 0B 95 LCALL _CYRF_ReadRegister
    1114: 54 02    MOV   [X+2],A
(0370) 			CYRF_ReadRx_data(rx_buf,rx_cnt);
    1116: 52 02    MOV   A,[X+2]
    1118: 08       PUSH  A
    1119: 50 00    MOV   A,0x0
    111B: 08       PUSH  A
    111C: 50 30    MOV   A,0x30
    111E: 08       PUSH  A
    111F: 50 21    MOV   A,0x21
    1121: 08       PUSH  A
    1122: 7C 0B AD LCALL _CYRF_ReadRegisterMulti
    1125: 38 FB    ADD   SP,0xFB
(0371) 			if(rx_cnt!=0x10)
    1127: 3D 02 10 CMP   [X+2],0x10
    112A: A0 05    JZ    0x1130
(0372) 			{
(0373) 				return FALSE;
    112C: 50 00    MOV   A,0x0
    112E: 80 16    JMP   0x1145
(0374) 			}
(0375) 		}
(0376) 		if (Irq_Status[0]&RXE_IRQ)
    1130: 48 00 01 TST   [X+0],0x1
    1133: A0 0F    JZ    0x1143
(0377) 		{
(0378) 			BYTE Est=CYRF_ReadRegister(CYRF_RX_STATUS);
    1135: 50 08    MOV   A,0x8
    1137: 08       PUSH  A
    1138: 7C 0B 95 LCALL _CYRF_ReadRegister
    113B: 38 FF    ADD   SP,0xFF
    113D: 54 02    MOV   [X+2],A
(0379) 			return FALSE;
    113F: 50 00    MOV   A,0x0
    1141: 80 03    JMP   0x1145
(0380) 		}
(0381) return TRUE;
    1143: 50 01    MOV   A,0x1
    1145: 38 FD    ADD   SP,0xFD
    1147: 20       POP   X
    1148: 7F       RET   
(0382) }
(0383) 
(0384) void ProcessNewData(void )
(0385) {
(0386) 		new_data= DSM_process_Data();
_ProcessNewData:
    1149: 96 DB    CALL  _DSM_process_Data
    114B: 53 8A    MOV   [new_data],A
    114D: 7F       RET   
(0387) }
(0388) 
(0389) 
(0390) void DSM_Cyclic(void)
(0391) {
_DSM_Cyclic:
  Irq_Status           --> X+2
    114E: 10       PUSH  X
    114F: 4F       MOV   X,SP
    1150: 38 06    ADD   SP,0x6
(0392) 	switch(State)
    1152: 51 8B    MOV   A,[State]
    1154: 54 01    MOV   [X+1],A
    1156: 56 00 00 MOV   [X+0],0x0
    1159: 3D 00 00 CMP   [X+0],0x0
    115C: B0 06    JNZ   0x1163
    115E: 3D 01 00 CMP   [X+1],0x0
    1161: A0 17    JZ    0x1179
    1163: 3D 00 00 CMP   [X+0],0x0
    1166: B0 06    JNZ   0x116D
    1168: 3D 01 03 CMP   [X+1],0x3
    116B: A0 1A    JZ    0x1186
    116D: 3D 00 00 CMP   [X+0],0x0
    1170: B0 06    JNZ   0x1177
    1172: 3D 01 05 CMP   [X+1],0x5
    1175: A0 0C    JZ    0x1182
    1177: 80 12    JMP   0x118A
(0393) 	{
(0394) 		case DSM_STATE_BIND:
(0395) 			{
(0396) 			DSM_ClearRxError();
    1179: 9C F0    CALL  _DSM_ClearRxError
(0397) 			DSM_StartRcv();
    117B: 94 63    CALL  _DSM_StartRcv
(0398) 			State=DSM_STATE_BIND_RCV;
    117D: 55 8B 01 MOV   [State],0x1
(0399) 			}
(0400) 		break;
    1180: 80 09    JMP   0x118A
(0401) 		case DSM_STATE_BIND_DONE:
(0402) 			{
(0403) 				DSM_initialize_Recive();
    1182: 9E 18    CALL  _DSM_initialize_Recive
(0404) 			}
(0405) 		break;
    1184: 80 05    JMP   0x118A
(0406) 		case DSM_STATE_BIND_RCV_START_ACK:
(0407) 			{
(0408) 			DSM_initialize_bind_ack();
    1186: 94 C5    CALL  _DSM_initialize_bind_ack
(0409) 			DSM_StartBindAck();
    1188: 94 68    CALL  _DSM_StartBindAck
(0410) 			}
(0411) 	}
(0412) 
(0413) 	//process interrupt
(0414) 	if(CY_irq) //we got an IRQ from CYRF6936
    118A: 3C 40 00 CMP   [CY_irq],0x0
    118D: A0 AC    JZ    0x123A
(0415) 	{
(0416) 		BYTE Irq_Status[2];
(0417) 		CY_irq=FALSE;
    118F: 55 40 00 MOV   [CY_irq],0x0
(0418) 		switch(State)
    1192: 51 8B    MOV   A,[State]
    1194: 54 05    MOV   [X+5],A
    1196: 56 04 00 MOV   [X+4],0x0
    1199: 3D 04 00 CMP   [X+4],0x0
    119C: B0 06    JNZ   0x11A3
    119E: 3D 05 01 CMP   [X+5],0x1
    11A1: A0 58    JZ    0x11FA
    11A3: 3D 04 00 CMP   [X+4],0x0
    11A6: B0 06    JNZ   0x11AD
    11A8: 3D 05 02 CMP   [X+5],0x2
    11AB: A0 4E    JZ    0x11FA
    11AD: 3D 04 00 CMP   [X+4],0x0
    11B0: B0 06    JNZ   0x11B7
    11B2: 3D 05 04 CMP   [X+5],0x4
    11B5: A0 21    JZ    0x11D7
    11B7: 3D 04 00 CMP   [X+4],0x0
    11BA: B0 06    JNZ   0x11C1
    11BC: 3D 05 06 CMP   [X+5],0x6
    11BF: A0 44    JZ    0x1204
    11C1: 3D 04 00 CMP   [X+4],0x0
    11C4: B0 06    JNZ   0x11CB
    11C6: 3D 05 0A CMP   [X+5],0xA
    11C9: A0 3A    JZ    0x1204
    11CB: 3D 04 00 CMP   [X+4],0x0
    11CE: B0 06    JNZ   0x11D5
    11D0: 3D 05 0B CMP   [X+5],0xB
    11D3: A0 30    JZ    0x1204
    11D5: 80 38    JMP   0x120E
(0419) 		{
(0420) 			case DSM_STATE_BIND_ACK:
(0421) 				{
(0422) 				//read IRQ status
(0423) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    11D7: 50 02    MOV   A,0x2
    11D9: 08       PUSH  A
    11DA: 5A 16    MOV   [__r1],X
    11DC: 06 16 02 ADD   [__r1],0x2
    11DF: 51 17    MOV   A,[__r0]
    11E1: 08       PUSH  A
    11E2: 51 16    MOV   A,[__r1]
    11E4: 08       PUSH  A
    11E5: 50 04    MOV   A,0x4
    11E7: 08       PUSH  A
    11E8: 7C 0B AD LCALL _CYRF_ReadRegisterMulti
    11EB: 38 FC    ADD   SP,0xFC
(0424) 				Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
    11ED: 52 03    MOV   A,[X+3]
    11EF: 21 01    AND   A,0x1
    11F1: 2D 02    OR    [X+2],A
(0425) 				//TX done
(0426) 				if(Irq_Status[0]&TXC_IRQ)
    11F3: 48 02 02 TST   [X+2],0x2
    11F6: A0 55    JZ    0x124C
(0427) 					{
(0428) 					}
(0429) 				}
(0430) 				break;
    11F8: 80 53    JMP   0x124C
(0431) 			case DSM_STATE_BIND_RCV:
(0432) 			case DSM_STATE_BIND_RCV_WAIT:
(0433) 				{
(0434) 					
(0435) 					if (ProcessRxIrqStatus())
    11FA: 9E F4    CALL  _ProcessRxIrqStatus
    11FC: 39 00    CMP   A,0x0
    11FE: A0 4D    JZ    0x124C
(0436) 						{
(0437) 						//we got some thing
(0438) 						Process_BindRcvIrq();	
    1200: 94 A6    CALL  _Process_BindRcvIrq
(0439) 						}
(0440) 				}
(0441) 				break;
    1202: 80 49    JMP   0x124C
(0442) 			case DSM_STATE_SYNC_AB:
(0443) 			case DSM_STATE_SYNC_X:
(0444) 			case DSM_STATE_LOCKED:	
(0445) 				{
(0446) 					if(ProcessRxIrqStatus())
    1204: 9E EA    CALL  _ProcessRxIrqStatus
    1206: 39 00    CMP   A,0x0
    1208: A0 43    JZ    0x124C
(0447) 						{
(0448) 						//we got some thing
(0449) 						Process_Rvc_Irq();
    120A: 9E 36    CALL  _Process_Rvc_Irq
(0450) 						}
(0451) 				}
(0452) 				break;
    120C: 80 3F    JMP   0x124C
(0453) 			default :
(0454) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    120E: 50 02    MOV   A,0x2
    1210: 08       PUSH  A
    1211: 5A 16    MOV   [__r1],X
    1213: 06 16 02 ADD   [__r1],0x2
    1216: 51 17    MOV   A,[__r0]
    1218: 08       PUSH  A
    1219: 51 16    MOV   A,[__r1]
    121B: 08       PUSH  A
    121C: 50 04    MOV   A,0x4
    121E: 08       PUSH  A
    121F: 7C 0B AD LCALL _CYRF_ReadRegisterMulti
(0455) 				CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
    1222: 50 02    MOV   A,0x2
    1224: 08       PUSH  A
    1225: 5A 16    MOV   [__r1],X
    1227: 06 16 02 ADD   [__r1],0x2
    122A: 51 17    MOV   A,[__r0]
    122C: 08       PUSH  A
    122D: 51 16    MOV   A,[__r1]
    122F: 08       PUSH  A
    1230: 50 07    MOV   A,0x7
    1232: 08       PUSH  A
    1233: 7C 0B AD LCALL _CYRF_ReadRegisterMulti
    1236: 38 F8    ADD   SP,0xF8
(0456) 		}
(0457) 	}
    1238: 80 13    JMP   0x124C
(0458) 	else //no IRQ to process
(0459) 	{
(0460) 		if (New_RCV_Data&& Ch_A)
    123A: 3C 47 00 CMP   [New_RCV_Data],0x0
    123D: A0 0E    JZ    0x124C
    123F: 3C 4C 00 CMP   [Ch_A],0x0
    1242: A0 09    JZ    0x124C
(0461) 		{
(0462) 			New_RCV_Data=FALSE;
    1244: 55 47 00 MOV   [New_RCV_Data],0x0
(0463) 			Rcv_Timeout=FALSE;
    1247: 55 89 00 MOV   [Rcv_Timeout],0x0
(0464) 			ProcessNewData();
    124A: 9E FD    CALL  _ProcessNewData
(0465) 		}
(0466) 	}
    124C: 38 FA    ADD   SP,0xFA
    124E: 20       POP   X
    124F: 7F       RET   
(0467) }
(0468) 
(0469) 
(0470) //calculate dsmX channels 
(0471) //found on deviation-tx source
(0472) // math by Alexandr Alexandrov code by Sergey Gimaev
(0473) //pseudo random gennerator /Linear congruential generator based on "Numerical Recipes" Chapter 7.1
(0474) void calc_dsmx_channel(void)
(0475) {
_calc_dsmx_channel:
  count_52_76          --> X+20
  count_28_51          --> X+18
  count_3_27           --> X+16
  next_ch              --> X+15
  i                    --> X+13
  id                   --> X+5
  id_tmp               --> X+1
  idx                  --> X+0
    1250: 10       PUSH  X
    1251: 4F       MOV   X,SP
    1252: 38 16    ADD   SP,0x16
(0476)     BYTE idx; 
(0477) 	DWORD id_tmp;
(0478)     DWORD id = ~(((DWORD)cyrfmfg_id[0] << 24) | ((DWORD)cyrfmfg_id[1] << 16) | ((DWORD)cyrfmfg_id[2] << 8) | (((DWORD)cyrfmfg_id[3]) << 0));
    1254: 5F 14 76 MOV   [__r3],[config+3]
    1257: 56 09 00 MOV   [X+9],0x0
    125A: 56 0A 00 MOV   [X+10],0x0
    125D: 56 0B 00 MOV   [X+11],0x0
    1260: 51 14    MOV   A,[__r3]
    1262: 54 0C    MOV   [X+12],A
    1264: 5F 10 75 MOV   [__r7],[config+2]
    1267: 55 11 00 MOV   [__r6],0x0
    126A: 55 12 00 MOV   [__r5],0x0
    126D: 55 13 00 MOV   [__r4],0x0
    1270: 50 08    MOV   A,0x8
    1272: 65 10    ASL   [__r7]
    1274: 6B 11    RLC   [__r6]
    1276: 6B 12    RLC   [__r5]
    1278: 6B 13    RLC   [__r4]
    127A: 78       DEC   A
    127B: BF F6    JNZ   0x1272
    127D: 5F 0C 74 MOV   [__r11],[config+1]
    1280: 55 0D 00 MOV   [__r10],0x0
    1283: 55 0E 00 MOV   [__r9],0x0
    1286: 55 0F 00 MOV   [__r8],0x0
    1289: 50 10    MOV   A,0x10
    128B: 65 0C    ASL   [__r11]
    128D: 6B 0D    RLC   [__r10]
    128F: 6B 0E    RLC   [__r9]
    1291: 6B 0F    RLC   [__r8]
    1293: 78       DEC   A
    1294: BF F6    JNZ   0x128B
    1296: 5F 14 73 MOV   [__r3],[config]
    1299: 55 15 00 MOV   [__r2],0x0
    129C: 55 16 00 MOV   [__r1],0x0
    129F: 55 17 00 MOV   [__r0],0x0
    12A2: 50 18    MOV   A,0x18
    12A4: 65 14    ASL   [__r3]
    12A6: 6B 15    RLC   [__r2]
    12A8: 6B 16    RLC   [__r1]
    12AA: 6B 17    RLC   [__r0]
    12AC: 78       DEC   A
    12AD: BF F6    JNZ   0x12A4
    12AF: 51 0C    MOV   A,[__r11]
    12B1: 2C 14    OR    [__r3],A
    12B3: 51 0D    MOV   A,[__r10]
    12B5: 2C 15    OR    [__r2],A
    12B7: 51 0E    MOV   A,[__r9]
    12B9: 2C 16    OR    [__r1],A
    12BB: 51 0F    MOV   A,[__r8]
    12BD: 2C 17    OR    [__r0],A
    12BF: 51 10    MOV   A,[__r7]
    12C1: 2C 14    OR    [__r3],A
    12C3: 51 11    MOV   A,[__r6]
    12C5: 2C 15    OR    [__r2],A
    12C7: 51 12    MOV   A,[__r5]
    12C9: 2C 16    OR    [__r1],A
    12CB: 51 13    MOV   A,[__r4]
    12CD: 2C 17    OR    [__r0],A
    12CF: 52 0C    MOV   A,[X+12]
    12D1: 2C 14    OR    [__r3],A
    12D3: 52 0B    MOV   A,[X+11]
    12D5: 2C 15    OR    [__r2],A
    12D7: 52 0A    MOV   A,[X+10]
    12D9: 2C 16    OR    [__r1],A
    12DB: 52 09    MOV   A,[X+9]
    12DD: 2C 17    OR    [__r0],A
    12DF: 51 17    MOV   A,[__r0]
    12E1: 73       CPL   A
    12E2: 54 05    MOV   [X+5],A
    12E4: 51 16    MOV   A,[__r1]
    12E6: 73       CPL   A
    12E7: 54 06    MOV   [X+6],A
    12E9: 51 15    MOV   A,[__r2]
    12EB: 73       CPL   A
    12EC: 54 07    MOV   [X+7],A
    12EE: 51 14    MOV   A,[__r3]
    12F0: 73       CPL   A
    12F1: 54 08    MOV   [X+8],A
(0479) 	idx = 0;
    12F3: 56 00 00 MOV   [X+0],0x0
(0480)     id_tmp = id;
    12F6: 52 05    MOV   A,[X+5]
    12F8: 54 01    MOV   [X+1],A
    12FA: 52 06    MOV   A,[X+6]
    12FC: 54 02    MOV   [X+2],A
    12FE: 52 07    MOV   A,[X+7]
    1300: 54 03    MOV   [X+3],A
    1302: 52 08    MOV   A,[X+8]
    1304: 54 04    MOV   [X+4],A
    1306: 81 9B    JMP   0x14A2
(0481)     while(idx < 23) {
(0482)         int i;
(0483)         BYTE next_ch;
(0484) 		int count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;
    1308: 56 11 00 MOV   [X+17],0x0
    130B: 56 10 00 MOV   [X+16],0x0
    130E: 56 13 00 MOV   [X+19],0x0
    1311: 56 12 00 MOV   [X+18],0x0
    1314: 56 15 00 MOV   [X+21],0x0
    1317: 56 14 00 MOV   [X+20],0x0
(0485)         id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F; // Randomization
    131A: 52 01    MOV   A,[X+1]
    131C: 08       PUSH  A
    131D: 52 02    MOV   A,[X+2]
    131F: 08       PUSH  A
    1320: 52 03    MOV   A,[X+3]
    1322: 08       PUSH  A
    1323: 52 04    MOV   A,[X+4]
    1325: 08       PUSH  A
    1326: 50 00    MOV   A,0x0
    1328: 08       PUSH  A
    1329: 50 19    MOV   A,0x19
    132B: 08       PUSH  A
    132C: 50 66    MOV   A,0x66
    132E: 08       PUSH  A
    132F: 50 0D    MOV   A,0xD
    1331: 08       PUSH  A
    1332: 7C 1F 21 LCALL 0x1F21
    1335: 38 FC    ADD   SP,0xFC
    1337: 18       POP   A
    1338: 53 14    MOV   [__r3],A
    133A: 18       POP   A
    133B: 53 15    MOV   [__r2],A
    133D: 18       POP   A
    133E: 53 16    MOV   [__r1],A
    1340: 18       POP   A
    1341: 53 17    MOV   [__r0],A
    1343: 51 14    MOV   A,[__r3]
    1345: 01 5F    ADD   A,0x5F
    1347: 54 04    MOV   [X+4],A
    1349: 51 15    MOV   A,[__r2]
    134B: 09 F3    ADC   A,0xF3
    134D: 54 03    MOV   [X+3],A
    134F: 51 16    MOV   A,[__r1]
    1351: 09 6E    ADC   A,0x6E
    1353: 54 02    MOV   [X+2],A
    1355: 51 17    MOV   A,[__r0]
    1357: 09 3C    ADC   A,0x3C
    1359: 54 01    MOV   [X+1],A
(0486)         next_ch = ((id_tmp >> 8) % 0x49) + 3;       // Use least-significant byte and must be larger than 3
    135B: 52 01    MOV   A,[X+1]
    135D: 53 17    MOV   [__r0],A
    135F: 52 02    MOV   A,[X+2]
    1361: 53 16    MOV   [__r1],A
    1363: 52 03    MOV   A,[X+3]
    1365: 53 15    MOV   [__r2],A
    1367: 52 04    MOV   A,[X+4]
    1369: 53 14    MOV   [__r3],A
    136B: 50 08    MOV   A,0x8
    136D: 70 FB    AND   F,0xFB
    136F: 6E 17    RRC   [__r0]
    1371: 6E 16    RRC   [__r1]
    1373: 6E 15    RRC   [__r2]
    1375: 6E 14    RRC   [__r3]
    1377: 78       DEC   A
    1378: BF F4    JNZ   0x136D
    137A: 50 00    MOV   A,0x0
    137C: 08       PUSH  A
    137D: 08       PUSH  A
    137E: 08       PUSH  A
    137F: 50 49    MOV   A,0x49
    1381: 08       PUSH  A
    1382: 51 17    MOV   A,[__r0]
    1384: 08       PUSH  A
    1385: 51 16    MOV   A,[__r1]
    1387: 08       PUSH  A
    1388: 51 15    MOV   A,[__r2]
    138A: 08       PUSH  A
    138B: 51 14    MOV   A,[__r3]
    138D: 08       PUSH  A
    138E: 7C 1E 45 LCALL 0x1E45
    1391: 38 FC    ADD   SP,0xFC
    1393: 18       POP   A
    1394: 53 14    MOV   [__r3],A
    1396: 18       POP   A
    1397: 18       POP   A
    1398: 18       POP   A
    1399: 06 14 03 ADD   [__r3],0x3
    139C: 51 14    MOV   A,[__r3]
    139E: 54 0F    MOV   [X+15],A
(0487)         if (((next_ch ^ id) & 0x01 )== 0)
    13A0: 52 0F    MOV   A,[X+15]
    13A2: 53 14    MOV   [__r3],A
    13A4: 55 15 00 MOV   [__r2],0x0
    13A7: 55 16 00 MOV   [__r1],0x0
    13AA: 55 17 00 MOV   [__r0],0x0
    13AD: 52 08    MOV   A,[X+8]
    13AF: 34 14    XOR   [__r3],A
    13B1: 52 07    MOV   A,[X+7]
    13B3: 34 15    XOR   [__r2],A
    13B5: 52 06    MOV   A,[X+6]
    13B7: 34 16    XOR   [__r1],A
    13B9: 52 05    MOV   A,[X+5]
    13BB: 34 17    XOR   [__r0],A
    13BD: 26 14 01 AND   [__r3],0x1
    13C0: 26 15 00 AND   [__r2],0x0
    13C3: 26 16 00 AND   [__r1],0x0
    13C6: 26 17 00 AND   [__r0],0x0
    13C9: B0 12    JNZ   0x13DC
    13CB: 3C 16 00 CMP   [__r1],0x0
    13CE: B0 0D    JNZ   0x13DC
    13D0: 3C 15 00 CMP   [__r2],0x0
    13D3: B0 08    JNZ   0x13DC
    13D5: 3C 14 00 CMP   [__r3],0x0
    13D8: B0 03    JNZ   0x13DC
(0488)             continue;
    13DA: 80 C7    JMP   0x14A2
(0489)         for (i = 0; i < idx; i++) {
    13DC: 56 0E 00 MOV   [X+14],0x0
    13DF: 56 0D 00 MOV   [X+13],0x0
    13E2: 80 47    JMP   0x142A
(0490)             if(channels[i] == next_ch)
    13E4: 52 0E    MOV   A,[X+14]
    13E6: 01 4E    ADD   A,0x4E
    13E8: 53 16    MOV   [__r1],A
    13EA: 3E 16    MVI   A,[__r1]
    13EC: 3B 0F    CMP   A,[X+15]
    13EE: B0 03    JNZ   0x13F2
(0491)                 break;
    13F0: 80 4F    JMP   0x1440
(0492)             if(channels[i] <= 27)
    13F2: 52 0E    MOV   A,[X+14]
    13F4: 01 4E    ADD   A,0x4E
    13F6: 53 16    MOV   [__r1],A
    13F8: 3E 16    MVI   A,[__r1]
    13FA: 53 17    MOV   [__r0],A
    13FC: 50 1B    MOV   A,0x1B
    13FE: 3A 17    CMP   A,[__r0]
    1400: C0 08    JC    0x1409
(0493)                 count_3_27++;
    1402: 77 11    INC   [X+17]
    1404: 0F 10 00 ADC   [X+16],0x0
    1407: 80 1D    JMP   0x1425
(0494)             else if (channels[i] <= 51)
    1409: 52 0E    MOV   A,[X+14]
    140B: 01 4E    ADD   A,0x4E
    140D: 53 16    MOV   [__r1],A
    140F: 3E 16    MVI   A,[__r1]
    1411: 53 17    MOV   [__r0],A
    1413: 50 33    MOV   A,0x33
    1415: 3A 17    CMP   A,[__r0]
    1417: C0 08    JC    0x1420
(0495)                 count_28_51++;
    1419: 77 13    INC   [X+19]
    141B: 0F 12 00 ADC   [X+18],0x0
    141E: 80 06    JMP   0x1425
(0496)             else
(0497)                 count_52_76++;
    1420: 77 15    INC   [X+21]
    1422: 0F 14 00 ADC   [X+20],0x0
(0498)         }
    1425: 77 0E    INC   [X+14]
    1427: 0F 0D 00 ADC   [X+13],0x0
    142A: 52 00    MOV   A,[X+0]
    142C: 53 16    MOV   [__r1],A
    142E: 52 0E    MOV   A,[X+14]
    1430: 12 16    SUB   A,[__r1]
    1432: 50 00    MOV   A,0x0
    1434: 31 80    XOR   A,0x80
    1436: 53 0B    MOV   [__rX],A
    1438: 52 0D    MOV   A,[X+13]
    143A: 31 80    XOR   A,0x80
    143C: 1A 0B    SBB   A,[__rX]
    143E: CF A5    JC    0x13E4
(0499)         if (i != idx)
    1440: 52 00    MOV   A,[X+0]
    1442: 53 16    MOV   [__r1],A
    1444: 55 17 00 MOV   [__r0],0x0
    1447: 52 0D    MOV   A,[X+13]
    1449: 3A 17    CMP   A,[__r0]
    144B: B0 07    JNZ   0x1453
    144D: 52 0E    MOV   A,[X+14]
    144F: 3A 16    CMP   A,[__r1]
    1451: A0 03    JZ    0x1455
(0500)             continue;
    1453: 80 4E    JMP   0x14A2
(0501)         if ((next_ch < 28 && count_3_27 < 8)
    1455: 3D 0F 1C CMP   [X+15],0x1C
    1458: D0 0D    JNC   0x1466
    145A: 52 11    MOV   A,[X+17]
    145C: 11 08    SUB   A,0x8
    145E: 52 10    MOV   A,[X+16]
    1460: 31 80    XOR   A,0x80
    1462: 19 80    SBB   A,0x80
    1464: C0 28    JC    0x148D
    1466: 3D 0F 1C CMP   [X+15],0x1C
    1469: C0 12    JC    0x147C
    146B: 3D 0F 34 CMP   [X+15],0x34
    146E: D0 0D    JNC   0x147C
    1470: 52 13    MOV   A,[X+19]
    1472: 11 07    SUB   A,0x7
    1474: 52 12    MOV   A,[X+18]
    1476: 31 80    XOR   A,0x80
    1478: 19 80    SBB   A,0x80
    147A: C0 12    JC    0x148D
    147C: 3D 0F 34 CMP   [X+15],0x34
    147F: C0 22    JC    0x14A2
    1481: 52 15    MOV   A,[X+21]
    1483: 11 08    SUB   A,0x8
    1485: 52 14    MOV   A,[X+20]
    1487: 31 80    XOR   A,0x80
    1489: 19 80    SBB   A,0x80
    148B: D0 16    JNC   0x14A2
(0502)           ||(next_ch >= 28 && next_ch < 52 && count_28_51 < 7)
(0503)           ||(next_ch >= 52 && count_52_76 < 8))
(0504)         {
(0505)             channels[idx++] = next_ch;
    148D: 52 00    MOV   A,[X+0]
    148F: 53 16    MOV   [__r1],A
    1491: 55 17 00 MOV   [__r0],0x0
    1494: 01 01    ADD   A,0x1
    1496: 54 00    MOV   [X+0],A
    1498: 06 16 4E ADD   [__r1],0x4E
    149B: 0E 17 00 ADC   [__r0],0x0
    149E: 52 0F    MOV   A,[X+15]
    14A0: 3F 16    MVI   [__r1],A
(0506)         }
(0507)     }
    14A2: 3D 00 17 CMP   [X+0],0x17
    14A5: CE 62    JC    0x1308
    14A7: 38 EA    ADD   SP,0xEA
    14A9: 20       POP   X
    14AA: 7F       RET   
(0508) }
(0509) 
(0510) 
(0511) //initialise system
(0512) void DSM_Init(void)
(0513) {
_DSM_Init:
  n                    --> X+0
    14AB: 10       PUSH  X
    14AC: 4F       MOV   X,SP
    14AD: 38 01    ADD   SP,0x1
(0514) 	BYTE n;
(0515) 	new_data=FALSE;
    14AF: 55 8A 00 MOV   [new_data],0x0
(0516) 	//init CYRF6936
(0517) 	CYRF_Init();
    14B2: 7C 0A 68 LCALL _CYRF_Init
(0518) 	//set defalut values
(0519) 	DSM_Is_DSMX=FALSE;
    14B5: 55 77 00 MOV   [config+4],0x0
(0520) 	DSM_Is_11ms=FALSE;
    14B8: 55 78 00 MOV   [config+5],0x0
(0521) 	DSM_Is_11Bit=FALSE;
    14BB: 55 79 00 MOV   [config+6],0x0
(0522) 	Ch_A=TRUE;
    14BE: 55 4C 01 MOV   [Ch_A],0x1
(0523) 	chidx=0;
    14C1: 55 4D 00 MOV   [chidx],0x0
(0524) 	Preste_Failsafe=FALSE;
    14C4: 55 7A 00 MOV   [config+7],0x0
(0525) 	DSM_Load_Config(init_vals,sizeof(init_vals)/(sizeof(BYTE)*2));
    14C7: 50 10    MOV   A,0x10
    14C9: 08       PUSH  A
    14CA: 50 02    MOV   A,0x2
    14CC: 08       PUSH  A
    14CD: 50 E0    MOV   A,0xE0
    14CF: 08       PUSH  A
    14D0: 99 5C    CALL  _DSM_Load_Config
(0526) 
(0527) 	CYRF_WritePreamble(preamble);
    14D2: 50 03    MOV   A,0x3
    14D4: 08       PUSH  A
    14D5: 50 03    MOV   A,0x3
    14D7: 08       PUSH  A
    14D8: 50 08    MOV   A,0x8
    14DA: 08       PUSH  A
    14DB: 50 24    MOV   A,0x24
    14DD: 08       PUSH  A
    14DE: 7C 0A BF LCALL _CYRF_WriteRegisterMulti
    14E1: 38 F9    ADD   SP,0xF9
    14E3: 38 FF    ADD   SP,0xFF
    14E5: 20       POP   X
    14E6: 7F       RET   
(0528) }
(0529) 
(0530) /*++++++++++BIND STUFF****************/
(0531) static const BYTE bind_vals[][2] = {
(0532)     {CYRF_TX_CFG,TX_DC_LEN|TX_DM(TX_DM_SDR)|DSM_BIND_POWER}, //0x38 Set 64 chip, SDR mode
(0533)     {CYRF_FRAMING_CFG,SOP_LEN|0xA}, //0x4A set sop len  32 chip and threshold =0xA 
(0534)     {CYRF_TX_OVERRIDE, DIS_TXCRC}, //0x4 disable tx CRC
(0535)     {CYRF_RX_OVERRIDE, DIS_RXCRC}, //0x4 disable rx CRC
(0536)     {CYRF_EOP_CTRL, 0x02}, //set EOP sync == 2
(0537) };
(0538) BYTE Bind_cnt;		//bind ack pulse counter
(0539) BYTE bind_channal;	//channel used to send bind packes
(0540) 
(0541) 
(0542) //initialize bind state
(0543) void DSM_initialize_bind(void)
(0544) {	
(0545) 	State=DSM_STATE_BIND;
_DSM_initialize_bind:
    14E7: 55 8B 00 MOV   [State],0x0
(0546) 	DSM_Load_Config(bind_vals,sizeof(bind_vals)/(sizeof(BYTE)*2));
    14EA: 50 05    MOV   A,0x5
    14EC: 08       PUSH  A
    14ED: 50 03    MOV   A,0x3
    14EF: 08       PUSH  A
    14F0: 50 0B    MOV   A,0xB
    14F2: 08       PUSH  A
    14F3: 99 39    CALL  _DSM_Load_Config
    14F5: 38 FD    ADD   SP,0xFD
(0547) 	bind_channal=1;
    14F7: 55 45 01 MOV   [bind_channal],0x1
(0548) 	Bind_cnt=0;
    14FA: 55 46 00 MOV   [Bind_cnt],0x0
(0549) 	CYRF_SetRFChannel(bind_channal);
    14FD: 51 45    MOV   A,[bind_channal]
    14FF: 08       PUSH  A
    1500: 50 00    MOV   A,0x0
    1502: 08       PUSH  A
    1503: 7C 0A A6 LCALL _CYRF_WriteRegister
(0550) 	CYRF_SetDataCode(pncodes[0][8], 16);
    1506: 50 10    MOV   A,0x10
    1508: 08       PUSH  A
    1509: 50 01    MOV   A,0x1
    150B: 08       PUSH  A
    150C: 50 B8    MOV   A,0xB8
    150E: 08       PUSH  A
    150F: 50 23    MOV   A,0x23
    1511: 08       PUSH  A
    1512: 7C 0A BF LCALL _CYRF_WriteRegisterMulti
    1515: 38 FA    ADD   SP,0xFA
(0551) 	Timer_SetPeriod(DSM_TIME_BIND_RCV);
    1517: 10       PUSH  X
    1518: 50 2E    MOV   A,0x2E
    151A: 7C 04 8B LCALL _Timer8_1_WritePeriod
    151D: 20       POP   X
(0552) 	Timer_SetCallback(Bind_TimeOut_cb);
    151E: 50 03    MOV   A,0x3
    1520: 08       PUSH  A
    1521: 50 22    MOV   A,0x22
    1523: 08       PUSH  A
    1524: 7C 1D 64 LCALL _Timer_SetCallback
    1527: 38 FE    ADD   SP,0xFE
(0553) 	Timer_Start();
    1529: 10       PUSH  X
    152A: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    152D: 20       POP   X
    152E: 7F       RET   
(0554) }
(0555) 
(0556) 
(0557) void DSM_Build_Ack_package(void)
(0558) {
_DSM_Build_Ack_package:
  ckSum                --> X+1
  i                    --> X+0
    152F: 10       PUSH  X
    1530: 4F       MOV   X,SP
    1531: 38 0D    ADD   SP,0xD
(0559) 	BYTE i;
(0560)     WORD ckSum = 0x170;
    1533: 56 02 70 MOV   [X+2],0x70
    1536: 56 01 01 MOV   [X+1],0x1
(0561) 	tx_buf[0]=rx_buf[0];
    1539: 5F 20 30 MOV   [mem],[mem+16]
(0562) 	tx_buf[1]=rx_buf[1];
    153C: 5F 21 31 MOV   [mem+1],[mem+17]
(0563) 	tx_buf[2]=rx_buf[2];
    153F: 5F 22 32 MOV   [mem+2],[mem+18]
(0564) 	tx_buf[3]=rx_buf[3];
    1542: 5F 23 33 MOV   [mem+3],[mem+19]
(0565)     tx_buf[4]=rx_buf[10];
    1545: 5F 24 3A MOV   [mem+4],[mem+26]
(0566)     tx_buf[5]=num_channels;
    1548: 5F 25 49 MOV   [mem+5],[num_channels]
(0567)     tx_buf[6]=DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01); //rx_buf[12]; //protocoll
    154B: 3C 77 00 CMP   [config+4],0x0
    154E: A0 1E    JZ    0x156D
    1550: 3C 78 00 CMP   [config+5],0x0
    1553: A0 09    JZ    0x155D
    1555: 56 06 B2 MOV   [X+6],0xB2
    1558: 56 05 00 MOV   [X+5],0x0
    155B: 80 07    JMP   0x1563
    155D: 56 06 A2 MOV   [X+6],0xA2
    1560: 56 05 00 MOV   [X+5],0x0
    1563: 52 06    MOV   A,[X+6]
    1565: 54 04    MOV   [X+4],A
    1567: 52 05    MOV   A,[X+5]
    1569: 54 03    MOV   [X+3],A
    156B: 80 46    JMP   0x15B2
    156D: 3C 79 00 CMP   [config+6],0x0
    1570: A0 1E    JZ    0x158F
    1572: 3C 78 00 CMP   [config+5],0x0
    1575: A0 09    JZ    0x157F
    1577: 56 0A 12 MOV   [X+10],0x12
    157A: 56 09 00 MOV   [X+9],0x0
    157D: 80 07    JMP   0x1585
    157F: 56 0A 11 MOV   [X+10],0x11
    1582: 56 09 00 MOV   [X+9],0x0
    1585: 52 0A    MOV   A,[X+10]
    1587: 54 08    MOV   [X+8],A
    1589: 52 09    MOV   A,[X+9]
    158B: 54 07    MOV   [X+7],A
    158D: 80 1C    JMP   0x15AA
    158F: 3C 78 00 CMP   [config+5],0x0
    1592: A0 09    JZ    0x159C
    1594: 56 0C 02 MOV   [X+12],0x2
    1597: 56 0B 00 MOV   [X+11],0x0
    159A: 80 07    JMP   0x15A2
    159C: 56 0C 01 MOV   [X+12],0x1
    159F: 56 0B 00 MOV   [X+11],0x0
    15A2: 52 0C    MOV   A,[X+12]
    15A4: 54 08    MOV   [X+8],A
    15A6: 52 0B    MOV   A,[X+11]
    15A8: 54 07    MOV   [X+7],A
    15AA: 52 08    MOV   A,[X+8]
    15AC: 54 04    MOV   [X+4],A
    15AE: 52 07    MOV   A,[X+7]
    15B0: 54 03    MOV   [X+3],A
    15B2: 52 04    MOV   A,[X+4]
    15B4: 53 26    MOV   [mem+6],A
(0568)     tx_buf[7]=rx_buf[13];//???
    15B6: 5F 27 3D MOV   [mem+7],[mem+29]
(0569) 
(0570) 	for (i = 0; i < 8; i++)
    15B9: 56 00 00 MOV   [X+0],0x0
    15BC: 80 12    JMP   0x15CF
(0571)          ckSum += tx_buf[i];
    15BE: 52 00    MOV   A,[X+0]
    15C0: 01 20    ADD   A,0x20
    15C2: 53 16    MOV   [__r1],A
    15C4: 3E 16    MVI   A,[__r1]
    15C6: 05 02    ADD   [X+2],A
    15C8: 50 00    MOV   A,0x0
    15CA: 0F 01 00 ADC   [X+1],0x0
    15CD: 77 00    INC   [X+0]
    15CF: 3D 00 08 CMP   [X+0],0x8
    15D2: CF EB    JC    0x15BE
(0572) 	tx_buf[8]=(ckSum >> 8);
    15D4: 52 01    MOV   A,[X+1]
    15D6: 53 28    MOV   [mem+8],A
(0573) 	tx_buf[9]=(ckSum & 0xff);
    15D8: 52 02    MOV   A,[X+2]
    15DA: 53 29    MOV   [mem+9],A
    15DC: 38 F3    ADD   SP,0xF3
    15DE: 20       POP   X
    15DF: 7F       RET   
(0574) }
(0575) 
(0576) 
(0577) //start waiting for the bind recive signal
(0578) void DSM_StartRcv(void)
(0579) {
(0580) 		CYRF_StartReceive();
_DSM_StartRcv:
    15E0: 50 83    MOV   A,0x83
    15E2: 08       PUSH  A
    15E3: 50 05    MOV   A,0x5
    15E5: 08       PUSH  A
    15E6: 7C 0A A6 LCALL _CYRF_WriteRegister
(0581) 		CYRF_ReadRSSI();
    15E9: 50 13    MOV   A,0x13
    15EB: 08       PUSH  A
    15EC: 7C 0B 95 LCALL _CYRF_ReadRegister
    15EF: 38 FD    ADD   SP,0xFD
    15F1: 7F       RET   
(0582) }
(0583) 
(0584) void DSM_StartBindAck(void)
(0585) {
(0586) 	CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
_DSM_StartBindAck:
    15F2: 50 02    MOV   A,0x2
    15F4: 08       PUSH  A
    15F5: 50 00    MOV   A,0x0
    15F7: 08       PUSH  A
    15F8: 50 00    MOV   A,0x0
    15FA: 08       PUSH  A
    15FB: 50 01    MOV   A,0x1
    15FD: 08       PUSH  A
    15FE: 7C 0B 7F LCALL _CYRF_WriteRegisterInc
(0587) 	CYRF_WriteTx_Data(tx_buf);
    1601: 50 10    MOV   A,0x10
    1603: 08       PUSH  A
    1604: 50 00    MOV   A,0x0
    1606: 08       PUSH  A
    1607: 50 20    MOV   A,0x20
    1609: 08       PUSH  A
    160A: 50 20    MOV   A,0x20
    160C: 08       PUSH  A
    160D: 7C 0B 24 LCALL _CYRF_WriteRegisterMultiD
    1610: 38 F8    ADD   SP,0xF8
    1612: 7F       RET   
(0588) }
(0589) 
(0590) 
(0591) void Bind_xfer_cb(void)
(0592) {
_Bind_xfer_cb:
  i                    --> X+0
    1613: 10       PUSH  X
    1614: 4F       MOV   X,SP
    1615: 38 01    ADD   SP,0x1
(0593) 	BYTE i;
(0594) 
(0595) 	if (Bind_cnt)
    1617: 3C 46 00 CMP   [Bind_cnt],0x0
    161A: A0 07    JZ    0x1622
(0596) 	{
(0597) 		Bind_cnt--;
    161C: 7A 46    DEC   [Bind_cnt]
(0598) 		DSM_StartBindAck();
    161E: 9F D2    CALL  _DSM_StartBindAck
(0599) 	}
    1620: 80 28    JMP   0x1649
(0600) 	else 
(0601) 	{
(0602) 		State=DSM_STATE_BIND_DONE;
    1622: 55 8B 05 MOV   [State],0x5
(0603) #ifdef DEBUG
(0604) 		LED_1_7_Off();
(0605) #endif
(0606) 		//save Mfg ID of transmitter
(0607) 		cyrfmfg_id[0]=~tx_buf[0];
    1625: 51 20    MOV   A,[mem]
    1627: 73       CPL   A
    1628: 53 73    MOV   [config],A
(0608) 		cyrfmfg_id[1]=~tx_buf[1];
    162A: 51 21    MOV   A,[mem+1]
    162C: 73       CPL   A
    162D: 53 74    MOV   [config+1],A
(0609) 		cyrfmfg_id[2]=~tx_buf[2];
    162F: 51 22    MOV   A,[mem+2]
    1631: 73       CPL   A
    1632: 53 75    MOV   [config+2],A
(0610) 		cyrfmfg_id[3]=~tx_buf[3];
    1634: 51 23    MOV   A,[mem+3]
    1636: 73       CPL   A
    1637: 53 76    MOV   [config+3],A
(0611) 		Timer_Stop();
    1639: 10       PUSH  X
    163A: 7C 04 87 LCALL _Timer8_1_Stop
    163D: 20       POP   X
(0612) 		Timer_SetCallback(0);
    163E: 50 03    MOV   A,0x3
    1640: 08       PUSH  A
    1641: 50 20    MOV   A,0x20
    1643: 08       PUSH  A
    1644: 7C 1D 64 LCALL _Timer_SetCallback
    1647: 38 FE    ADD   SP,0xFE
(0613) 	}
    1649: 38 FF    ADD   SP,0xFF
    164B: 20       POP   X
    164C: 7F       RET   
(0614) }
(0615) 
(0616) void DSM_initialize_bind_ack(void)
(0617) {
(0618)  	DSM_Build_Ack_package();
_DSM_initialize_bind_ack:
    164D: 9E E0    CALL  _DSM_Build_Ack_package
(0619) 	State=DSM_STATE_BIND_ACK;
    164F: 55 8B 04 MOV   [State],0x4
(0620)     CYRF_SetDataCode(pn_bind, 16);
    1652: 50 10    MOV   A,0x10
    1654: 08       PUSH  A
    1655: 50 01    MOV   A,0x1
    1657: 08       PUSH  A
    1658: 50 70    MOV   A,0x70
    165A: 08       PUSH  A
    165B: 50 23    MOV   A,0x23
    165D: 08       PUSH  A
    165E: 7C 0A BF LCALL _CYRF_WriteRegisterMulti
    1661: 38 FC    ADD   SP,0xFC
(0621) 	Timer_Stop();
    1663: 10       PUSH  X
    1664: 7C 04 87 LCALL _Timer8_1_Stop
(0622) 	Timer_SetPeriod(DSM_TIME_BIND_ACK);
    1667: 50 27    MOV   A,0x27
    1669: 7C 04 8B LCALL _Timer8_1_WritePeriod
    166C: 20       POP   X
(0623) 	Timer_SetCallback(Bind_xfer_cb);
    166D: 50 03    MOV   A,0x3
    166F: 08       PUSH  A
    1670: 50 1E    MOV   A,0x1E
    1672: 08       PUSH  A
    1673: 7C 1D 64 LCALL _Timer_SetCallback
    1676: 38 FE    ADD   SP,0xFE
(0624) 	Timer_Start();
    1678: 10       PUSH  X
    1679: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    167C: 20       POP   X
    167D: 7F       RET   
(0625) }
(0626) 
(0627) void Bind_TimeOut_cb(void)
(0628) {
(0629) 		DSM_ClearRxError();
_Bind_TimeOut_cb:
    167E: 7C 0E 6B LCALL _DSM_ClearRxError
(0630) #ifdef DEBUG
(0631) 		LED_1_5_Invert();
(0632) #endif
(0633) 		if (State==DSM_STATE_BIND_RCV_WAIT) //wait for done
    1681: 3C 8B 02 CMP   [State],0x2
    1684: B0 09    JNZ   0x168E
(0634) 		{ 
(0635) 			Bind_cnt=DSM_BIND_ACK_NUM;
    1686: 55 46 64 MOV   [Bind_cnt],0x64
(0636) 			State=DSM_STATE_BIND_RCV_START_ACK;
    1689: 55 8B 03 MOV   [State],0x3
(0637) 		}
    168C: 80 1A    JMP   0x16A7
(0638) 		else 
(0639) 		{
(0640) 		bind_channal=bind_channal+2;
    168E: 06 45 02 ADD   [bind_channal],0x2
(0641) 		if (bind_channal>DSM_MAX_CH)
    1691: 50 4F    MOV   A,0x4F
    1693: 3A 45    CMP   A,[bind_channal]
    1695: D0 04    JNC   0x169A
(0642) 			bind_channal=1;
    1697: 55 45 01 MOV   [bind_channal],0x1
(0643) 		CYRF_SetRFChannel(bind_channal);
    169A: 51 45    MOV   A,[bind_channal]
    169C: 08       PUSH  A
    169D: 50 00    MOV   A,0x0
    169F: 08       PUSH  A
    16A0: 7C 0A A6 LCALL _CYRF_WriteRegister
    16A3: 38 FE    ADD   SP,0xFE
(0644) 		DSM_StartRcv();
    16A5: 9F 39    CALL  _DSM_StartRcv
(0645) 		}
    16A7: 7F       RET   
(0646) }
(0647) 
(0648) void Process_BindRcvIrq(void)
(0649) {
_Process_BindRcvIrq:
  ckSum                --> X+1
  n                    --> X+0
    16A8: 10       PUSH  X
    16A9: 4F       MOV   X,SP
    16AA: 38 07    ADD   SP,0x7
(0650) 	BYTE n;
(0651)     WORD ckSum= 384 - 0x10;
    16AC: 56 02 70 MOV   [X+2],0x70
    16AF: 56 01 01 MOV   [X+1],0x1
(0652) 	Timer_Stop();
    16B2: 10       PUSH  X
    16B3: 7C 04 87 LCALL _Timer8_1_Stop
(0653) 	Timer_SetPeriod(DSM_TIME_BIND_RCV);
    16B6: 50 2E    MOV   A,0x2E
    16B8: 7C 04 8B LCALL _Timer8_1_WritePeriod
(0654) 	Timer_Start();
    16BB: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    16BE: 20       POP   X
(0655) #ifdef DEBUG
(0656) 	LED_1_4_Invert();
(0657) #endif
(0658) 	//check recived data
(0659) 	if(rx_buf[0]!=rx_buf[4] || rx_buf[1]!=rx_buf[5] ||rx_buf[2]!=rx_buf[6] || rx_buf[3]!=rx_buf[7])
    16BF: 51 30    MOV   A,[mem+16]
    16C1: 3A 34    CMP   A,[mem+20]
    16C3: B0 13    JNZ   0x16D7
    16C5: 51 31    MOV   A,[mem+17]
    16C7: 3A 35    CMP   A,[mem+21]
    16C9: B0 0D    JNZ   0x16D7
    16CB: 51 32    MOV   A,[mem+18]
    16CD: 3A 36    CMP   A,[mem+22]
    16CF: B0 07    JNZ   0x16D7
    16D1: 51 33    MOV   A,[mem+19]
    16D3: 3A 37    CMP   A,[mem+23]
    16D5: A0 03    JZ    0x16D9
(0660) 	{
(0661) 		goto Bind_rcv_error;
    16D7: 80 E4    JMP   0x17BC
(0662) 	}
(0663) 	//gennerate first checksum
(0664)     for(n = 0; n < 8; n++)
    16D9: 56 00 00 MOV   [X+0],0x0
    16DC: 80 12    JMP   0x16EF
(0665)         ckSum += rx_buf[n];
    16DE: 52 00    MOV   A,[X+0]
    16E0: 01 30    ADD   A,0x30
    16E2: 53 16    MOV   [__r1],A
    16E4: 3E 16    MVI   A,[__r1]
    16E6: 05 02    ADD   [X+2],A
    16E8: 50 00    MOV   A,0x0
    16EA: 0F 01 00 ADC   [X+1],0x0
    16ED: 77 00    INC   [X+0]
    16EF: 3D 00 08 CMP   [X+0],0x8
    16F2: CF EB    JC    0x16DE
(0666) 	if(rx_buf[8] != (ckSum >> 8) || rx_buf[9] !=(ckSum & 0xff))
    16F4: 52 01    MOV   A,[X+1]
    16F6: 53 16    MOV   [__r1],A
    16F8: 55 17 00 MOV   [__r0],0x0
    16FB: 5F 14 38 MOV   [__r3],[mem+24]
    16FE: 50 00    MOV   A,0x0
    1700: 3A 17    CMP   A,[__r0]
    1702: B0 1D    JNZ   0x1720
    1704: 51 14    MOV   A,[__r3]
    1706: 3A 16    CMP   A,[__r1]
    1708: B0 17    JNZ   0x1720
    170A: 52 02    MOV   A,[X+2]
    170C: 53 16    MOV   [__r1],A
    170E: 55 17 00 MOV   [__r0],0x0
    1711: 5F 14 39 MOV   [__r3],[mem+25]
    1714: 50 00    MOV   A,0x0
    1716: 3A 17    CMP   A,[__r0]
    1718: B0 07    JNZ   0x1720
    171A: 51 14    MOV   A,[__r3]
    171C: 3A 16    CMP   A,[__r1]
    171E: A0 03    JZ    0x1722
(0667) 	{
(0668) 		goto Bind_rcv_error;
    1720: 80 9B    JMP   0x17BC
(0669) 	}
(0670)     //gennerate second checksum 
(0671) 	for(n = 8; n < 14; n++)
    1722: 56 00 08 MOV   [X+0],0x8
    1725: 80 12    JMP   0x1738
(0672)         ckSum += rx_buf[n];
    1727: 52 00    MOV   A,[X+0]
    1729: 01 30    ADD   A,0x30
    172B: 53 16    MOV   [__r1],A
    172D: 3E 16    MVI   A,[__r1]
    172F: 05 02    ADD   [X+2],A
    1731: 50 00    MOV   A,0x0
    1733: 0F 01 00 ADC   [X+1],0x0
    1736: 77 00    INC   [X+0]
    1738: 3D 00 0E CMP   [X+0],0xE
    173B: CF EB    JC    0x1727
(0673) 	if(rx_buf[14] != (ckSum >> 8) || rx_buf[15] !=(ckSum & 0xff))
    173D: 52 01    MOV   A,[X+1]
    173F: 53 16    MOV   [__r1],A
    1741: 55 17 00 MOV   [__r0],0x0
    1744: 5F 14 3E MOV   [__r3],[mem+30]
    1747: 50 00    MOV   A,0x0
    1749: 3A 17    CMP   A,[__r0]
    174B: B0 1D    JNZ   0x1769
    174D: 51 14    MOV   A,[__r3]
    174F: 3A 16    CMP   A,[__r1]
    1751: B0 17    JNZ   0x1769
    1753: 52 02    MOV   A,[X+2]
    1755: 53 16    MOV   [__r1],A
    1757: 55 17 00 MOV   [__r0],0x0
    175A: 5F 14 3F MOV   [__r3],[mem+31]
    175D: 50 00    MOV   A,0x0
    175F: 3A 17    CMP   A,[__r0]
    1761: B0 07    JNZ   0x1769
    1763: 51 14    MOV   A,[__r3]
    1765: 3A 16    CMP   A,[__r1]
    1767: A0 03    JZ    0x176B
(0674) 	{
(0675) 		goto Bind_rcv_error;
    1769: 80 52    JMP   0x17BC
(0676) 	}
(0677) 	if (rx_buf[10] != 0x01)
    176B: 3C 3A 01 CMP   [mem+26],0x1
    176E: A0 03    JZ    0x1772
(0678) 	{
(0679) 		goto Bind_rcv_error;
    1770: 80 4B    JMP   0x17BC
(0680) 	}
(0681) 	num_channels=rx_buf[11];
    1772: 5F 49 3B MOV   [num_channels],[mem+27]
(0682) 	if (num_channels>PPM_PULSE_COUNT)
    1775: 50 07    MOV   A,0x7
    1777: 3A 49    CMP   A,[num_channels]
    1779: D0 04    JNC   0x177E
(0683) 		num_channels=PPM_PULSE_COUNT;
    177B: 55 49 07 MOV   [num_channels],0x7
(0684) 	DSM_Is_DSMX=PROTOC_IS_DSMX(rx_buf[12]);
    177E: 51 3C    MOV   A,[mem+28]
    1780: 21 A0    AND   A,0xA0
    1782: 39 A0    CMP   A,0xA0
    1784: B0 09    JNZ   0x178E
    1786: 56 04 01 MOV   [X+4],0x1
    1789: 56 03 00 MOV   [X+3],0x0
    178C: 80 07    JMP   0x1794
    178E: 56 04 00 MOV   [X+4],0x0
    1791: 56 03 00 MOV   [X+3],0x0
    1794: 52 04    MOV   A,[X+4]
    1796: 53 77    MOV   [config+4],A
(0685) 	DSM_Is_11ms=FALSE; //PROTOC_IS_DSM_11MS(rx_buf[12]);
    1798: 55 78 00 MOV   [config+5],0x0
(0686) 	DSM_Is_11Bit=PROTOC_IS_DSM_11BIT(rx_buf[12]);
    179B: 51 3C    MOV   A,[mem+28]
    179D: 21 30    AND   A,0x30
    179F: 67       ASR   A
    17A0: 67       ASR   A
    17A1: 67       ASR   A
    17A2: 67       ASR   A
    17A3: 21 0F    AND   A,0xF
    17A5: A0 09    JZ    0x17AF
    17A7: 56 06 01 MOV   [X+6],0x1
    17AA: 56 05 00 MOV   [X+5],0x0
    17AD: 80 07    JMP   0x17B5
    17AF: 56 06 00 MOV   [X+6],0x0
    17B2: 56 05 00 MOV   [X+5],0x0
    17B5: 52 06    MOV   A,[X+6]
    17B7: 53 79    MOV   [config+6],A
(0687) 	State=DSM_STATE_BIND_RCV_WAIT; 	
    17B9: 55 8B 02 MOV   [State],0x2
(0688) 
(0689) 	Bind_rcv_error:
(0690) 	DSM_StartRcv();
    17BC: 9E 22    CALL  _DSM_StartRcv
    17BE: 38 F9    ADD   SP,0xF9
    17C0: 20       POP   X
    17C1: 7F       RET   
(0691) }
(0692) //determin if we got 10 or 11 Bit data
(0693) // tryout
(0694) BYTE DSM_DeterminBitCount(void)
(0695) {
_DSM_DeterminBitCount:
  min                  --> X+3
  max                  --> X+2
  n                    --> X+1
  chanal               --> X+0
    17C2: 10       PUSH  X
    17C3: 4F       MOV   X,SP
    17C4: 38 04    ADD   SP,0x4
(0696) 	//tryout
(0697) 	BYTE min=0xff;
    17C6: 56 03 FF MOV   [X+3],0xFF
(0698) 	BYTE max=0;
    17C9: 56 02 00 MOV   [X+2],0x0
(0699) 	BYTE chanal;
(0700) 	BYTE n;
(0701) 	//try 10 Bits
(0702) 	for (n=0;n<7;n++)
    17CC: 56 01 00 MOV   [X+1],0x0
    17CF: 80 38    JMP   0x1808
(0703) 	{
(0704) 		chanal=(rx_data[n*2+2]>>2)&0xF;
    17D1: 52 01    MOV   A,[X+1]
    17D3: 64       ASL   A
    17D4: 01 22    ADD   A,0x22
    17D6: 53 16    MOV   [__r1],A
    17D8: 3E 16    MVI   A,[__r1]
    17DA: 67       ASR   A
    17DB: 67       ASR   A
    17DC: 21 0F    AND   A,0xF
    17DE: 54 00    MOV   [X+0],A
(0705) 		if (chanal && chanal<min)
    17E0: 3D 00 00 CMP   [X+0],0x0
    17E3: A0 0B    JZ    0x17EF
    17E5: 52 00    MOV   A,[X+0]
    17E7: 3B 03    CMP   A,[X+3]
    17E9: D0 05    JNC   0x17EF
(0706) 			min=chanal;
    17EB: 52 00    MOV   A,[X+0]
    17ED: 54 03    MOV   [X+3],A
(0707) 		if(rx_data[n*2+2]!=0xFF  && chanal>max)
    17EF: 52 01    MOV   A,[X+1]
    17F1: 64       ASL   A
    17F2: 01 22    ADD   A,0x22
    17F4: 53 16    MOV   [__r1],A
    17F6: 3E 16    MVI   A,[__r1]
    17F8: 39 FF    CMP   A,0xFF
    17FA: A0 0B    JZ    0x1806
    17FC: 52 02    MOV   A,[X+2]
    17FE: 3B 00    CMP   A,[X+0]
    1800: D0 05    JNC   0x1806
(0708) 			max=chanal;
    1802: 52 00    MOV   A,[X+0]
    1804: 54 02    MOV   [X+2],A
(0709) 	}		
    1806: 77 01    INC   [X+1]
    1808: 3D 01 07 CMP   [X+1],0x7
    180B: CF C5    JC    0x17D1
(0710) 	if (min==1 &&  max && max <7)
    180D: 3D 03 01 CMP   [X+3],0x1
    1810: B0 0F    JNZ   0x1820
    1812: 3D 02 00 CMP   [X+2],0x0
    1815: A0 0A    JZ    0x1820
    1817: 3D 02 07 CMP   [X+2],0x7
    181A: D0 05    JNC   0x1820
(0711) 		return 10;
    181C: 50 0A    MOV   A,0xA
    181E: 80 03    JMP   0x1822
(0712) 	else 
(0713) 		return 11;
    1820: 50 0B    MOV   A,0xB
    1822: 38 FC    ADD   SP,0xFC
    1824: 20       POP   X
    1825: 7F       RET   
(0714) }
(0715) 
(0716) #define PPM_OFFSET (PPM_OUT_CENTER_LEN-1024)
(0717) //Extract chanal data from serial data
(0718) BOOL DSM_process_Data(void)
(0719) {
_DSM_process_Data:
  n                    --> X+0
    1826: 10       PUSH  X
    1827: 4F       MOV   X,SP
    1828: 38 01    ADD   SP,0x1
(0720) static BYTE bits;	
(0721) 	if (!bits) //check if we have 10 or 11 Bit data
    182A: 3C 41 00 CMP   [CY_irq+1],0x0
    182D: B0 05    JNZ   0x1833
(0722) 		bits=DSM_DeterminBitCount();
    182F: 9F 91    CALL  _DSM_DeterminBitCount
    1831: 53 41    MOV   [CY_irq+1],A
(0723) 	if (bits)
    1833: 3C 41 00 CMP   [CY_irq+1],0x0
    1836: A0 FB    JZ    0x1932
(0724) 	{
(0725) 	BYTE n;
(0726) 	//static to safe stack space		
(0727) 	static BYTE chanal; 
(0728) 	static WORD value;	
(0729) 		//loop thru the words 
(0730) 		for (n=0;n<7;n++)
    1838: 56 00 00 MOV   [X+0],0x0
    183B: 80 ED    JMP   0x1929
(0731) 		{	//extract chanal number
(0732) 			if (bits==10)
    183D: 3C 41 0A CMP   [CY_irq+1],0xA
    1840: B0 0A    JNZ   0x184B
    1842: 97 4E    CALL  0x1F92
    1844: 40       NOP   
(0733) 				chanal=(rx_data[n*2+2]>>2)&0xF;
    1845: 21 0F    AND   A,0xF
    1847: 53 42    MOV   [CY_irq+2],A
    1849: 80 09    JMP   0x1853
(0734) 			else 
(0735) 				chanal=(rx_data[n*2+2]>>3)&0xF;
    184B: 97 45    CALL  0x1F92
    184D: 40       NOP   
    184E: 67       ASR   A
    184F: 21 0F    AND   A,0xF
    1851: 53 42    MOV   [CY_irq+2],A
(0736) 			//check if chanal numer is in range
(0737) 			if (chanal<PPM_PULSE_COUNT && rx_data[n*2+2]!=0xFF)
    1853: 3C 42 07 CMP   [CY_irq+2],0x7
    1856: D0 D0    JNC   0x1927
    1858: 52 00    MOV   A,[X+0]
    185A: 64       ASL   A
    185B: 01 22    ADD   A,0x22
    185D: 53 16    MOV   [__r1],A
    185F: 3E 16    MVI   A,[__r1]
    1861: 39 FF    CMP   A,0xFF
    1863: A0 C3    JZ    0x1927
(0738) 				//extract chanal value
(0739) 			{
(0740) 				if (bits==10)
    1865: 3C 41 0A CMP   [CY_irq+1],0xA
    1868: B0 21    JNZ   0x188A
(0741) 				{
(0742) 					value=(((WORD)rx_data[n*2+2]<<8)+rx_data[n*2+3])&0x3FF;
    186A: 52 00    MOV   A,[X+0]
    186C: 64       ASL   A
    186D: 53 16    MOV   [__r1],A
    186F: 01 23    ADD   A,0x23
    1871: 53 14    MOV   [__r3],A
    1873: 3E 14    MVI   A,[__r3]
    1875: 53 15    MOV   [__r2],A
    1877: 06 16 22 ADD   [__r1],0x22
    187A: 3E 16    MVI   A,[__r1]
    187C: 53 17    MOV   [__r0],A
    187E: 51 15    MOV   A,[__r2]
    1880: 53 44    MOV   [CY_irq+4],A
    1882: 51 17    MOV   A,[__r0]
    1884: 21 03    AND   A,0x3
    1886: 53 43    MOV   [CY_irq+3],A
(0743) 				}
    1888: 80 1F    JMP   0x18A8
(0744) 				else
(0745) 				{
(0746) 					value=(((WORD)rx_data[n*2+2]<<8)+rx_data[n*2+3])&0x7FF;
    188A: 52 00    MOV   A,[X+0]
    188C: 64       ASL   A
    188D: 53 16    MOV   [__r1],A
    188F: 01 23    ADD   A,0x23
    1891: 53 14    MOV   [__r3],A
    1893: 3E 14    MVI   A,[__r3]
    1895: 53 15    MOV   [__r2],A
    1897: 06 16 22 ADD   [__r1],0x22
    189A: 3E 16    MVI   A,[__r1]
    189C: 53 17    MOV   [__r0],A
    189E: 51 15    MOV   A,[__r2]
    18A0: 53 44    MOV   [CY_irq+4],A
    18A2: 51 17    MOV   A,[__r0]
    18A4: 21 07    AND   A,0x7
    18A6: 53 43    MOV   [CY_irq+3],A
(0747) 				}
(0748) 				//PPM has resulution of 2000/1ms so 10 Bit datta (0 to 1024) needs to be multipleid by 2
(0749) 				//best would be a linear scale like "Value=PPM_MIN + (value*(PPM_MAX-PPM_MIN))/(1<<Bits)" but that takes to mutch time.
(0750) 				if (bits==10) 
    18A8: 3C 41 0A CMP   [CY_irq+1],0xA
    18AB: B0 23    JNZ   0x18CF
(0751) 					ppm_Data[chanal]=PPM_OFFSET+ value*2;
    18AD: 5F 16 44 MOV   [__r1],[CY_irq+4]
    18B0: 5F 17 43 MOV   [__r0],[CY_irq+3]
    18B3: 65 16    ASL   [__r1]
    18B5: 6B 17    RLC   [__r0]
    18B7: 06 16 B8 ADD   [__r1],0xB8
    18BA: 0E 17 07 ADC   [__r0],0x7
    18BD: 5F 14 42 MOV   [__r3],[CY_irq+2]
    18C0: 65 14    ASL   [__r3]
    18C2: 06 14 65 ADD   [__r3],0x65
    18C5: 51 17    MOV   A,[__r0]
    18C7: 3F 14    MVI   [__r3],A
    18C9: 51 16    MOV   A,[__r1]
    18CB: 3F 14    MVI   [__r3],A
    18CD: 80 19    JMP   0x18E7
(0752) 				else 
(0753) 					ppm_Data[chanal]=PPM_OFFSET+ value;
    18CF: 51 44    MOV   A,[CY_irq+4]
    18D1: 01 B8    ADD   A,0xB8
    18D3: 53 16    MOV   [__r1],A
    18D5: 51 43    MOV   A,[CY_irq+3]
    18D7: 09 07    ADC   A,0x7
    18D9: 5F 14 42 MOV   [__r3],[CY_irq+2]
    18DC: 65 14    ASL   [__r3]
    18DE: 06 14 65 ADD   [__r3],0x65
    18E1: 3F 14    MVI   [__r3],A
    18E3: 51 16    MOV   A,[__r1]
    18E5: 3F 14    MVI   [__r3],A
(0754) 				//limit to MIN / MAX
(0755) 				if (PPM_OUT_MAX_LEN<ppm_Data[chanal])
    18E7: 5F 16 42 MOV   [__r1],[CY_irq+2]
    18EA: 96 8C    CALL  0x1F78
    18EC: 40       NOP   
    18ED: 53 16    MOV   [__r1],A
    18EF: 50 B8    MOV   A,0xB8
    18F1: 12 16    SUB   A,[__r1]
    18F3: 50 0F    MOV   A,0xF
    18F5: 1A 17    SBB   A,[__r0]
    18F7: D0 11    JNC   0x1909
(0756) 					ppm_Data[chanal]=PPM_OUT_MAX_LEN;
    18F9: 5F 16 42 MOV   [__r1],[CY_irq+2]
    18FC: 65 16    ASL   [__r1]
    18FE: 06 16 65 ADD   [__r1],0x65
    1901: 50 0F    MOV   A,0xF
    1903: 3F 16    MVI   [__r1],A
    1905: 50 B8    MOV   A,0xB8
    1907: 3F 16    MVI   [__r1],A
(0757) 				if (PPM_OUT_MIN_LEN>ppm_Data[chanal])
    1909: 5F 16 42 MOV   [__r1],[CY_irq+2]
    190C: 96 6A    CALL  0x1F78
    190E: 40       NOP   
    190F: 11 B8    SUB   A,0xB8
    1911: 51 17    MOV   A,[__r0]
    1913: 19 07    SBB   A,0x7
    1915: D0 11    JNC   0x1927
(0758) 					ppm_Data[chanal]=PPM_OUT_MIN_LEN;
    1917: 5F 16 42 MOV   [__r1],[CY_irq+2]
    191A: 65 16    ASL   [__r1]
    191C: 06 16 65 ADD   [__r1],0x65
    191F: 50 07    MOV   A,0x7
    1921: 3F 16    MVI   [__r1],A
    1923: 50 B8    MOV   A,0xB8
    1925: 3F 16    MVI   [__r1],A
(0759) 			}
(0760) 		}
    1927: 77 00    INC   [X+0]
    1929: 3D 00 07 CMP   [X+0],0x7
    192C: CF 10    JC    0x183D
(0761) 		return 1;
    192E: 50 01    MOV   A,0x1
    1930: 80 03    JMP   0x1934
(0762) 	}
(0763) 	return 0;
    1932: 50 00    MOV   A,0x0
    1934: 38 FF    ADD   SP,0xFF
    1936: 20       POP   X
    1937: 7F       RET   
(0764) }
(0765) 
(0766) void DSM_Save_Failsafe_Presets(void)
(0767) {
_DSM_Save_Failsafe_Presets:
  n                    --> X+0
    1938: 10       PUSH  X
    1939: 4F       MOV   X,SP
    193A: 38 01    ADD   SP,0x1
(0768) BYTE n;
(0769) #ifdef DEBUG
(0770) 	LED_1_6_Invert();
(0771) 	LED_1_6_Invert();
(0772) #endif
(0773) 	for(n=0;n<PPM_PULSE_COUNT;n++)
    193C: 56 00 00 MOV   [X+0],0x0
    193F: 80 22    JMP   0x1962
(0774) 	{	
(0775) 		ppm_fs_Data[n]=ppm_Data[n];
    1941: 96 29    CALL  <created procedures>
    1943: 40       NOP   
    1944: 51 16    MOV   A,[__r1]
    1946: 01 65    ADD   A,0x65
    1948: 53 14    MOV   [__r3],A
    194A: 3E 14    MVI   A,[__r3]
    194C: 53 15    MOV   [__r2],A
    194E: 3E 14    MVI   A,[__r3]
    1950: 53 14    MOV   [__r3],A
    1952: 06 16 7B ADD   [__r1],0x7B
    1955: 0E 17 00 ADC   [__r0],0x0
    1958: 51 15    MOV   A,[__r2]
    195A: 3F 16    MVI   [__r1],A
    195C: 51 14    MOV   A,[__r3]
    195E: 3F 16    MVI   [__r1],A
(0776) 	}
    1960: 77 00    INC   [X+0]
    1962: 3D 00 07 CMP   [X+0],0x7
    1965: CF DB    JC    0x1941
(0777) Preste_Failsafe=TRUE;
    1967: 55 7A 01 MOV   [config+7],0x1
    196A: 38 FF    ADD   SP,0xFF
    196C: 20       POP   X
    196D: 7F       RET   
(0778) }
(0779) 
(0780) void DSM_Load_FS_Data(void)
(0781) {
_DSM_Load_FS_Data:
  n                    --> X+0
    196E: 10       PUSH  X
    196F: 4F       MOV   X,SP
    1970: 38 01    ADD   SP,0x1
(0782) BYTE n;
(0783) #ifdef DEBUG
(0784) 	LED_1_6_Invert();
(0785) 	LED_1_6_Invert();
(0786) #endif
(0787) 	if (Preste_Failsafe)
    1972: 3C 7A 00 CMP   [config+7],0x0
    1975: A0 2E    JZ    0x19A4
(0788) 	{
(0789) 		for(n=0;n<PPM_PULSE_COUNT;n++)
    1977: 56 00 00 MOV   [X+0],0x0
    197A: 80 22    JMP   0x199D
(0790) 		{	
(0791) 			ppm_Data[n]=ppm_fs_Data[n];
    197C: 95 EE    CALL  <created procedures>
    197E: 40       NOP   
    197F: 51 16    MOV   A,[__r1]
    1981: 01 7B    ADD   A,0x7B
    1983: 53 14    MOV   [__r3],A
    1985: 3E 14    MVI   A,[__r3]
    1987: 53 15    MOV   [__r2],A
    1989: 3E 14    MVI   A,[__r3]
    198B: 53 14    MOV   [__r3],A
    198D: 06 16 65 ADD   [__r1],0x65
    1990: 0E 17 00 ADC   [__r0],0x0
    1993: 51 15    MOV   A,[__r2]
    1995: 3F 16    MVI   [__r1],A
    1997: 51 14    MOV   A,[__r3]
    1999: 3F 16    MVI   [__r1],A
(0792) 		}
    199B: 77 00    INC   [X+0]
    199D: 3D 00 07 CMP   [X+0],0x7
    19A0: CF DB    JC    0x197C
(0793) 	}
    19A2: 80 07    JMP   0x19AA
(0794) 	else 
(0795) 	{
(0796) 		ppm_Data[0]=PPM_OUT_MIN_LEN;
    19A4: 55 66 B8 MOV   [ppm_Data+1],0xB8
    19A7: 55 65 07 MOV   [ppm_Data],0x7
(0797) 	}
    19AA: 38 FF    ADD   SP,0xFF
    19AC: 20       POP   X
    19AD: 7F       RET   
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) //98000BFE295413FE26A81BFE0154 //DSMX
(0006) 
(0007) //900005FF14AA09FF13540DFF00AA   //DSM2
(0008) 
(0009) #include <m8c.h>        // part specific constants and macros
(0010) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0011) #include "timer.h"
(0012) #include "CYRF6936.h"
(0013) #include "DSM.h"
(0014) #include "config.h"
(0015) #include "ppm.h"
(0016) 
(0017) 
(0018) 
(0019) //global data
(0020) BOOL LV_Detect=FALSE;
(0021) //#define DEBUG
(0022) 
(0023) // Declare LVD_ISR as ISR
(0024) #pragma interrupt_handler LVD_ISR
(0025) void LVD_ISR(void)
(0026) {
_LVD_ISR:
    19AE: 08       PUSH  A
(0027)  	LV_Detect=TRUE;
    19AF: 55 04 01 MOV   [LV_Detect],0x1
(0028) 	M8C_ClearIntFlag(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR);
    19B2: 41 E0 FE AND   REG[0xE0],0xFE
(0029) 	M8C_DisableIntMask(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR); 
    19B5: 41 E0 FE AND   REG[0xE0],0xFE
    19B8: 18       POP   A
    19B9: 7E       RETI  
(0030) }
(0031) 
(0032) 
(0033) void main(void)
(0034) {
_main:
  n                    --> X+5
  Bind                 --> X+0
    19BA: 10       PUSH  X
    19BB: 4F       MOV   X,SP
    19BC: 38 0C    ADD   SP,0xC
(0035) 	BOOL Bind;
(0036) 	//initialize everiting
(0037) 
(0038) 	//enable glogal interrupts
(0039) 	M8C_EnableGInt;		
    19BE: 71 01    OR    F,0x1
(0040) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_VOLTAGE_MONITOR); 
    19C0: 43 E0 01 OR    REG[0xE0],0x1
(0041) 	ppm_Init();
    19C3: 7C 1B 8A LCALL _ppm_Init
(0042) 
(0043) #ifdef DEBUG
(0044) 	LED_1_Start();
(0045) 	LED_1_7_Start();
(0046) 	LED_1_5_Start();
(0047) 	LED_1_4_Start();
(0048) 	LED_1_6_Start();
(0049) #endif
(0050) 	Timer_init();
    19C6: 7C 1D 52 LCALL _Timer_init
(0051) 	LED_1_Start();
    19C9: 10       PUSH  X
    19CA: 7C 05 78 LCALL LED_1_On|LED_1_Start|LED_1_Stop|LED_1_0_Invert|_LED_1_Start|LED_1_Off|_LED_1_Off|_LED_1_Stop|LED_1_0_GetState
    19CD: 20       POP   X
(0052) 	DSM_Init();
    19CE: 7C 14 AB LCALL _DSM_Init
(0053) #ifndef DEBUG
(0054) 	E2PROM_1_Start();
    19D1: 10       PUSH  X
    19D2: 7C 05 8B LCALL _E2PROM_1_Start|LED_1_Invert|E2PROM_1_Start|LED_1_GetState
    19D5: 20       POP   X
(0055) #endif
(0056) 
(0057) 
(0058) Bind=(Bind_Port_Data_ADDR&Bind_Port_MASK)?FALSE:TRUE;
    19D6: 5D 0C    MOV   A,REG[0xC]
    19D8: 53 17    MOV   [__r0],A
    19DA: 47 17 04 TST   [__r0],0x4
    19DD: A0 09    JZ    0x19E7
    19DF: 56 02 00 MOV   [X+2],0x0
    19E2: 56 01 00 MOV   [X+1],0x0
    19E5: 80 07    JMP   0x19ED
    19E7: 56 02 01 MOV   [X+2],0x1
    19EA: 56 01 00 MOV   [X+1],0x0
    19ED: 52 02    MOV   A,[X+2]
    19EF: 54 00    MOV   [X+0],A
(0059) Bind=Bind||!ReadConfig(&config,sizeof (config_s));	
    19F1: 3D 00 00 CMP   [X+0],0x0
    19F4: B0 13    JNZ   0x1A08
    19F6: 50 16    MOV   A,0x16
    19F8: 08       PUSH  A
    19F9: 50 00    MOV   A,0x0
    19FB: 08       PUSH  A
    19FC: 50 73    MOV   A,0x73
    19FE: 08       PUSH  A
    19FF: 7C 0A 06 LCALL _ReadConfig
    1A02: 38 FD    ADD   SP,0xFD
    1A04: 39 00    CMP   A,0x0
    1A06: B0 09    JNZ   0x1A10
    1A08: 56 04 01 MOV   [X+4],0x1
    1A0B: 56 03 00 MOV   [X+3],0x0
    1A0E: 80 07    JMP   0x1A16
    1A10: 56 04 00 MOV   [X+4],0x0
    1A13: 56 03 00 MOV   [X+3],0x0
    1A16: 52 04    MOV   A,[X+4]
    1A18: 54 00    MOV   [X+0],A
(0060) 	
(0061) 	
(0062) if (Bind)
    1A1A: 3D 00 00 CMP   [X+0],0x0
    1A1D: A0 E1    JZ    0x1AFF
(0063) 	{
(0064) 	BYTE n=0;
    1A1F: 56 05 00 MOV   [X+5],0x0
(0065) 	DSM_initialize_bind();
    1A22: 7C 14 E7 LCALL _DSM_initialize_bind
(0066) 	do
(0067) 		{
(0068) 		if (LV_Detect)	
    1A25: 3C 04 00 CMP   [LV_Detect],0x0
    1A28: A0 31    JZ    0x1A5A
(0069) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x340)==0x340?1:0);
    1A2A: 10       PUSH  X
    1A2B: 7C 04 D4 LCALL _SleepTimer_1_SyncWait|SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_bGetTimer|_SleepTimer_1_iGetTickCntr
    1A2E: 5A 17    MOV   [__r0],X
    1A30: 53 16    MOV   [__r1],A
    1A32: 20       POP   X
    1A33: 26 16 40 AND   [__r1],0x40
    1A36: 26 17 03 AND   [__r0],0x3
    1A39: 3C 17 03 CMP   [__r0],0x3
    1A3C: B0 0E    JNZ   0x1A4B
    1A3E: 3C 16 40 CMP   [__r1],0x40
    1A41: B0 09    JNZ   0x1A4B
    1A43: 56 07 01 MOV   [X+7],0x1
    1A46: 56 06 00 MOV   [X+6],0x0
    1A49: 80 07    JMP   0x1A51
    1A4B: 56 07 00 MOV   [X+7],0x0
    1A4E: 56 06 00 MOV   [X+6],0x0
    1A51: 52 07    MOV   A,[X+7]
    1A53: 10       PUSH  X
    1A54: 7C 05 7A LCALL _LED_1_Switch
    1A57: 20       POP   X
    1A58: 80 66    JMP   0x1ABF
(0070) 		else if (DSM_BIND_WAIT())
    1A5A: 3C 8B 02 CMP   [State],0x2
    1A5D: D0 31    JNC   0x1A8F
(0071) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x100)==0x100?1:0);
    1A5F: 10       PUSH  X
    1A60: 7C 04 D4 LCALL _SleepTimer_1_SyncWait|SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_bGetTimer|_SleepTimer_1_iGetTickCntr
    1A63: 5A 17    MOV   [__r0],X
    1A65: 53 16    MOV   [__r1],A
    1A67: 20       POP   X
    1A68: 26 16 00 AND   [__r1],0x0
    1A6B: 26 17 01 AND   [__r0],0x1
    1A6E: 3C 17 01 CMP   [__r0],0x1
    1A71: B0 0E    JNZ   0x1A80
    1A73: 3C 16 00 CMP   [__r1],0x0
    1A76: B0 09    JNZ   0x1A80
    1A78: 56 09 01 MOV   [X+9],0x1
    1A7B: 56 08 00 MOV   [X+8],0x0
    1A7E: 80 07    JMP   0x1A86
    1A80: 56 09 00 MOV   [X+9],0x0
    1A83: 56 08 00 MOV   [X+8],0x0
    1A86: 52 09    MOV   A,[X+9]
    1A88: 10       PUSH  X
    1A89: 7C 05 7A LCALL _LED_1_Switch
    1A8C: 20       POP   X
    1A8D: 80 31    JMP   0x1ABF
(0072) 		else if (DSM_BIND_ACK())
    1A8F: 3C 8B 03 CMP   [State],0x3
    1A92: C0 2C    JC    0x1ABF
(0073) 			LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x40)==0x40?1:0);
    1A94: 10       PUSH  X
    1A95: 7C 04 D4 LCALL _SleepTimer_1_SyncWait|SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_bGetTimer|_SleepTimer_1_iGetTickCntr
    1A98: 5A 17    MOV   [__r0],X
    1A9A: 53 16    MOV   [__r1],A
    1A9C: 20       POP   X
    1A9D: 26 16 40 AND   [__r1],0x40
    1AA0: 26 17 00 AND   [__r0],0x0
    1AA3: B0 0E    JNZ   0x1AB2
    1AA5: 3C 16 40 CMP   [__r1],0x40
    1AA8: B0 09    JNZ   0x1AB2
    1AAA: 56 0B 01 MOV   [X+11],0x1
    1AAD: 56 0A 00 MOV   [X+10],0x0
    1AB0: 80 07    JMP   0x1AB8
    1AB2: 56 0B 00 MOV   [X+11],0x0
    1AB5: 56 0A 00 MOV   [X+10],0x0
    1AB8: 52 0B    MOV   A,[X+11]
    1ABA: 10       PUSH  X
    1ABB: 7C 05 7A LCALL _LED_1_Switch
    1ABE: 20       POP   X
(0074) 		DSM_Cyclic();
    1ABF: 7C 11 4E LCALL _DSM_Cyclic
(0075) 		}
(0076) 	//wait till binding is done
(0077) 	while(!DSM_BIND_DONE());
    1AC2: 3C 8B 0B CMP   [State],0xB
    1AC5: CF 5F    JC    0x1A25
(0078) 	
(0079) 	do 	//wait for stable
(0080) 		{
(0081) 			if (new_data)
    1AC7: 3C 8A 00 CMP   [new_data],0x0
    1ACA: A0 06    JZ    0x1AD1
(0082) 				{
(0083) 				new_data=0;	
    1ACC: 55 8A 00 MOV   [new_data],0x0
(0084) 				n++;	
    1ACF: 77 05    INC   [X+5]
(0085) 				}
(0086) 		DSM_Cyclic();
    1AD1: 7C 11 4E LCALL _DSM_Cyclic
(0087) 		}
(0088) 	while (n<5);
    1AD4: 3D 05 05 CMP   [X+5],0x5
    1AD7: CF EF    JC    0x1AC7
(0089) 		
(0090) 	//save falisave position
(0091) 	if(Bind_Port_Data_ADDR&Bind_Port_MASK)
    1AD9: 5D 0C    MOV   A,REG[0xC]
    1ADB: 53 17    MOV   [__r0],A
    1ADD: 47 17 04 TST   [__r0],0x4
    1AE0: A0 04    JZ    0x1AE5
(0092) 	{
(0093) 			DSM_Save_Failsafe_Presets();
    1AE2: 7C 19 38 LCALL _DSM_Save_Failsafe_Presets
(0094) 	}
(0095) 	
(0096) 
(0097) 	//save configuration to FLASH
(0098) 	Timer_Stop();
    1AE5: 10       PUSH  X
    1AE6: 7C 04 87 LCALL _Timer8_1_Stop
    1AE9: 20       POP   X
(0099) 	SaveConfig(&config,sizeof (config_s));
    1AEA: 50 16    MOV   A,0x16
    1AEC: 08       PUSH  A
    1AED: 50 00    MOV   A,0x0
    1AEF: 08       PUSH  A
    1AF0: 50 73    MOV   A,0x73
    1AF2: 08       PUSH  A
    1AF3: 7C 09 A7 LCALL __UserModules_end|_FlashReadBlock|__text_start|_SaveConfig|_SaveConfig
    1AF6: 38 FD    ADD   SP,0xFD
(0100) 	Timer_Start();
    1AF8: 10       PUSH  X
    1AF9: 7C 04 83 LCALL Timer8_1_Start|_Timer8_1_DisableInt|_Timer8_1_Start
    1AFC: 20       POP   X
(0101) 	}
    1AFD: 80 12    JMP   0x1B10
(0102) 	else 
(0103) 	{
(0104) 		DSM_initialize_Recive();	
    1AFF: 7C 0F 9C LCALL _DSM_initialize_Recive
(0105) 		do 
(0106) 		{
(0107) 			Rcv_Timeout=FALSE;
    1B02: 55 89 00 MOV   [Rcv_Timeout],0x0
(0108) 			new_data=FALSE;	
    1B05: 55 8A 00 MOV   [new_data],0x0
(0109) 			DSM_Cyclic();
    1B08: 7C 11 4E LCALL _DSM_Cyclic
(0110) 		}while (!DSM_INSYNC());
    1B0B: 3C 8B 0B CMP   [State],0xB
    1B0E: CF F3    JC    0x1B02
(0111) 	}
(0112) 		do
(0113) 			{
(0114) 			DSM_Cyclic();
    1B10: 7C 11 4E LCALL _DSM_Cyclic
(0115) 			if (LV_Detect)	
    1B13: 3C 04 00 CMP   [LV_Detect],0x0
    1B16: A0 31    JZ    0x1B48
(0116) 				LED_1_Switch((SleepTimer_1_iGetTickCntr()&0x340)==0x340?1:0);
    1B18: 10       PUSH  X
    1B19: 7C 04 D4 LCALL _SleepTimer_1_SyncWait|SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTickCntr|_SleepTimer_1_SetTimer|_SleepTimer_1_bGetTimer|_SleepTimer_1_iGetTickCntr
    1B1C: 5A 17    MOV   [__r0],X
    1B1E: 53 16    MOV   [__r1],A
    1B20: 20       POP   X
    1B21: 26 16 40 AND   [__r1],0x40
    1B24: 26 17 03 AND   [__r0],0x3
    1B27: 3C 17 03 CMP   [__r0],0x3
    1B2A: B0 0E    JNZ   0x1B39
    1B2C: 3C 16 40 CMP   [__r1],0x40
    1B2F: B0 09    JNZ   0x1B39
    1B31: 56 06 01 MOV   [X+6],0x1
    1B34: 56 05 00 MOV   [X+5],0x0
    1B37: 80 07    JMP   0x1B3F
    1B39: 56 06 00 MOV   [X+6],0x0
    1B3C: 56 05 00 MOV   [X+5],0x0
    1B3F: 52 06    MOV   A,[X+6]
    1B41: 10       PUSH  X
    1B42: 7C 05 7A LCALL _LED_1_Switch
    1B45: 20       POP   X
    1B46: 80 1B    JMP   0x1B62
(0117) 			else	
(0118) 				LED_1_Switch(DSM_INSYNC());
    1B48: 3C 8B 0B CMP   [State],0xB
    1B4B: C0 09    JC    0x1B55
    1B4D: 56 08 01 MOV   [X+8],0x1
    1B50: 56 07 00 MOV   [X+7],0x0
    1B53: 80 07    JMP   0x1B5B
    1B55: 56 08 00 MOV   [X+8],0x0
    1B58: 56 07 00 MOV   [X+7],0x0
    1B5B: 52 08    MOV   A,[X+8]
    1B5D: 10       PUSH  X
    1B5E: 7C 05 7A LCALL _LED_1_Switch
    1B61: 20       POP   X
(0119) 			if (Rcv_Timeout)
    1B62: 3C 89 00 CMP   [Rcv_Timeout],0x0
    1B65: A0 0A    JZ    0x1B70
(0120) 			{
(0121) 				DSM_Load_FS_Data();
    1B67: 7C 19 6E LCALL _DSM_Load_FS_Data
(0122) 				Rcv_Timeout=FALSE;
    1B6A: 55 89 00 MOV   [Rcv_Timeout],0x0
(0123) 				new_data=TRUE;
    1B6D: 55 8A 01 MOV   [new_data],0x1
(0124) 			}
(0125) 			if (PPM_IS_PPM_DONE())
    1B70: 3C 06 00 CMP   [ppm_Run],0x0
    1B73: B0 0F    JNZ   0x1B83
(0126) 				{
(0127) 				if (new_data)
    1B75: 3C 8A 00 CMP   [new_data],0x0
    1B78: A0 0A    JZ    0x1B83
(0128) 					{
(0129) 					new_data=FALSE;	
    1B7A: 55 8A 00 MOV   [new_data],0x0
(0130) 					Rcv_Timeout=FALSE;
    1B7D: 55 89 00 MOV   [Rcv_Timeout],0x0
(0131) 					PPM_START_ONE_PPM_TRAIN();
    1B80: 7C 1C 5E LCALL _PPM_Start_One_PPM_Train
(0132) 					}
(0133) 				}
(0134) 			}
(0135) 		while (1);	
    1B83: 8F 8C    JMP   0x1B10
    1B85: 38 F4    ADD   SP,0xF4
    1B87: 20       POP   X
    1B88: 8F FF    JMP   0x1B88
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\ppm.c
(0001) /*
(0002) *PPM.C
(0003) *A 16 Bit PWM module  is used to gennerate the PPM train
(0004) *The PWM actually gennerates an inverted CPPM __|_|_|_|_|_|_|_|_|___|_|_|_|_|_|_|_|_|___|_
(0005) *this has the advantage that the pulse width can stay constant, only the periode has to be changed
(0006) *on everey compare match interrupt the periode value for the next chanel is loaded
(0007) *the last chanal value has an extra large value and is used to gennerate the sync gap
(0008) */
(0009) 
(0010) #include <m8c.h>        // part specific constants and macros
(0011) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0012) #include "config.h"
(0013) #include "ppm.h"
(0014) 
(0015) //#define DEBUG
(0016) 
(0017) volatile BYTE ppm_Nr=0;//the chanal counter
(0018) volatile BOOL ppm_Run=0;//start one pulse train
(0019) BOOL TC_IRQ;
(0020) 
(0021) #define PWM_TC_IRQ 0x31;
(0022) #define PWM_CM_IRQ 0x39;
(0023) //initialize PPM output
(0024) void ppm_Init(void )
(0025) {
_ppm_Init:
  n                    --> X+0
    1B8A: 10       PUSH  X
    1B8B: 4F       MOV   X,SP
    1B8C: 38 02    ADD   SP,0x2
(0026) 	
(0027) int n;
(0028) 	//Init PPM_DATA array
(0029) 	for (n=0;n<PPM_PULSE_COUNT;n++)
    1B8E: 56 01 00 MOV   [X+1],0x0
    1B91: 56 00 00 MOV   [X+0],0x0
(0030) 	{	//set to center
(0031) 		ppm_Data[n]=PPM_OUT_CENTER_LEN;
    1B94: 52 01    MOV   A,[X+1]
    1B96: 64       ASL   A
    1B97: 01 65    ADD   A,0x65
    1B99: 53 16    MOV   [__r1],A
    1B9B: 50 0B    MOV   A,0xB
    1B9D: 3F 16    MVI   [__r1],A
    1B9F: 50 B8    MOV   A,0xB8
    1BA1: 3F 16    MVI   [__r1],A
(0032) 	}
    1BA3: 77 01    INC   [X+1]
    1BA5: 0F 00 00 ADC   [X+0],0x0
    1BA8: 52 01    MOV   A,[X+1]
    1BAA: 11 07    SUB   A,0x7
    1BAC: 52 00    MOV   A,[X+0]
    1BAE: 31 80    XOR   A,0x80
    1BB0: 19 80    SBB   A,0x80
    1BB2: CF E1    JC    0x1B94
(0033) 	//enable compare match interrupt of the PWM
(0034) 	PWM16_1_EnableInt();
    1BB4: 10       PUSH  X
    1BB5: 7C 04 FA LCALL _PWM16_1_EnableInt
(0035) 	//pulse widht is actually the small gap between the PPM pulses
(0036) 	PWM16_1_WritePulseWidth(PPM_OUT_PULSE_GAP_LEN_US);
    1BB8: 57 01    MOV   X,0x1
    1BBA: 50 90    MOV   A,0x90
    1BBC: 7C 05 0C LCALL _PWM16_1_WritePulseWidth
    1BBF: 20       POP   X
(0037) 	//disconnect the PIN from the PWM and  set the pin to High
(0038) 	PPM_DISCON_SET_OUT_PIN_HIGH;
    1BC0: 43 B4 0F OR    REG[0xB4],0xF
(0039) 	//init pulse counter, will loop thru the cannels
(0040) 	ppm_Nr=0;		
    1BC3: 55 05 00 MOV   [ppm_Nr],0x0
(0041) 	TC_IRQ=TRUE;
    1BC6: 55 8E 01 MOV   [TC_IRQ],0x1
(0042) 	PWM16_1_FUNC_MSB_REG=PWM_TC_IRQ;
    1BC9: 71 10    OR    F,0x10
    1BCB: 62 24 31 MOV   REG[0x24],0x31
(0043) 	//set a initial pulse len, just to have somthing in ther will be change in the interrupt service
(0044) 	PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN);
    1BCE: 10       PUSH  X
    1BCF: 57 17    MOV   X,0x17
    1BD1: 50 70    MOV   A,0x70
    1BD3: 70 CF    AND   F,0xCF
    1BD5: 7C 05 06 LCALL _PWM16_1_WritePeriod
    1BD8: 20       POP   X
    1BD9: 38 FE    ADD   SP,0xFE
    1BDB: 20       POP   X
    1BDC: 7F       RET   
(0045) }//END OFF ppm_Init
(0046) 
(0047) void Switch_LED(BYTE val)
(0048) {
_Switch_LED:
  val                  --> X-4
    1BDD: 10       PUSH  X
    1BDE: 4F       MOV   X,SP
    1BDF: 38 02    ADD   SP,0x2
(0049) #ifndef DEBUG	
(0050) 	switch (ppm_Nr)
    1BE1: 51 05    MOV   A,[ppm_Nr]
    1BE3: 54 01    MOV   [X+1],A
    1BE5: 56 00 00 MOV   [X+0],0x0
    1BE8: 3D 00 00 CMP   [X+0],0x0
    1BEB: B0 06    JNZ   0x1BF2
    1BED: 3D 01 02 CMP   [X+1],0x2
    1BF0: A0 35    JZ    0x1C26
    1BF2: 3D 00 00 CMP   [X+0],0x0
    1BF5: B0 06    JNZ   0x1BFC
    1BF7: 3D 01 03 CMP   [X+1],0x3
    1BFA: A0 34    JZ    0x1C2F
    1BFC: 3D 00 00 CMP   [X+0],0x0
    1BFF: B0 06    JNZ   0x1C06
    1C01: 3D 01 04 CMP   [X+1],0x4
    1C04: A0 33    JZ    0x1C38
    1C06: 3D 00 00 CMP   [X+0],0x0
    1C09: B0 06    JNZ   0x1C10
    1C0B: 3D 01 05 CMP   [X+1],0x5
    1C0E: A0 32    JZ    0x1C41
    1C10: 3D 00 00 CMP   [X+0],0x0
    1C13: B0 06    JNZ   0x1C1A
    1C15: 3D 01 06 CMP   [X+1],0x6
    1C18: A0 31    JZ    0x1C4A
    1C1A: 3D 00 00 CMP   [X+0],0x0
    1C1D: B0 06    JNZ   0x1C24
    1C1F: 3D 01 07 CMP   [X+1],0x7
    1C22: A0 30    JZ    0x1C53
    1C24: 80 35    JMP   0x1C5A
(0051) 	{
(0052) 		case 2:
(0053) 		{
(0054) 			LED_1_7_Switch(val);
    1C26: 10       PUSH  X
    1C27: 52 FC    MOV   A,[X-4]
    1C29: 7C 05 12 LCALL _LED_1_7_Start|_LED_1_7_Off|_LED_1_7_Stop|LED_1_7_Stop|LED_1_7_Switch|wPWM16_1_ReadPulseWidth|_wPWM16_1_ReadPulseWidth|wPWM16_1_ReadCounter|_PWM16_1_wReadPulseWidth|_wPWM16_1_ReadCounter|_LED_1_7_Switch|_PWM16_1_wReadCounter|LED_1_7_On|LED_1_7_Start|...
    1C2C: 20       POP   X
(0055) 		}
(0056) 		break;
    1C2D: 80 2C    JMP   0x1C5A
(0057) 		case 3:
(0058) 		{
(0059) 			LED_1_1_Switch(val);
    1C2F: 10       PUSH  X
    1C30: 52 FC    MOV   A,[X-4]
    1C32: 7C 05 56 LCALL _LED_1_1_Switch|LED_1_4_Invert|LED_1_1_On|LED_1_1_Switch|LED_1_4_GetState|_LED_1_1_Off|_LED_1_1_Start|_LED_1_1_Stop|LED_1_1_Stop|LED_1_1_Start|LED_1_1_Off
    1C35: 20       POP   X
(0060) 		}
(0061) 		break;
    1C36: 80 23    JMP   0x1C5A
(0062) 		case 4:
(0063) 		{
(0064) 			LED_1_5_Switch(val);
    1C38: 10       PUSH  X
    1C39: 52 FC    MOV   A,[X-4]
    1C3B: 7C 05 34 LCALL LED_1_5_On|LED_1_5_Stop|_LED_1_5_Stop|LED_1_5_Start|LED_1_6_GetState|LED_1_5_Off|_LED_1_5_Switch|_LED_1_5_Start|LED_1_5_Switch|LED_1_6_Invert|_LED_1_5_Off
    1C3E: 20       POP   X
(0065) 		}
(0066) 		break;
    1C3F: 80 1A    JMP   0x1C5A
(0067) 		case 5:
(0068) 		{
(0069) 			LED_1_0_Switch(val);
    1C41: 10       PUSH  X
    1C42: 52 FC    MOV   A,[X-4]
    1C44: 7C 05 67 LCALL _LED_1_0_Off|LED_1_0_Stop|_LED_1_0_Stop|LED_1_1_GetState|LED_1_0_On|_LED_1_0_Start|LED_1_0_Switch|LED_1_0_Start|LED_1_1_Invert|_LED_1_0_Switch
    1C47: 20       POP   X
(0070) 		}
(0071) 		break;
    1C48: 80 11    JMP   0x1C5A
(0072) 		case 6:
(0073) 		{
(0074) 			LED_1_4_Switch(val);
    1C4A: 10       PUSH  X
    1C4B: 52 FC    MOV   A,[X-4]
    1C4D: 7C 05 45 LCALL LED_1_4_Off|LED_1_4_On|LED_1_4_Stop|_LED_1_4_Switch|_LED_1_4_Start|_LED_1_4_Stop|LED_1_4_Switch|LED_1_5_Invert|LED_1_5_GetState|_LED_1_4_Off|LED_1_4_Start
    1C50: 20       POP   X
(0075) 		}
(0076) 		break;
    1C51: 80 08    JMP   0x1C5A
(0077) 		case 7:
(0078) 		{
(0079) 			LED_1_6_Switch(val);
    1C53: 10       PUSH  X
    1C54: 52 FC    MOV   A,[X-4]
    1C56: 7C 05 23 LCALL LED_1_7_GetState|LED_1_6_Start|_LED_1_6_Off|_LED_1_6_Switch|LED_1_6_Off|_LED_1_6_Start|LED_1_6_Switch|LED_1_7_Invert|_LED_1_6_Stop|LED_1_6_On|LED_1_6_Stop
    1C59: 20       POP   X
(0080) 		}
(0081) 		break;
    1C5A: 38 FE    ADD   SP,0xFE
    1C5C: 20       POP   X
    1C5D: 7F       RET   
(0082) 	}
(0083) #endif
(0084) }
(0085) 
(0086) void PPM_Start_One_PPM_Train(void )
(0087) {
(0088) 	ppm_Run=TRUE;
_PPM_Start_One_PPM_Train:
    1C5E: 55 06 01 MOV   [ppm_Run],0x1
(0089) 	PPM_RECON_OUT_PIN;	//reconect i/O PIN to PWM
    1C61: 41 B4 FC AND   REG[0xB4],0xFC
(0090) 	ppm_Nr=1;//reset counter
    1C64: 55 05 01 MOV   [ppm_Nr],0x1
(0091) 	PWM16_1_WritePeriod(ppm_Data[0]+PPM_OUT_PULSE_GAP_LEN_US);//load pulse len of first channel
    1C67: 51 66    MOV   A,[ppm_Data+1]
    1C69: 01 90    ADD   A,0x90
    1C6B: 53 16    MOV   [__r1],A
    1C6D: 51 65    MOV   A,[ppm_Data]
    1C6F: 09 01    ADC   A,0x1
    1C71: 10       PUSH  X
    1C72: 08       PUSH  A
    1C73: 51 16    MOV   A,[__r1]
    1C75: 20       POP   X
    1C76: 7C 05 06 LCALL _PWM16_1_WritePeriod
(0092) 	//start the PWM Module
(0093) 	PWM16_1_Start();
    1C79: 7C 04 FE LCALL _PWM16_1_Start|_PWM16_1_DisableInt|PWM16_1_Start
    1C7C: 20       POP   X
    1C7D: 7F       RET   
(0094) }
(0095) 
(0096) /*inerrupt service routine for the PWM module
(0097) *will be called on TC
(0098) *-load pulse len of the next PPM pulse
(0099) *- increase pulse counter
(0100) */
(0101) #pragma interrupt_handler PWM16_1_CMP_ISR
(0102) void PWM16_1_CMP_ISR(void )
(0103) {
_PWM16_1_CMP_ISR:
    1C7E: 08       PUSH  A
    1C7F: 51 17    MOV   A,[__r0]
    1C81: 08       PUSH  A
    1C82: 51 16    MOV   A,[__r1]
    1C84: 08       PUSH  A
    1C85: 51 15    MOV   A,[__r2]
    1C87: 08       PUSH  A
    1C88: 51 14    MOV   A,[__r3]
    1C8A: 08       PUSH  A
    1C8B: 51 13    MOV   A,[__r4]
    1C8D: 08       PUSH  A
    1C8E: 51 12    MOV   A,[__r5]
    1C90: 08       PUSH  A
    1C91: 51 11    MOV   A,[__r6]
    1C93: 08       PUSH  A
    1C94: 51 10    MOV   A,[__r7]
    1C96: 08       PUSH  A
    1C97: 51 0F    MOV   A,[__r8]
    1C99: 08       PUSH  A
    1C9A: 51 0E    MOV   A,[__r9]
    1C9C: 08       PUSH  A
    1C9D: 51 0D    MOV   A,[__r10]
    1C9F: 08       PUSH  A
    1CA0: 51 0C    MOV   A,[__r11]
    1CA2: 08       PUSH  A
    1CA3: 51 0B    MOV   A,[__rX]
    1CA5: 08       PUSH  A
    1CA6: 51 0A    MOV   A,[__rY]
    1CA8: 08       PUSH  A
    1CA9: 51 09    MOV   A,[__rZ]
    1CAB: 08       PUSH  A
(0104) 	if (TC_IRQ)
    1CAC: 3C 8E 00 CMP   [TC_IRQ],0x0
    1CAF: A0 53    JZ    0x1D03
(0105) 	{
(0106) 		//Sync is send out we are done 
(0107) 		if (ppm_Nr==PPM_PULSE_COUNT+2) 
    1CB1: 3C 05 09 CMP   [ppm_Nr],0x9
    1CB4: B0 0B    JNZ   0x1CC0
(0108) 			{ //we are done 
(0109) 				PWM16_1_Stop();
    1CB6: 10       PUSH  X
    1CB7: 7C 05 02 LCALL _PWM16_1_Stop
    1CBA: 20       POP   X
(0110) 				ppm_Run=0;		//signal that we are done
    1CBB: 55 06 00 MOV   [ppm_Run],0x0
(0111) 			}
    1CBE: 80 2F    JMP   0x1CEE
(0112) 		else if (ppm_Nr==PPM_PULSE_COUNT+1) 
    1CC0: 3C 05 08 CMP   [ppm_Nr],0x8
    1CC3: B0 06    JNZ   0x1CCA
(0113) 			{ //we are done 
(0114) 				PPM_DISCON_SET_OUT_PIN_HIGH;	//disconect IO pin from PWM and set to High
    1CC5: 43 B4 0F OR    REG[0xB4],0xF
(0115) 			}
    1CC8: 80 25    JMP   0x1CEE
(0116) 		//load pulse len of next chanal
(0117) 		else 
(0118) 		{	//check if that is the last chanel is done
(0119) 			if(ppm_Nr==PPM_PULSE_COUNT)
    1CCA: 3C 05 07 CMP   [ppm_Nr],0x7
    1CCD: B0 0C    JNZ   0x1CDA
(0120) 			{
(0121) 				PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN); 
    1CCF: 10       PUSH  X
    1CD0: 57 17    MOV   X,0x17
    1CD2: 50 70    MOV   A,0x70
    1CD4: 7C 05 06 LCALL _PWM16_1_WritePeriod
    1CD7: 20       POP   X
(0122) 			}
    1CD8: 80 15    JMP   0x1CEE
(0123) 			else 
(0124) 			{
(0125) 				PWM16_1_WritePeriod(ppm_Data[ppm_Nr]+PPM_OUT_PULSE_GAP_LEN_US);//load pulse len of the next pulse
    1CDA: 5F 16 05 MOV   [__r1],[ppm_Nr]
    1CDD: 92 99    CALL  0x1F78
    1CDF: 40       NOP   
    1CE0: 01 90    ADD   A,0x90
    1CE2: 53 16    MOV   [__r1],A
    1CE4: 0E 17 01 ADC   [__r0],0x1
    1CE7: 10       PUSH  X
    1CE8: 58 17    MOV   X,[__r0]
    1CEA: 7C 05 06 LCALL _PWM16_1_WritePeriod
    1CED: 20       POP   X
(0126) 			}
(0127) 		}
(0128) 		ppm_Nr++;
    1CEE: 76 05    INC   [ppm_Nr]
(0129) 		Switch_LED(TRUE);
    1CF0: 50 01    MOV   A,0x1
    1CF2: 08       PUSH  A
    1CF3: 9E E8    CALL  _Switch_LED
    1CF5: 38 FF    ADD   SP,0xFF
(0130) 		TC_IRQ=FALSE;
    1CF7: 55 8E 00 MOV   [TC_IRQ],0x0
(0131) 		PWM16_1_FUNC_MSB_REG=PWM_CM_IRQ;
    1CFA: 71 10    OR    F,0x10
    1CFC: 62 24 39 MOV   REG[0x24],0x39
(0132) 	}
    1CFF: 70 CF    AND   F,0xCF
    1D01: 80 12    JMP   0x1D14
(0133) 	else 
(0134) 	{
(0135) 		Switch_LED(FALSE);
    1D03: 50 00    MOV   A,0x0
    1D05: 08       PUSH  A
    1D06: 9E D5    CALL  _Switch_LED
    1D08: 38 FF    ADD   SP,0xFF
(0136) 		TC_IRQ=TRUE;
    1D0A: 55 8E 01 MOV   [TC_IRQ],0x1
(0137) 		PWM16_1_FUNC_MSB_REG=PWM_TC_IRQ;
    1D0D: 71 10    OR    F,0x10
    1D0F: 62 24 31 MOV   REG[0x24],0x31
(0138) 	}
    1D12: 70 CF    AND   F,0xCF
(0139) }//END OFF PWM16_1_CMP_ISR
(0140) 
FILE: E:\WORKSP~1\cypress\DS400A~1\DSM_RE~1\timer.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "timer.h"
(0003) 
(0004) //WORD systic=0;   //will be incremented once per 1,953125 ms
(0005) WORD cnt_last;
(0006) tmr_callback_t timer_cb=0;
(0007) 
(0008) //a delay
(0009) void Timer_Wait_ms(BYTE ms)
(0010) {
_Timer_Wait_ms:
  ms                   --> X-4
    1D43: 10       PUSH  X
    1D44: 4F       MOV   X,SP
(0011) SleepTimer_1_TickWait(ms>>2);
    1D45: 52 FC    MOV   A,[X-4]
    1D47: 67       ASR   A
    1D48: 67       ASR   A
    1D49: 21 3F    AND   A,0x3F
    1D4B: 10       PUSH  X
    1D4C: 7C 04 C5 LCALL _SleepTimer_1_TickWait|_SleepTimer_1_Stop|SleepTimer_1_TickWait|_SleepTimer_1_SetInterval
    1D4F: 20       POP   X
    1D50: 20       POP   X
    1D51: 7F       RET   
(0012) }
(0013) 
(0014) 
(0015) 
(0016) void Timer_init (void)
(0017) {
(0018) timer_cb=0;
_Timer_init:
    1D52: 55 08 2A MOV   [timer_cb+1],0x2A
    1D55: 55 07 03 MOV   [timer_cb],0x3
(0019) SleepTimer_1_EnableInt();
    1D58: 10       PUSH  X
    1D59: 7C 04 B4 LCALL _SleepTimer_1_EnableInt
(0020) SleepTimer_1_Start();
    1D5C: 7C 04 B8 LCALL _SleepTimer_1_DisableInt|_SleepTimer_1_Start|SleepTimer_1_Start
(0021) Timer8_1_EnableInt();
    1D5F: 7C 04 7F LCALL _Timer8_1_EnableInt
    1D62: 20       POP   X
    1D63: 7F       RET   
(0022) }
(0023) 
(0024) 
(0025) 
(0026) 
(0027) void Timer_SetCallback(tmr_callback_t cb_fn)
(0028) {
_Timer_SetCallback:
  cb_fn                --> X-5
    1D64: 10       PUSH  X
    1D65: 4F       MOV   X,SP
(0029) 	timer_cb=cb_fn;
    1D66: 52 FC    MOV   A,[X-4]
    1D68: 53 08    MOV   [timer_cb+1],A
    1D6A: 52 FB    MOV   A,[X-5]
    1D6C: 53 07    MOV   [timer_cb],A
    1D6E: 20       POP   X
    1D6F: 7F       RET   
(0030) }
(0031) 
(0032) //#pragma interrupt_handler Sleep_Timer_Interrupt
(0033) 
(0034) /*/interrupt handler on TC of LSB
(0035) /void Sleep_Timer_Interrupt(void )
(0036) {
(0037) 	systic++;
(0038) }*/
(0039) 
(0040) #pragma interrupt_handler Timer8_1_Interrupt
(0041) 
(0042) void Timer8_1_Interrupt(void)
(0043) {
_Timer8_1_Interrupt:
    1D70: 08       PUSH  A
    1D71: 51 17    MOV   A,[__r0]
    1D73: 08       PUSH  A
    1D74: 51 16    MOV   A,[__r1]
    1D76: 08       PUSH  A
    1D77: 51 15    MOV   A,[__r2]
    1D79: 08       PUSH  A
    1D7A: 51 14    MOV   A,[__r3]
    1D7C: 08       PUSH  A
    1D7D: 51 13    MOV   A,[__r4]
    1D7F: 08       PUSH  A
    1D80: 51 12    MOV   A,[__r5]
    1D82: 08       PUSH  A
    1D83: 51 11    MOV   A,[__r6]
    1D85: 08       PUSH  A
    1D86: 51 10    MOV   A,[__r7]
    1D88: 08       PUSH  A
    1D89: 51 0F    MOV   A,[__r8]
    1D8B: 08       PUSH  A
    1D8C: 51 0E    MOV   A,[__r9]
    1D8E: 08       PUSH  A
    1D8F: 51 0D    MOV   A,[__r10]
    1D91: 08       PUSH  A
    1D92: 51 0C    MOV   A,[__r11]
    1D94: 08       PUSH  A
    1D95: 51 0B    MOV   A,[__rX]
    1D97: 08       PUSH  A
    1D98: 51 0A    MOV   A,[__rY]
    1D9A: 08       PUSH  A
    1D9B: 51 09    MOV   A,[__rZ]
    1D9D: 08       PUSH  A
(0044) 	if(timer_cb!=0)
    1D9E: 5F 16 08 MOV   [__r1],[timer_cb+1]
    1DA1: 51 07    MOV   A,[timer_cb]
    1DA3: 10       PUSH  X
    1DA4: 58 16    MOV   X,[__r1]
    1DA6: 08       PUSH  A
    1DA7: 28       ROMX  
    1DA8: 53 17    MOV   [__r0],A
    1DAA: 18       POP   A
    1DAB: 75       INC   X
    1DAC: 09 00    ADC   A,0x0
    1DAE: 28       ROMX  
    1DAF: 20       POP   X
    1DB0: 3C 17 00 CMP   [__r0],0x0
    1DB3: B0 05    JNZ   0x1DB9
    1DB5: 39 00    CMP   A,0x0
    1DB7: A0 10    JZ    0x1DC8
(0045) 		timer_cb();
    1DB9: 5F 16 08 MOV   [__r1],[timer_cb+1]
    1DBC: 5F 17 07 MOV   [__r0],[timer_cb]
    1DBF: 10       PUSH  X
    1DC0: 58 16    MOV   X,[__r1]
    1DC2: 51 17    MOV   A,[__r0]
    1DC4: 7C 1F 5F LCALL __plcall
    1DC7: 20       POP   X
    1DC8: 18       POP   A
    1DC9: 53 09    MOV   [__rZ],A
    1DCB: 18       POP   A
    1DCC: 53 0A    MOV   [__rY],A
    1DCE: 18       POP   A
    1DCF: 53 0B    MOV   [__rX],A
    1DD1: 18       POP   A
    1DD2: 53 0C    MOV   [__r11],A
    1DD4: 18       POP   A
    1DD5: 53 0D    MOV   [__r10],A
    1DD7: 18       POP   A
    1DD8: 53 0E    MOV   [__r9],A
    1DDA: 18       POP   A
    1DDB: 53 0F    MOV   [__r8],A
    1DDD: 18       POP   A
    1DDE: 53 10    MOV   [__r7],A
    1DE0: 18       POP   A
    1DE1: 53 11    MOV   [__r6],A
    1DE3: 18       POP   A
    1DE4: 53 12    MOV   [__r5],A
    1DE6: 18       POP   A
    1DE7: 53 13    MOV   [__r4],A
    1DE9: 18       POP   A
    1DEA: 53 14    MOV   [__r3],A
    1DEC: 18       POP   A
    1DED: 53 15    MOV   [__r2],A
    1DEF: 18       POP   A
    1DF0: 53 16    MOV   [__r1],A
    1DF2: 18       POP   A
    1DF3: 53 17    MOV   [__r0],A
    1DF5: 18       POP   A
    1DF6: 7E       RETI  
FILE: lib\psocgpioint.asm               (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
1DF7: 7D 0A 53 LJMP  _GPIO_ISR          (0059)    ljmp _GPIO_ISR
                                        (0060)    ;---------------------------------------------------
                                        (0061)    ; Insert your custom code above this banner
                                        (0062)    ;---------------------------------------------------
                                        (0063)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0064) 
1DFA: 7E       RETI                     (0065)    reti
                                        (0066) 
                                        (0067) 
                                        (0068) ; end of file PSoCGPIOINT.asm
__plcall:
    1F5F: 53 0B    MOV   [__rX],A
    1F61: 28       ROMX  
    1F62: 08       PUSH  A
    1F63: 51 0B    MOV   A,[__rX]
    1F65: 75       INC   X
    1F66: 09 00    ADC   A,0x0
    1F68: 28       ROMX  
    1F69: 08       PUSH  A
    1F6A: 7F       RET   
    1F6B: 30       HALT  
<created procedures>:
    1F6C: 52 00    MOV   A,[X+0]
    1F6E: 53 16    MOV   [__r1],A
    1F70: 55 17 00 MOV   [__r0],0x0
    1F73: 65 16    ASL   [__r1]
    1F75: 6B 17    RLC   [__r0]
    1F77: 7F       RET   
    1F78: 65 16    ASL   [__r1]
    1F7A: 06 16 65 ADD   [__r1],0x65
    1F7D: 3E 16    MVI   A,[__r1]
    1F7F: 53 17    MOV   [__r0],A
    1F81: 3E 16    MVI   A,[__r1]
    1F83: 7F       RET   
    1F84: 5F 16 74 MOV   [__r1],[config+1]
    1F87: 55 17 00 MOV   [__r0],0x0
    1F8A: 5F 15 73 MOV   [__r2],[config]
    1F8D: 50 00    MOV   A,0x0
    1F8F: 02 16    ADD   A,[__r1]
    1F91: 7F       RET   
    1F92: 52 00    MOV   A,[X+0]
    1F94: 64       ASL   A
    1F95: 01 22    ADD   A,0x22
    1F97: 53 16    MOV   [__r1],A
    1F99: 3E 16    MVI   A,[__r1]
    1F9B: 67       ASR   A
    1F9C: 67       ASR   A
    1F9D: 7F       RET   
